import { randomUUID } from "crypto";

export interface KubernetesAbuseResult {
  id: string;
  clusterContext: string;
  namespace: string;
  testDate: Date;
  apiAbuseVectors: APIAbuseVector[];
  lateralMovementPaths: K8sLateralMovement[];
  rbacEscalations: RBACEscalation[];
  networkPolicies: NetworkPolicyAnalysis;
  secretExposures: SecretExposure[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
}

export interface APIAbuseVector {
  id: string;
  name: string;
  apiEndpoint: string;
  method: string;
  description: string;
  severity: "critical" | "high" | "medium" | "low";
  exploitability: "trivial" | "easy" | "moderate" | "difficult";
  requiredPermissions: string[];
  exploitSteps: string[];
  impact: string;
  remediation: string;
  mitreId: string;
  tested: boolean;
  exploitable: boolean;
}

export interface K8sLateralMovement {
  id: string;
  sourcePod: string;
  sourceNamespace: string;
  targetPod: string;
  targetNamespace: string;
  technique: string;
  networkPath: string;
  serviceAccountUsed?: string;
  severity: "critical" | "high" | "medium" | "low";
  mitreId: string;
  exploitSteps: string[];
}

export interface RBACEscalation {
  id: string;
  name: string;
  sourceRole: string;
  targetRole: string;
  escalationPath: string[];
  requiredVerbs: string[];
  targetResources: string[];
  severity: "critical" | "high" | "medium" | "low";
  mitreId: string;
  remediation: string;
}

export interface NetworkPolicyAnalysis {
  hasDefaultDeny: boolean;
  podsToPodCommunication: "unrestricted" | "partially-restricted" | "fully-restricted";
  egressRestrictions: "unrestricted" | "partially-restricted" | "fully-restricted";
  ingressRestrictions: "unrestricted" | "partially-restricted" | "fully-restricted";
  gaps: string[];
}

export interface SecretExposure {
  id: string;
  secretName: string;
  namespace: string;
  exposureType: string;
  severity: "critical" | "high" | "medium" | "low";
  accessibleBy: string[];
  mitreId: string;
}

export interface MitreMapping {
  techniqueId: string;
  techniqueName: string;
  tactic: string;
  description: string;
}

export interface K8sClusterConfig {
  clusterContext: string;
  namespace: string;
  pods?: PodInfo[];
  serviceAccounts?: ServiceAccountInfo[];
  roles?: RoleInfo[];
  roleBindings?: RoleBindingInfo[];
  networkPolicies?: NetworkPolicyInfo[];
  secrets?: SecretInfo[];
}

export interface PodInfo {
  name: string;
  namespace: string;
  serviceAccount: string;
  containers: ContainerInfo[];
  hostNetwork?: boolean;
  hostPID?: boolean;
  hostIPC?: boolean;
}

export interface ContainerInfo {
  name: string;
  image: string;
  privileged?: boolean;
  capabilities?: string[];
  volumeMounts?: VolumeMount[];
}

export interface VolumeMount {
  name: string;
  mountPath: string;
  readOnly?: boolean;
}

export interface ServiceAccountInfo {
  name: string;
  namespace: string;
  automountToken: boolean;
  secrets?: string[];
}

export interface RoleInfo {
  name: string;
  namespace?: string;
  isClusterRole: boolean;
  rules: PolicyRule[];
}

export interface PolicyRule {
  apiGroups: string[];
  resources: string[];
  verbs: string[];
  resourceNames?: string[];
}

export interface RoleBindingInfo {
  name: string;
  namespace?: string;
  isClusterRoleBinding: boolean;
  roleRef: string;
  subjects: Subject[];
}

export interface Subject {
  kind: string;
  name: string;
  namespace?: string;
}

export interface NetworkPolicyInfo {
  name: string;
  namespace: string;
  podSelector: Record<string, string>;
  policyTypes: string[];
  ingressRules: number;
  egressRules: number;
}

export interface SecretInfo {
  name: string;
  namespace: string;
  type: string;
  accessibleByPods: string[];
}

const API_ABUSE_VECTORS: Omit<APIAbuseVector, "id" | "tested" | "exploitable">[] = [
  {
    name: "Pod Creation with Host Path",
    apiEndpoint: "/api/v1/namespaces/{ns}/pods",
    method: "POST",
    description: "Create pods mounting sensitive host paths",
    severity: "critical",
    exploitability: "easy",
    requiredPermissions: ["pods/create"],
    exploitSteps: [
      "Create pod spec with hostPath volume",
      "Mount /etc, /var, or root filesystem",
      "Access host filesystem from pod",
    ],
    impact: "Full host filesystem access",
    remediation: "Use PodSecurityPolicy/PSS to restrict hostPath",
    mitreId: "T1611",
  },
  {
    name: "Privileged Pod Creation",
    apiEndpoint: "/api/v1/namespaces/{ns}/pods",
    method: "POST",
    description: "Create privileged pods for container escape",
    severity: "critical",
    exploitability: "easy",
    requiredPermissions: ["pods/create"],
    exploitSteps: [
      "Create pod with privileged: true",
      "Deploy pod to cluster",
      "Use privileged access to escape container",
    ],
    impact: "Container escape to host",
    remediation: "Enforce PodSecurityPolicy/PSS to block privileged pods",
    mitreId: "T1611",
  },
  {
    name: "Secret Enumeration",
    apiEndpoint: "/api/v1/secrets",
    method: "GET",
    description: "List and read secrets across namespaces",
    severity: "high",
    exploitability: "trivial",
    requiredPermissions: ["secrets/list", "secrets/get"],
    exploitSteps: [
      "List all secrets: kubectl get secrets -A",
      "Read secret data: kubectl get secret X -o yaml",
      "Decode base64 values",
    ],
    impact: "Access to credentials and sensitive data",
    remediation: "Restrict secret access with RBAC",
    mitreId: "T1552.007",
  },
  {
    name: "Service Account Token Theft",
    apiEndpoint: "/api/v1/namespaces/{ns}/serviceaccounts/{sa}/token",
    method: "POST",
    description: "Create tokens for service accounts",
    severity: "high",
    exploitability: "moderate",
    requiredPermissions: ["serviceaccounts/token/create"],
    exploitSteps: [
      "Identify high-privilege service account",
      "Create token for service account",
      "Use token to impersonate service account",
    ],
    impact: "Privilege escalation via service account",
    remediation: "Restrict token creation permissions",
    mitreId: "T1550.001",
  },
  {
    name: "Pod Exec for Remote Code Execution",
    apiEndpoint: "/api/v1/namespaces/{ns}/pods/{pod}/exec",
    method: "POST",
    description: "Execute commands in running pods",
    severity: "high",
    exploitability: "trivial",
    requiredPermissions: ["pods/exec"],
    exploitSteps: [
      "Identify target pod",
      "Execute command: kubectl exec -it pod -- /bin/sh",
      "Access pod resources and network",
    ],
    impact: "Code execution in container context",
    remediation: "Restrict exec permissions to authorized users",
    mitreId: "T1609",
  },
  {
    name: "ConfigMap with Secrets",
    apiEndpoint: "/api/v1/namespaces/{ns}/configmaps",
    method: "GET",
    description: "Access sensitive data stored in ConfigMaps",
    severity: "medium",
    exploitability: "trivial",
    requiredPermissions: ["configmaps/list", "configmaps/get"],
    exploitSteps: [
      "List ConfigMaps: kubectl get configmaps",
      "Read ConfigMap data for credentials",
      "Use exposed credentials",
    ],
    impact: "Credential exposure",
    remediation: "Store sensitive data in Secrets, not ConfigMaps",
    mitreId: "T1552.001",
  },
];

const RBAC_ESCALATION_PATHS: Omit<RBACEscalation, "id">[] = [
  {
    name: "Create Privileged Pod",
    sourceRole: "pods/create",
    targetRole: "cluster-admin",
    escalationPath: [
      "Create privileged pod with hostPID",
      "Access host process namespace",
      "Read kubelet credentials",
      "Impersonate cluster-admin",
    ],
    requiredVerbs: ["create"],
    targetResources: ["pods"],
    severity: "critical",
    mitreId: "T1078.004",
    remediation: "Use Pod Security Standards to restrict pod creation",
  },
  {
    name: "Bind Cluster-Admin Role",
    sourceRole: "clusterrolebindings/create",
    targetRole: "cluster-admin",
    escalationPath: [
      "Create ClusterRoleBinding",
      "Bind cluster-admin to current service account",
      "Gain full cluster access",
    ],
    requiredVerbs: ["create", "bind"],
    targetResources: ["clusterrolebindings"],
    severity: "critical",
    mitreId: "T1098.003",
    remediation: "Restrict role binding creation permissions",
  },
  {
    name: "Impersonate Service Account",
    sourceRole: "users/impersonate",
    targetRole: "any service account",
    escalationPath: [
      "Identify high-privilege service account",
      "Use impersonation headers",
      "Execute requests as target SA",
    ],
    requiredVerbs: ["impersonate"],
    targetResources: ["users", "serviceaccounts"],
    severity: "critical",
    mitreId: "T1550.001",
    remediation: "Restrict impersonation to specific identities",
  },
  {
    name: "Escalate Verb Abuse",
    sourceRole: "roles/escalate",
    targetRole: "higher privilege role",
    escalationPath: [
      "Create or modify Role with escalate verb",
      "Add additional permissions to Role",
      "Bind modified Role to self",
    ],
    requiredVerbs: ["escalate", "update"],
    targetResources: ["roles", "clusterroles"],
    severity: "critical",
    mitreId: "T1098.003",
    remediation: "Never grant escalate verb",
  },
  {
    name: "CSR Signing Attack",
    sourceRole: "certificatesigningrequests/create",
    targetRole: "cluster-admin",
    escalationPath: [
      "Create CSR for system:masters group",
      "Sign CSR (if auto-approved)",
      "Use certificate for cluster-admin access",
    ],
    requiredVerbs: ["create"],
    targetResources: ["certificatesigningrequests"],
    severity: "critical",
    mitreId: "T1552.004",
    remediation: "Disable CSR auto-approval, restrict CSR creation",
  },
];

class KubernetesPentestService {
  async testKubernetesAbuse(config: K8sClusterConfig): Promise<KubernetesAbuseResult> {
    const id = `k8s-pentest-${randomUUID().slice(0, 8)}`;
    const apiAbuseVectors: APIAbuseVector[] = [];
    const lateralMovementPaths: K8sLateralMovement[] = [];
    const rbacEscalations: RBACEscalation[] = [];
    const secretExposures: SecretExposure[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    for (const role of config.roles || []) {
      for (const rule of role.rules) {
        if (rule.resources.includes("pods") && rule.verbs.includes("create")) {
          apiAbuseVectors.push(this.createAPIVector(API_ABUSE_VECTORS[0], true, true));
          apiAbuseVectors.push(this.createAPIVector(API_ABUSE_VECTORS[1], true, true));
        }

        if (rule.resources.includes("secrets") && 
            (rule.verbs.includes("get") || rule.verbs.includes("list"))) {
          apiAbuseVectors.push(this.createAPIVector(API_ABUSE_VECTORS[2], true, true));
        }

        if (rule.resources.includes("pods/exec") && rule.verbs.includes("create")) {
          apiAbuseVectors.push(this.createAPIVector(API_ABUSE_VECTORS[4], true, true));
        }

        if ((rule.resources.includes("clusterrolebindings") || rule.resources.includes("rolebindings")) &&
            (rule.verbs.includes("create") || rule.verbs.includes("bind"))) {
          rbacEscalations.push({
            id: `rbac-${randomUUID().slice(0, 8)}`,
            ...RBAC_ESCALATION_PATHS[1],
          });
        }

        if (rule.verbs.includes("impersonate")) {
          rbacEscalations.push({
            id: `rbac-${randomUUID().slice(0, 8)}`,
            ...RBAC_ESCALATION_PATHS[2],
          });
        }

        if (rule.verbs.includes("escalate")) {
          rbacEscalations.push({
            id: `rbac-${randomUUID().slice(0, 8)}`,
            ...RBAC_ESCALATION_PATHS[3],
          });
        }
      }
    }

    for (const pod of config.pods || []) {
      if (pod.hostNetwork || pod.hostPID || pod.hostIPC) {
        lateralMovementPaths.push({
          id: `lateral-${randomUUID().slice(0, 8)}`,
          sourcePod: pod.name,
          sourceNamespace: pod.namespace,
          targetPod: "host processes",
          targetNamespace: "N/A",
          technique: pod.hostPID ? "Host PID namespace access" : 
                     pod.hostNetwork ? "Host network access" : "Host IPC access",
          networkPath: "Direct host access",
          serviceAccountUsed: pod.serviceAccount,
          severity: "critical",
          mitreId: "T1611",
          exploitSteps: [
            `Pod ${pod.name} has host namespace access`,
            "Access host processes/network/IPC",
            "Lateral movement to other pods via host",
          ],
        });
      }

      for (const container of pod.containers) {
        if (container.privileged) {
          lateralMovementPaths.push({
            id: `lateral-${randomUUID().slice(0, 8)}`,
            sourcePod: pod.name,
            sourceNamespace: pod.namespace,
            targetPod: "All pods via host",
            targetNamespace: "*",
            technique: "Privileged container escape",
            networkPath: "Container -> Host -> All pods",
            severity: "critical",
            mitreId: "T1611",
            exploitSteps: [
              "Escape privileged container to host",
              "Access container runtime socket",
              "Interact with any container on node",
            ],
          });
        }
      }
    }

    for (const secret of config.secrets || []) {
      if (secret.accessibleByPods.length > 1) {
        secretExposures.push({
          id: `secret-${randomUUID().slice(0, 8)}`,
          secretName: secret.name,
          namespace: secret.namespace,
          exposureType: "Over-shared secret",
          severity: "medium",
          accessibleBy: secret.accessibleByPods,
          mitreId: "T1552.007",
        });
      }

      if (secret.type === "kubernetes.io/service-account-token") {
        secretExposures.push({
          id: `secret-${randomUUID().slice(0, 8)}`,
          secretName: secret.name,
          namespace: secret.namespace,
          exposureType: "Service account token accessible",
          severity: "high",
          accessibleBy: secret.accessibleByPods,
          mitreId: "T1528",
        });
      }
    }

    for (const sa of config.serviceAccounts || []) {
      if (sa.automountToken) {
        secretExposures.push({
          id: `secret-${randomUUID().slice(0, 8)}`,
          secretName: `${sa.name}-token`,
          namespace: sa.namespace,
          exposureType: "Auto-mounted service account token",
          severity: "medium",
          accessibleBy: [`pods using ${sa.name}`],
          mitreId: "T1528",
        });
      }
    }

    const networkPolicies = this.analyzeNetworkPolicies(config.networkPolicies || [], config.namespace);

    for (const vector of apiAbuseVectors) {
      if (!mitreAttackMappings.some(m => m.techniqueId === vector.mitreId)) {
        mitreAttackMappings.push({
          techniqueId: vector.mitreId,
          techniqueName: vector.name,
          tactic: "execution",
          description: vector.description,
        });
      }
    }

    for (const path of lateralMovementPaths) {
      if (!mitreAttackMappings.some(m => m.techniqueId === path.mitreId)) {
        mitreAttackMappings.push({
          techniqueId: path.mitreId,
          techniqueName: path.technique,
          tactic: "lateral-movement",
          description: path.technique,
        });
      }
    }

    for (const esc of rbacEscalations) {
      if (!mitreAttackMappings.some(m => m.techniqueId === esc.mitreId)) {
        mitreAttackMappings.push({
          techniqueId: esc.mitreId,
          techniqueName: esc.name,
          tactic: "privilege-escalation",
          description: esc.escalationPath.join(" -> "),
        });
      }
    }

    const riskScore = this.calculateRiskScore(
      apiAbuseVectors, 
      lateralMovementPaths, 
      rbacEscalations, 
      secretExposures,
      networkPolicies
    );
    
    const recommendations = this.generateRecommendations(
      apiAbuseVectors,
      lateralMovementPaths,
      rbacEscalations,
      secretExposures,
      networkPolicies
    );

    return {
      id,
      clusterContext: config.clusterContext,
      namespace: config.namespace,
      testDate: new Date(),
      apiAbuseVectors,
      lateralMovementPaths,
      rbacEscalations,
      networkPolicies,
      secretExposures,
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        apiVectorsFound: apiAbuseVectors.length,
        lateralMovementPathsFound: lateralMovementPaths.length,
        rbacEscalationsFound: rbacEscalations.length,
        secretExposuresFound: secretExposures.length,
        podsAnalyzed: config.pods?.length || 0,
        rolesAnalyzed: config.roles?.length || 0,
      },
    };
  }

  private createAPIVector(
    template: Omit<APIAbuseVector, "id" | "tested" | "exploitable">,
    tested: boolean,
    exploitable: boolean
  ): APIAbuseVector {
    return {
      ...template,
      id: `api-${randomUUID().slice(0, 8)}`,
      tested,
      exploitable,
    };
  }

  private analyzeNetworkPolicies(
    policies: NetworkPolicyInfo[],
    namespace: string
  ): NetworkPolicyAnalysis {
    const gaps: string[] = [];
    
    if (policies.length === 0) {
      gaps.push("No NetworkPolicies defined - all pod-to-pod communication is unrestricted");
      return {
        hasDefaultDeny: false,
        podsToPodCommunication: "unrestricted",
        egressRestrictions: "unrestricted",
        ingressRestrictions: "unrestricted",
        gaps,
      };
    }

    const hasDefaultDenyIngress = policies.some(p => 
      Object.keys(p.podSelector).length === 0 && 
      p.policyTypes.includes("Ingress") && 
      p.ingressRules === 0
    );

    const hasDefaultDenyEgress = policies.some(p =>
      Object.keys(p.podSelector).length === 0 &&
      p.policyTypes.includes("Egress") &&
      p.egressRules === 0
    );

    if (!hasDefaultDenyIngress) {
      gaps.push("Missing default deny ingress policy");
    }

    if (!hasDefaultDenyEgress) {
      gaps.push("Missing default deny egress policy - pods can access external networks");
    }

    return {
      hasDefaultDeny: hasDefaultDenyIngress && hasDefaultDenyEgress,
      podsToPodCommunication: hasDefaultDenyIngress ? "partially-restricted" : "unrestricted",
      egressRestrictions: hasDefaultDenyEgress ? "partially-restricted" : "unrestricted",
      ingressRestrictions: hasDefaultDenyIngress ? "partially-restricted" : "unrestricted",
      gaps,
    };
  }

  private calculateRiskScore(
    apiVectors: APIAbuseVector[],
    lateralPaths: K8sLateralMovement[],
    rbacEscalations: RBACEscalation[],
    secretExposures: SecretExposure[],
    networkPolicies: NetworkPolicyAnalysis
  ): number {
    let score = 0;

    for (const v of apiVectors) {
      if (v.exploitable) {
        score += v.severity === "critical" ? 20 : v.severity === "high" ? 15 : 10;
      }
    }

    for (const p of lateralPaths) {
      score += p.severity === "critical" ? 20 : p.severity === "high" ? 15 : 10;
    }

    for (const r of rbacEscalations) {
      score += r.severity === "critical" ? 20 : r.severity === "high" ? 15 : 10;
    }

    for (const s of secretExposures) {
      score += s.severity === "critical" ? 10 : s.severity === "high" ? 7 : 5;
    }

    if (!networkPolicies.hasDefaultDeny) {
      score += 15;
    }

    return Math.min(100, score);
  }

  private generateRecommendations(
    apiVectors: APIAbuseVector[],
    lateralPaths: K8sLateralMovement[],
    rbacEscalations: RBACEscalation[],
    secretExposures: SecretExposure[],
    networkPolicies: NetworkPolicyAnalysis
  ): string[] {
    const recs: string[] = [];

    if (rbacEscalations.length > 0) {
      recs.push("Review and restrict RBAC permissions following least privilege");
      recs.push("Never grant escalate, bind, or impersonate verbs without careful review");
    }

    if (apiVectors.some(v => v.name.includes("Privileged") || v.name.includes("Host Path"))) {
      recs.push("Implement Pod Security Standards (PSS) at baseline or restricted level");
      recs.push("Use admission controllers to block privileged pods");
    }

    if (lateralPaths.length > 0) {
      recs.push("Avoid hostNetwork, hostPID, hostIPC on application pods");
      recs.push("Use separate node pools for sensitive workloads");
    }

    if (secretExposures.length > 0) {
      recs.push("Disable automatic service account token mounting (automountServiceAccountToken: false)");
      recs.push("Use workload identity instead of service account tokens");
      recs.push("Limit secret access with RBAC to specific service accounts");
    }

    if (!networkPolicies.hasDefaultDeny) {
      recs.push("Implement default-deny NetworkPolicies for ingress and egress");
      recs.push("Define explicit NetworkPolicies for required communication paths");
    }

    recs.push("Enable audit logging for security-relevant API calls");
    recs.push("Use OPA Gatekeeper or Kyverno for policy enforcement");
    recs.push("Regularly audit RBAC permissions and remove unused roles");

    return recs;
  }
}

export const kubernetesPentestService = new KubernetesPentestService();
