import type OpenAI from "openai";
import { ValidationEngine, type ValidationTarget, type VulnerabilityType } from "../validation/validation-engine";
import { apiFuzzingEngine, type ParameterSchema } from "../api-fuzzer/fuzzing-engine";
import { fuzzingExecutor } from "../api-fuzzer/fuzzing-executor";
import { portScan, sslCheck, httpFingerprint, detectAuthenticationSurface } from "../external-recon";
import { createProtocolProbe } from "../validation/probes";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface ToolCallEvidence {
  toolName: string;
  arguments: Record<string, unknown>;
  resultSummary: string;
  vulnerable: boolean;
  confidence: number;
  verdict?: string;
  httpEvidence?: { request: string; response: string; timing: number };
  executionTimeMs: number;
  timestamp: string;
}

export interface ExploitToolContext {
  executionMode: "safe" | "simulation" | "live";
  organizationId?: string;
  evaluationId?: string;
  assetId: string;
  tenantId?: string;
}

// ---------------------------------------------------------------------------
// Execution mode gates
// ---------------------------------------------------------------------------

const TOOL_MODE_REQUIREMENTS: Record<string, string[]> = {
  validate_vulnerability: ["simulation", "live"],
  fuzz_endpoint: ["simulation", "live"],
  http_fingerprint: ["safe", "simulation", "live"],
  port_scan: ["safe", "simulation", "live"],
  check_ssl_tls: ["safe", "simulation", "live"],
  run_protocol_probe: ["safe", "simulation", "live"],
};

function isToolAllowed(toolName: string, mode: string, args?: Record<string, unknown>): { allowed: boolean; reason?: string } {
  const allowed = TOOL_MODE_REQUIREMENTS[toolName];
  if (!allowed || !allowed.includes(mode)) {
    return {
      allowed: false,
      reason: `Tool '${toolName}' requires ${TOOL_MODE_REQUIREMENTS[toolName]?.join(" or ")} mode. Current mode: ${mode}. Use passive tools (http_fingerprint, port_scan, check_ssl_tls) instead.`,
    };
  }
  // Credential probes need simulation+
  if (toolName === "run_protocol_probe" && args?.probe_type === "credential" && mode === "safe") {
    return {
      allowed: false,
      reason: "Credential probing requires simulation or live mode. Try dns or smtp probes instead (allowed in safe mode).",
    };
  }
  return { allowed: true };
}

// ---------------------------------------------------------------------------
// Tool definitions (OpenAI function calling format)
// ---------------------------------------------------------------------------

export const EXPLOIT_AGENT_TOOLS: OpenAI.ChatCompletionTool[] = [
  {
    type: "function",
    function: {
      name: "validate_vulnerability",
      description:
        "Test a specific endpoint parameter for a vulnerability type (SQLi, XSS, SSRF, command injection, path traversal, auth bypass). Sends real payloads and analyzes responses. Requires simulation or live mode.",
      parameters: {
        type: "object",
        properties: {
          url: { type: "string", description: "Full URL of the target endpoint" },
          method: { type: "string", enum: ["GET", "POST", "PUT", "DELETE", "PATCH"] },
          parameter_name: { type: "string", description: "Name of the parameter to test" },
          parameter_location: { type: "string", enum: ["url_param", "body_param", "header", "cookie", "path"] },
          vulnerability_types: {
            type: "array",
            items: { type: "string", enum: ["sqli", "xss", "auth_bypass", "command_injection", "path_traversal", "ssrf"] },
            description: "Which vulnerability types to test",
          },
          original_value: { type: "string", description: "Original parameter value for differential testing" },
        },
        required: ["url", "method", "parameter_name", "parameter_location", "vulnerability_types"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "fuzz_endpoint",
      description:
        "Fuzz an API endpoint parameter with smart payloads (type mutation, null injection, boundary values, encoding tricks, injection strings). Detects anomalous responses.",
      parameters: {
        type: "object",
        properties: {
          url: { type: "string", description: "Endpoint URL" },
          method: { type: "string", enum: ["GET", "POST", "PUT", "DELETE", "PATCH"] },
          parameter_name: { type: "string", description: "Parameter to fuzz" },
          parameter_type: { type: "string", enum: ["string", "integer", "number", "boolean", "array", "object"] },
          parameter_location: { type: "string", enum: ["path", "query", "header", "body"] },
          max_payloads: { type: "number", description: "Max payloads to send (default 10)" },
        },
        required: ["url", "method", "parameter_name", "parameter_type", "parameter_location"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "http_fingerprint",
      description:
        "Fingerprint a web target: server technology, frameworks, security headers, and authentication surface (login pages, admin panels, OAuth endpoints). Safe/passive operation.",
      parameters: {
        type: "object",
        properties: {
          target: { type: "string", description: "URL or hostname to fingerprint" },
          include_auth_surface: { type: "boolean", description: "Also detect login pages, admin panels, OAuth endpoints" },
        },
        required: ["target"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "port_scan",
      description:
        "TCP port scan to discover open services. Returns open ports with service identification and banners. Safe/passive operation.",
      parameters: {
        type: "object",
        properties: {
          host: { type: "string", description: "Target hostname or IP" },
          ports: { type: "array", items: { type: "number" }, description: "Specific ports to scan (omit for common ports)" },
        },
        required: ["host"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "check_ssl_tls",
      description:
        "Analyze SSL/TLS configuration: certificate validity, protocol versions, cipher suites, known weaknesses. Safe/passive operation.",
      parameters: {
        type: "object",
        properties: {
          host: { type: "string", description: "Target hostname" },
          port: { type: "number", description: "TLS port (default 443)" },
        },
        required: ["host"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "run_protocol_probe",
      description:
        "Run protocol-level probes: SMTP open relay testing, DNS misconfiguration checks, LDAP anonymous bind, or default credential testing on services.",
      parameters: {
        type: "object",
        properties: {
          host: { type: "string", description: "Target hostname or IP" },
          probe_type: { type: "string", enum: ["smtp", "dns", "ldap", "credential"] },
          service: { type: "string", enum: ["ssh", "ftp", "mysql", "postgresql", "redis", "mongodb", "telnet"], description: "Only needed for credential probe" },
          port: { type: "number", description: "Override default port" },
        },
        required: ["host", "probe_type"],
      },
    },
  },
];

// ---------------------------------------------------------------------------
// Tool executor
// ---------------------------------------------------------------------------

/** Truncate a string to maxLen characters for LLM context. */
function truncate(s: string, maxLen: number = 1200): string {
  return s.length > maxLen ? s.slice(0, maxLen) + "... [truncated]" : s;
}

export async function executeExploitTool(
  toolName: string,
  args: Record<string, unknown>,
  ctx: ExploitToolContext
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const start = Date.now();

  // Mode gate
  const gate = isToolAllowed(toolName, ctx.executionMode, args);
  if (!gate.allowed) {
    return {
      result: JSON.stringify({ blocked: true, reason: gate.reason }),
    };
  }

  try {
    switch (toolName) {
      case "validate_vulnerability":
        return await execValidateVulnerability(args, ctx, start);
      case "fuzz_endpoint":
        return await execFuzzEndpoint(args, ctx, start);
      case "http_fingerprint":
        return await execHttpFingerprint(args, start);
      case "port_scan":
        return await execPortScan(args, start);
      case "check_ssl_tls":
        return await execSslCheck(args, start);
      case "run_protocol_probe":
        return await execProtocolProbe(args, start);
      default:
        return { result: JSON.stringify({ error: `Unknown tool: ${toolName}` }) };
    }
  } catch (error: any) {
    return {
      result: JSON.stringify({ error: error.message || "Tool execution failed" }),
    };
  }
}

// ---------------------------------------------------------------------------
// Individual tool executors
// ---------------------------------------------------------------------------

async function execValidateVulnerability(
  args: Record<string, unknown>,
  ctx: ExploitToolContext,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const target: ValidationTarget = {
    url: String(args.url),
    method: String(args.method) as ValidationTarget["method"],
    parameterName: String(args.parameter_name),
    parameterLocation: String(args.parameter_location) as ValidationTarget["parameterLocation"],
    originalValue: args.original_value ? String(args.original_value) : undefined,
    vulnerabilityTypes: (args.vulnerability_types as string[])?.map((v) => v as VulnerabilityType),
  };

  const engine = new ValidationEngine({
    executionMode: ctx.executionMode,
    maxPayloadsPerTest: 8,
    timeoutMs: 15_000,
    captureEvidence: true,
    safeMode: ctx.executionMode === "safe",
    tenantId: ctx.tenantId || "default",
  });

  const result = await engine.validateTarget(target);
  const elapsed = Date.now() - start;

  const summary = {
    vulnerable: result.vulnerable,
    confidence: result.overallConfidence,
    verdict: result.overallVerdict,
    payloadsTested: result.totalPayloadsTested,
    successfulPayloads: result.successfulPayloads,
    vulnerabilities: result.vulnerabilities.map((v) => ({
      type: v.type,
      vulnerable: v.result.vulnerable,
      confidence: v.result.confidence,
      evidence: v.result.evidence?.slice(0, 200),
    })),
    recommendations: result.recommendations.slice(0, 3),
    executionTimeMs: elapsed,
  };

  return {
    result: truncate(JSON.stringify(summary)),
    evidence: {
      toolName: "validate_vulnerability",
      arguments: args,
      resultSummary: `${result.overallVerdict} (confidence: ${result.overallConfidence}%, ${result.totalPayloadsTested} payloads tested)`,
      vulnerable: result.vulnerable,
      confidence: result.overallConfidence,
      verdict: result.overallVerdict,
      httpEvidence: result.evidence.length > 0
        ? { request: result.evidence[0]?.slice(0, 500) || "", response: "", timing: elapsed }
        : undefined,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execFuzzEndpoint(
  args: Record<string, unknown>,
  ctx: ExploitToolContext,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const maxPayloads = Math.min(Number(args.max_payloads) || 10, ctx.executionMode === "simulation" ? 10 : 25);

  const paramSchema: ParameterSchema = {
    name: String(args.parameter_name),
    type: String(args.parameter_type),
    in: String(args.parameter_location) as ParameterSchema["in"],
  };

  const testCases = apiFuzzingEngine
    .generatePayloadsForParameter(paramSchema)
    .slice(0, maxPayloads)
    .map((payload, i) => ({
      id: `fuzz-${i}`,
      endpointPath: String(args.url),
      method: String(args.method),
      parameter: paramSchema,
      payload,
      generatedAt: new Date(),
    }));

  const result = await fuzzingExecutor.executeTestCases(testCases, {
    targetBaseUrl: String(args.url).replace(/\/[^/]*$/, "") || String(args.url),
    concurrency: 2,
    timeoutMs: 10_000,
    delayBetweenRequests: 50,
    maxTestCases: maxPayloads,
  });

  const elapsed = Date.now() - start;
  const hasCritical = result.summary.criticalFindings > 0;

  const summary = {
    totalTested: result.completedTestCases,
    anomalies: result.anomalies.length,
    critical: result.summary.criticalFindings,
    high: result.summary.highFindings,
    medium: result.summary.mediumFindings,
    topAnomalies: result.anomalies.slice(0, 3).map((a) => ({
      type: a.anomalyType,
      severity: a.severity,
      details: a.anomalyDetails?.slice(0, 100),
      statusCode: a.statusCode,
    })),
    avgResponseTime: Math.round(result.summary.averageResponseTime),
  };

  return {
    result: truncate(JSON.stringify(summary)),
    evidence: {
      toolName: "fuzz_endpoint",
      arguments: args,
      resultSummary: `${result.anomalies.length} anomalies (${result.summary.criticalFindings} critical) from ${result.completedTestCases} payloads`,
      vulnerable: hasCritical || result.summary.highFindings > 0,
      confidence: hasCritical ? 80 : result.summary.highFindings > 0 ? 60 : 30,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execHttpFingerprint(
  args: Record<string, unknown>,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const target = String(args.target);
  const fp = await httpFingerprint(target);
  const auth = args.include_auth_surface ? await detectAuthenticationSurface(target) : null;

  const elapsed = Date.now() - start;
  const summary: Record<string, unknown> = {
    server: fp.server,
    technologies: fp.technologies,
    securityHeaders: fp.securityHeaders,
    statusCode: fp.statusCode,
  };
  const unprotectedPanels = auth?.adminPanels?.filter((p) => !p.protected) ?? [];
  if (auth) {
    summary.authSurface = {
      loginPages: auth.loginPages,
      adminPanels: auth.adminPanels,
      oauthEndpoints: auth.oauthEndpoints,
      unprotectedPanels,
    };
  }

  return {
    result: truncate(JSON.stringify(summary)),
    evidence: {
      toolName: "http_fingerprint",
      arguments: args,
      resultSummary: `Server: ${fp.server || "unknown"}, ${fp.technologies?.length || 0} technologies detected`,
      vulnerable: unprotectedPanels.length > 0,
      confidence: 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execPortScan(
  args: Record<string, unknown>,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const host = String(args.host);
  const ports = Array.isArray(args.ports) ? (args.ports as number[]) : undefined;
  const results = await portScan(host, ports);
  const elapsed = Date.now() - start;

  const openPorts = results.filter((r) => r.state === "open");
  const summary = {
    totalScanned: results.length,
    openPorts: openPorts.map((p) => ({
      port: p.port,
      service: p.service,
      banner: p.banner?.slice(0, 100),
    })),
  };

  return {
    result: truncate(JSON.stringify(summary)),
    evidence: {
      toolName: "port_scan",
      arguments: args,
      resultSummary: `${openPorts.length} open ports on ${host}`,
      vulnerable: false,
      confidence: 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execSslCheck(
  args: Record<string, unknown>,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const host = String(args.host);
  const port = Number(args.port) || 443;
  const result = await sslCheck(host, port);
  const elapsed = Date.now() - start;

  const hasIssues =
    (result.vulnerabilities?.length ?? 0) > 0 ||
    (result.daysUntilExpiry != null && result.daysUntilExpiry < 30);

  return {
    result: truncate(JSON.stringify(result)),
    evidence: {
      toolName: "check_ssl_tls",
      arguments: args,
      resultSummary: `TLS ${result.protocol || "unknown"}, ${result.vulnerabilities?.length || 0} issues`,
      vulnerable: hasIssues,
      confidence: hasIssues ? 70 : 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}

async function execProtocolProbe(
  args: Record<string, unknown>,
  start: number
): Promise<{ result: string; evidence?: ToolCallEvidence }> {
  const host = String(args.host);
  const probeType = String(args.probe_type) as "smtp" | "dns" | "ldap" | "credential";
  const port = args.port ? Number(args.port) : undefined;

  const baseConfig = { host, port };
  let probeConfig: Record<string, unknown>;
  switch (probeType) {
    case "dns":
      probeConfig = { ...baseConfig, domain: host };
      break;
    case "credential":
      probeConfig = { ...baseConfig, service: args.service ? String(args.service) : "ssh" };
      break;
    default:
      probeConfig = baseConfig;
  }

  const probe = createProtocolProbe({
    type: probeType,
    config: probeConfig as any,
  });

  const result = await probe.probe();
  const elapsed = Date.now() - start;

  return {
    result: truncate(JSON.stringify(result)),
    evidence: {
      toolName: "run_protocol_probe",
      arguments: args,
      resultSummary: `${probeType} probe on ${host}: ${result.vulnerable ? "VULNERABLE" : "OK"}`,
      vulnerable: result.vulnerable || false,
      confidence: result.confidence || 0,
      executionTimeMs: elapsed,
      timestamp: new Date().toISOString(),
    },
  };
}
