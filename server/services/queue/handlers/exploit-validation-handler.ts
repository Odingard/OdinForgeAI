import { Job } from "bullmq";
import { randomUUID } from "crypto";
import { storage } from "../../../storage";
import { db } from "../../../db";
import { exploitValidationResults } from "@shared/schema";
import {
  ExploitValidationJobData,
  JobResult,
  JobProgress,
} from "../job-types";
import { validateOrchestratorFindings, type ValidatedOrchestratorResult } from "../../validation/findings-validator";
import type { AttackPathStep } from "@shared/schema";

interface ExploitValidationJob {
  id?: string;
  data: ExploitValidationJobData;
  updateProgress?: (progress: number | object) => Promise<void>;
}

function emitValidationProgress(
  tenantId: string,
  organizationId: string,
  validationId: string,
  event: Record<string, any>
): void {
  const type = event.type;
  
  if (type === "validation_started") {
    console.log(`[ExploitValidation] ${validationId}: Started ${event.exploitType} validation (safe=${event.safeMode})`);
  } else if (type === "validation_progress") {
    console.log(`[ExploitValidation] ${validationId}: ${event.phase} - ${event.message}`);
  } else if (type === "validation_completed") {
    console.log(`[ExploitValidation] ${validationId}: Completed - exploitable=${event.exploitable}, verdict=${event.verdict}`);
  } else if (type === "validation_failed") {
    console.log(`[ExploitValidation] ${validationId}: Failed - ${event.error}`);
  }

  try {
    const { wsService } = require("../../websocket");
    if (!wsService) return;
    
    const channel = `exploit_validation:${tenantId}:${organizationId}:${validationId}`;
    wsService.broadcastToChannel(channel, {
      type: "exploit_validation_progress",
      validationId,
      phase: event.phase || "processing",
      progress: event.progress || 0,
      message: event.message,
    });
  } catch {
  }
}

export async function handleExploitValidationJob(
  job: Job<ExploitValidationJobData> | ExploitValidationJob
): Promise<JobResult> {
  const startTime = Date.now();
  const { validationId, findingId, exploitType, safeMode, tenantId, organizationId, evaluationId } = job.data;

  console.log(`[ExploitValidation] Starting validation for finding ${findingId}`);

  emitValidationProgress(tenantId, organizationId, validationId, {
    type: "validation_started",
    exploitType,
    safeMode,
  });

  try {
    await job.updateProgress?.({
      percent: 10,
      stage: "loading",
      message: "Loading evaluation results...",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_progress",
      phase: "loading",
      progress: 10,
      message: "Loading evaluation results",
    });

    let attackPath: AttackPathStep[] = [];
    let assetId = "unknown";
    let exposureType = exploitType;

    if (evaluationId) {
      const evaluation = await storage.getEvaluation(evaluationId);
      if (evaluation) {
        assetId = evaluation.assetId;
        exposureType = evaluation.exposureType;
        
        const results = await storage.getResultsByEvaluationId(evaluationId);
        if (results.length > 0) {
          const result = results[0];
          if (result.attackPath && Array.isArray(result.attackPath)) {
            attackPath = result.attackPath as AttackPathStep[];
          }
        }
      }
    }

    if (attackPath.length === 0) {
      attackPath = [{
        id: 1,
        title: `${exploitType} Exploitation`,
        technique: exploitType,
        severity: "high",
        description: `Potential ${exploitType} vulnerability requiring validation`,
        discoveredBy: "exploit_validation",
      }];
    }

    await job.updateProgress?.({
      percent: 30,
      stage: "preparing",
      message: "Preparing validation bundles...",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_progress",
      phase: "preparing",
      progress: 30,
      message: "Preparing validation bundles",
    });

    await job.updateProgress?.({
      percent: 50,
      stage: "validating",
      message: "Running LLM-based finding validation...",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_progress",
      phase: "validating",
      progress: 50,
      message: "Running LLM-based finding validation",
    });

    let validationResult: ValidatedOrchestratorResult;
    try {
      validationResult = await validateOrchestratorFindings(
        { attackPath },
        {
          evaluationId: evaluationId || validationId,
          assetId,
          exposureType,
        },
        (stage, progress, message) => {
          emitValidationProgress(tenantId, organizationId, validationId, {
            type: "validation_progress",
            phase: stage,
            progress: 50 + Math.floor(progress * 0.3),
            message,
          });
        }
      );
    } catch (llmError) {
      console.log(`[ExploitValidation] LLM validation unavailable, using heuristic validation`);
      validationResult = {
        attackPath: attackPath.map(step => ({
          ...step,
          llmValidationVerdict: "needs_review" as const,
          llmValidation: {
            verdict: "needs_review" as const,
            confidence: 60,
            reason: "LLM validation unavailable - manual review recommended",
            validatedAt: new Date().toISOString(),
            model: "heuristic",
          },
        })),
        validationStats: {
          total: attackPath.length,
          confirmed: 0,
          noise: 0,
          needsReview: attackPath.length,
          errors: 0,
          skipped: 0,
        },
      };
    }

    await job.updateProgress?.({
      percent: 85,
      stage: "analyzing",
      message: "Analyzing validation results...",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_progress",
      phase: "analyzing",
      progress: 85,
      message: "Analyzing validation results",
    });

    const stats = validationResult.validationStats;
    const exploitable = stats.confirmed > 0 || stats.needsReview > 0;
    const confidence = stats.total > 0 
      ? Math.round(((stats.confirmed + stats.needsReview * 0.5) / stats.total) * 100) 
      : 50;
    
    let verdict: "confirmed" | "noise" | "needs_review" = "needs_review";
    if (stats.confirmed > 0 && stats.confirmed >= stats.noise) {
      verdict = "confirmed";
    } else if (stats.noise > stats.confirmed && stats.needsReview === 0) {
      verdict = "noise";
    }

    const evidence = [
      `Validated ${stats.total} findings`,
      `Confirmed: ${stats.confirmed}`,
      `Noise: ${stats.noise}`,
      `Needs Review: ${stats.needsReview}`,
      `Validation Mode: ${safeMode ? "safe (static analysis)" : "live (dynamic testing)"}`,
    ];

    await job.updateProgress?.({
      percent: 95,
      stage: "persisting",
      message: "Saving validation results...",
    } as JobProgress);

    try {
      await db.insert(exploitValidationResults).values({
        id: randomUUID(),
        validationId,
        tenantId,
        organizationId,
        findingId,
        evaluationId: evaluationId || null,
        exploitType,
        safeMode,
        verdict,
        exploitable,
        confidence,
        validationStats: stats,
        evidence,
        attackPath: validationResult.attackPath.map(step => ({
          phase: step.phase,
          action: step.action,
          tools: step.tools || [],
        })),
        status: "completed",
        validationStarted: new Date(startTime),
        validationCompleted: new Date(),
      });
      console.log(`[ExploitValidation] Results persisted to database for ${validationId}`);
    } catch (dbError) {
      console.warn(`[ExploitValidation] Failed to persist results:`, dbError instanceof Error ? dbError.message : "Unknown error");
    }

    await job.updateProgress?.({
      percent: 100,
      stage: "complete",
      message: "Validation complete",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_completed",
      exploitable,
      confidence,
      verdict,
      stats,
    });

    return {
      success: true,
      data: {
        validationId,
        findingId,
        exploitType,
        exploitable,
        confidence,
        verdict,
        evidence,
        validationStats: stats,
        validatedAttackPath: validationResult.attackPath,
      },
      duration: Date.now() - startTime,
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error(`[ExploitValidation] Validation failed:`, errorMessage);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_failed",
      error: errorMessage,
    });

    return {
      success: false,
      error: errorMessage,
      duration: Date.now() - startTime,
    };
  }
}
