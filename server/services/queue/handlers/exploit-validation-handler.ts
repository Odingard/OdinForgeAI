import { Job } from "bullmq";
import { randomUUID } from "crypto";
import { storage } from "../../../storage";
import { db } from "../../../db";
import { exploitValidationResults } from "@shared/schema";
import {
  ExploitValidationJobData,
  JobResult,
  JobProgress,
} from "../job-types";
import { validateOrchestratorFindings, type ValidatedOrchestratorResult } from "../../validation/findings-validator";
import { createValidationEngine, type VulnerabilityType, type UnifiedValidationResult } from "../../validation/validation-engine";
import type { ValidationContext } from "../../validation/validating-http-client";
import type { AttackPathStep } from "@shared/schema";

function mapExploitTypeToVulnerabilityTypes(exploitType: string): VulnerabilityType[] {
  const implementedValidators: Record<string, VulnerabilityType[]> = {
    "sqli": ["sqli"],
    "sql_injection": ["sqli"],
    "xss": ["xss"],
    "cross_site_scripting": ["xss"],
    "auth_bypass": ["auth_bypass"],
    "authentication_bypass": ["auth_bypass"],
  };
  
  const lowerType = exploitType.toLowerCase();
  return implementedValidators[lowerType] || ["sqli", "xss", "auth_bypass"];
}

interface ExploitValidationJob {
  id?: string;
  data: ExploitValidationJobData;
  updateProgress?: (progress: number | object) => Promise<void>;
}

function emitValidationProgress(
  tenantId: string,
  organizationId: string,
  validationId: string,
  event: Record<string, any>
): void {
  const type = event.type;
  
  if (type === "validation_started") {
    console.log(`[ExploitValidation] ${validationId}: Started ${event.exploitType} validation (safe=${event.safeMode})`);
  } else if (type === "validation_progress") {
    console.log(`[ExploitValidation] ${validationId}: ${event.phase} - ${event.message}`);
  } else if (type === "validation_completed") {
    console.log(`[ExploitValidation] ${validationId}: Completed - exploitable=${event.exploitable}, verdict=${event.verdict}`);
  } else if (type === "validation_failed") {
    console.log(`[ExploitValidation] ${validationId}: Failed - ${event.error}`);
  }

  try {
    const { wsService } = require("../../websocket");
    if (!wsService) return;
    
    const channel = `exploit_validation:${tenantId}:${organizationId}:${validationId}`;
    wsService.broadcastToChannel(channel, {
      type: "exploit_validation_progress",
      validationId,
      phase: event.phase || "processing",
      progress: event.progress || 0,
      message: event.message,
    });
  } catch {
  }
}

export async function handleExploitValidationJob(
  job: Job<ExploitValidationJobData> | ExploitValidationJob
): Promise<JobResult> {
  const startTime = Date.now();
  const { validationId, findingId, exploitType, safeMode, tenantId, organizationId, evaluationId } = job.data;

  console.log(`[ExploitValidation] Starting validation for finding ${findingId}`);

  emitValidationProgress(tenantId, organizationId, validationId, {
    type: "validation_started",
    exploitType,
    safeMode,
  });

  try {
    await job.updateProgress?.({
      percent: 10,
      stage: "loading",
      message: "Loading evaluation results...",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_progress",
      phase: "loading",
      progress: 10,
      message: "Loading evaluation results",
    });

    let attackPath: AttackPathStep[] = [];
    let assetId = "unknown";
    let exposureType = exploitType;

    if (evaluationId) {
      const evaluation = await storage.getEvaluation(evaluationId);
      if (evaluation) {
        assetId = evaluation.assetId;
        exposureType = evaluation.exposureType;
        
        const result = await storage.getResultByEvaluationId(evaluationId);
        if (result && result.attackPath && Array.isArray(result.attackPath)) {
          attackPath = result.attackPath as AttackPathStep[];
        }
      }
    }

    if (attackPath.length === 0) {
      attackPath = [{
        id: 1,
        title: `${exploitType} Exploitation`,
        technique: exploitType,
        severity: "high",
        description: `Potential ${exploitType} vulnerability requiring validation`,
        discoveredBy: "exploit",
      }];
    }

    await job.updateProgress?.({
      percent: 30,
      stage: "preparing",
      message: "Preparing validation bundles...",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_progress",
      phase: "preparing",
      progress: 30,
      message: "Preparing validation bundles",
    });

    await job.updateProgress?.({
      percent: 50,
      stage: "validating",
      message: "Running LLM-based finding validation...",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_progress",
      phase: "validating",
      progress: 50,
      message: "Running LLM-based finding validation",
    });

    let validationResult: ValidatedOrchestratorResult;
    let liveValidationResults: UnifiedValidationResult | null = null;

    if (!safeMode && job.data.targetUrl) {
      emitValidationProgress(tenantId, organizationId, validationId, {
        type: "validation_progress",
        phase: "live_validation",
        progress: 40,
        message: "Running live payload-based validation",
      });

      try {
        const validationContext: ValidationContext = {
          tenantId,
          organizationId,
          evaluationId: evaluationId || validationId,
          scanId: validationId,
          findingId,
        };

        const vulnTypes = mapExploitTypeToVulnerabilityTypes(exploitType);
        const engine = createValidationEngine(
          { captureEvidence: true, safeMode: false, timeoutMs: 15000 },
          validationContext
        );

        liveValidationResults = await engine.validateTarget({
          url: job.data.targetUrl,
          method: (job.data.httpMethod as "GET" | "POST" | "PUT" | "DELETE" | "PATCH") || "GET",
          parameterName: job.data.parameterName || "id",
          parameterLocation: (job.data.parameterLocation as "url_param" | "body_param") || "url_param",
          vulnerabilityTypes: vulnTypes,
        });

        if (liveValidationResults.vulnerable) {
          await engine.captureValidationEvidence(
            {
              url: job.data.targetUrl,
              method: (job.data.httpMethod as "GET" | "POST" | "PUT" | "DELETE" | "PATCH") || "GET",
              parameterName: job.data.parameterName || "id",
              parameterLocation: "url_param",
            },
            liveValidationResults
          );
        }

        console.log(`[ExploitValidation] Live validation complete: vulnerable=${liveValidationResults.vulnerable}, confidence=${liveValidationResults.overallConfidence}`);
      } catch (liveError) {
        console.warn(`[ExploitValidation] Live validation failed:`, liveError instanceof Error ? liveError.message : "Unknown");
      }
    }

    await job.updateProgress?.({
      percent: 50,
      stage: "validating",
      message: safeMode ? "Running LLM-based finding validation..." : "Running combined validation...",
    } as JobProgress);

    try {
      validationResult = await validateOrchestratorFindings(
        { attackPath },
        {
          evaluationId: evaluationId || validationId,
          assetId,
          exposureType,
        },
        (stage, progress, message) => {
          emitValidationProgress(tenantId, organizationId, validationId, {
            type: "validation_progress",
            phase: stage,
            progress: 50 + Math.floor(progress * 0.3),
            message,
          });
        }
      );
    } catch (llmError) {
      console.log(`[ExploitValidation] LLM validation unavailable, using heuristic validation`);
      validationResult = {
        attackPath: attackPath.map(step => ({
          ...step,
          llmValidationVerdict: "needs_review" as const,
          llmValidation: {
            verdict: "needs_review" as const,
            confidence: 60,
            reason: "LLM validation unavailable - manual review recommended",
            validatedAt: new Date().toISOString(),
            model: "heuristic",
          },
        })),
        validationStats: {
          total: attackPath.length,
          confirmed: 0,
          noise: 0,
          needsReview: attackPath.length,
          errors: 0,
          skipped: 0,
        },
      };
    }

    if (liveValidationResults?.vulnerable) {
      const liveConfirmed = liveValidationResults.vulnerabilities.filter(v => v.result.vulnerable).length;
      validationResult.validationStats.confirmed += liveConfirmed;
      validationResult.validationStats.needsReview = Math.max(0, validationResult.validationStats.needsReview - liveConfirmed);
    }

    await job.updateProgress?.({
      percent: 85,
      stage: "analyzing",
      message: "Analyzing validation results...",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_progress",
      phase: "analyzing",
      progress: 85,
      message: "Analyzing validation results",
    });

    const stats = validationResult.validationStats;
    const exploitable = stats.confirmed > 0 || stats.needsReview > 0;
    const confidence = stats.total > 0 
      ? Math.round(((stats.confirmed + stats.needsReview * 0.5) / stats.total) * 100) 
      : 50;
    
    let verdict: "confirmed" | "noise" | "needs_review" = "needs_review";
    if (stats.confirmed > 0 && stats.confirmed >= stats.noise) {
      verdict = "confirmed";
    } else if (stats.noise > stats.confirmed && stats.needsReview === 0) {
      verdict = "noise";
    }

    const evidence = [
      `Validated ${stats.total} findings`,
      `Confirmed: ${stats.confirmed}`,
      `Noise: ${stats.noise}`,
      `Needs Review: ${stats.needsReview}`,
      `Validation Mode: ${safeMode ? "safe (static analysis)" : "live (dynamic testing)"}`,
    ];

    if (liveValidationResults) {
      evidence.push(`Live Payloads Tested: ${liveValidationResults.totalPayloadsTested}`);
      evidence.push(`Successful Payloads: ${liveValidationResults.successfulPayloads}`);
      evidence.push(`Live Validation Verdict: ${liveValidationResults.overallVerdict}`);
      if (liveValidationResults.evidence.length > 0) {
        evidence.push(...liveValidationResults.evidence.slice(0, 3));
      }
    }

    await job.updateProgress?.({
      percent: 95,
      stage: "persisting",
      message: "Saving validation results...",
    } as JobProgress);

    try {
      await db.insert(exploitValidationResults).values({
        id: randomUUID(),
        validationId,
        tenantId,
        organizationId,
        findingId,
        evaluationId: evaluationId || null,
        exploitType,
        safeMode,
        verdict,
        exploitable,
        confidence,
        validationStats: stats,
        evidence,
        attackPath: validationResult.attackPath.map(step => ({
          phase: step.discoveredBy || "exploit",
          action: step.title,
          tools: step.technique ? [step.technique] : [],
        })),
        status: "completed",
        validationStarted: new Date(startTime),
        validationCompleted: new Date(),
      });
      console.log(`[ExploitValidation] Results persisted to database for ${validationId}`);
    } catch (dbError) {
      console.warn(`[ExploitValidation] Failed to persist results:`, dbError instanceof Error ? dbError.message : "Unknown error");
    }

    await job.updateProgress?.({
      percent: 100,
      stage: "complete",
      message: "Validation complete",
    } as JobProgress);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_completed",
      exploitable,
      confidence,
      verdict,
      stats,
    });

    return {
      success: true,
      data: {
        validationId,
        findingId,
        exploitType,
        exploitable,
        confidence,
        verdict,
        evidence,
        validationStats: stats,
        validatedAttackPath: validationResult.attackPath,
      },
      duration: Date.now() - startTime,
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error(`[ExploitValidation] Validation failed:`, errorMessage);

    emitValidationProgress(tenantId, organizationId, validationId, {
      type: "validation_failed",
      error: errorMessage,
    });

    return {
      success: false,
      error: errorMessage,
      duration: Date.now() - startTime,
    };
  }
}
