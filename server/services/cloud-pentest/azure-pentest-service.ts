import { randomUUID } from "crypto";

export interface AzureManagedIdentityResult {
  id: string;
  identitiesAnalyzed: ManagedIdentityInfo[];
  exploitableIdentities: ManagedIdentityExploit[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
  timestamp: Date;
}

export interface ManagedIdentityInfo {
  resourceId: string;
  resourceName: string;
  resourceType: string;
  identityType: "SystemAssigned" | "UserAssigned";
  principalId?: string;
  clientId?: string;
  tenantId?: string;
  roleAssignments: AzureRoleAssignment[];
}

export interface ManagedIdentityExploit {
  identityName: string;
  resourceType: string;
  exploitPath: string;
  dangerousRoles: string[];
  impact: string;
  likelihood: "high" | "medium" | "low";
  mitreId: string;
}

export interface AzureRoleAssignment {
  roleDefinitionId: string;
  roleName: string;
  scope: string;
  principalType: string;
}

export interface AzureStorageExposureResult {
  id: string;
  accountsAnalyzed: StorageAccountInfo[];
  publicContainers: ContainerInfo[];
  misconfigurations: StorageMisconfiguration[];
  sensitiveDataExposures: AzureDataExposure[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
  timestamp: Date;
}

export interface StorageAccountInfo {
  name: string;
  resourceGroup: string;
  location: string;
  kind: string;
  sku: string;
  httpsOnly: boolean;
  minimumTlsVersion: string;
  allowBlobPublicAccess: boolean;
  networkRuleSet?: {
    defaultAction: "Allow" | "Deny";
    virtualNetworkRules: string[];
    ipRules: string[];
  };
  encryption?: {
    keySource: string;
    requireInfrastructureEncryption: boolean;
  };
}

export interface ContainerInfo {
  name: string;
  storageAccount: string;
  publicAccess: "None" | "Blob" | "Container";
  lastModified?: Date;
  blobCount?: number;
}

export interface StorageMisconfiguration {
  accountName: string;
  type: string;
  severity: "critical" | "high" | "medium" | "low";
  description: string;
  remediation: string;
  mitreId?: string;
}

export interface AzureDataExposure {
  accountName: string;
  containerName: string;
  blobPath: string;
  dataType: string;
  sensitivityLevel: "critical" | "high" | "medium" | "low";
}

export interface AzureRBACEscalationResult {
  id: string;
  principalId: string;
  principalName: string;
  currentRoles: AzureRoleAssignment[];
  escalationPaths: RBACEscalationPath[];
  dangerousPermissions: AzureDangerousPermission[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
  timestamp: Date;
}

export interface RBACEscalationPath {
  name: string;
  description: string;
  steps: string[];
  requiredPermissions: string[];
  targetRole: string;
  likelihood: "high" | "medium" | "low";
  impact: "critical" | "high" | "medium" | "low";
  mitreId: string;
}

export interface AzureDangerousPermission {
  action: string;
  scope: string;
  risk: string;
  exploitability: "easy" | "moderate" | "difficult";
  mitreId?: string;
}

export interface MitreMapping {
  techniqueId: string;
  techniqueName: string;
  tactic: string;
  description: string;
}

const DANGEROUS_AZURE_ROLES = [
  { role: "Owner", risk: "Full control over all resources", mitreId: "T1098" },
  { role: "Contributor", risk: "Can modify any resource", mitreId: "T1098" },
  { role: "User Access Administrator", risk: "Can assign roles to any user", mitreId: "T1098.003" },
  { role: "Virtual Machine Contributor", risk: "Can manage VMs and access credentials", mitreId: "T1078.004" },
  { role: "Storage Account Contributor", risk: "Can access storage account keys", mitreId: "T1530" },
  { role: "Key Vault Administrator", risk: "Can access secrets and keys", mitreId: "T1555" },
];

const AZURE_ESCALATION_PATHS: RBACEscalationPath[] = [
  {
    name: "User Access Administrator to Owner",
    description: "Assign Owner role to self using User Access Administrator permissions",
    steps: [
      "Identify subscription or resource group scope",
      "Create role assignment with Owner role for current principal",
      "Gain full control over scope",
    ],
    requiredPermissions: ["Microsoft.Authorization/roleAssignments/write"],
    targetRole: "Owner",
    likelihood: "high",
    impact: "critical",
    mitreId: "T1098.003",
  },
  {
    name: "VM Contributor to Key Vault Access",
    description: "Use VM managed identity to access Key Vault secrets",
    steps: [
      "Access VM with managed identity",
      "Query IMDS endpoint for access token",
      "Use token to access Key Vault secrets",
    ],
    requiredPermissions: ["Microsoft.Compute/virtualMachines/write"],
    targetRole: "Key Vault Secrets User",
    likelihood: "medium",
    impact: "high",
    mitreId: "T1552.005",
  },
  {
    name: "Automation Account RunAs to Subscription",
    description: "Use Automation Account RunAs account for privilege escalation",
    steps: [
      "Access Automation Account with Contributor role",
      "Create runbook using RunAs connection",
      "Execute privileged commands with service principal",
    ],
    requiredPermissions: ["Microsoft.Automation/automationAccounts/runbooks/write"],
    targetRole: "Contributor",
    likelihood: "medium",
    impact: "critical",
    mitreId: "T1548.005",
  },
  {
    name: "Logic App Managed Identity Abuse",
    description: "Use Logic App managed identity for privilege escalation",
    steps: [
      "Create or modify Logic App with managed identity",
      "Configure HTTP action to call ARM API",
      "Execute privileged operations using identity",
    ],
    requiredPermissions: ["Microsoft.Logic/workflows/write"],
    targetRole: "Contributor",
    likelihood: "medium",
    impact: "high",
    mitreId: "T1548.005",
  },
];

const DANGEROUS_AZURE_PERMISSIONS = [
  { action: "*/write", risk: "Can modify any resource type", mitreId: "T1098" },
  { action: "Microsoft.Authorization/roleAssignments/write", risk: "Can assign roles", mitreId: "T1098.003" },
  { action: "Microsoft.Compute/virtualMachines/*", risk: "Full VM control", mitreId: "T1078.004" },
  { action: "Microsoft.Storage/storageAccounts/listKeys/action", risk: "Can access storage keys", mitreId: "T1530" },
  { action: "Microsoft.KeyVault/vaults/secrets/*", risk: "Can access Key Vault secrets", mitreId: "T1555" },
  { action: "Microsoft.ManagedIdentity/userAssignedIdentities/*", risk: "Can manage identities", mitreId: "T1078.004" },
  { action: "Microsoft.Resources/deployments/*", risk: "Can deploy ARM templates", mitreId: "T1578" },
];

class AzurePentestService {
  async analyzeManagedIdentities(
    identities: Partial<ManagedIdentityInfo>[]
  ): Promise<AzureManagedIdentityResult> {
    const id = `azure-mi-${randomUUID().slice(0, 8)}`;
    const exploitableIdentities: ManagedIdentityExploit[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    const enrichedIdentities: ManagedIdentityInfo[] = identities.map(i => ({
      resourceId: i.resourceId || "",
      resourceName: i.resourceName || "unknown",
      resourceType: i.resourceType || "unknown",
      identityType: i.identityType || "SystemAssigned",
      principalId: i.principalId,
      clientId: i.clientId,
      tenantId: i.tenantId,
      roleAssignments: i.roleAssignments || [],
    }));

    for (const identity of enrichedIdentities) {
      const dangerousRoles = identity.roleAssignments
        .filter(ra => DANGEROUS_AZURE_ROLES.some(dr => ra.roleName.includes(dr.role)))
        .map(ra => ra.roleName);

      if (dangerousRoles.length > 0) {
        exploitableIdentities.push({
          identityName: identity.resourceName,
          resourceType: identity.resourceType,
          exploitPath: `Access ${identity.resourceType} to obtain managed identity token with elevated privileges`,
          dangerousRoles,
          impact: dangerousRoles.some(r => r.includes("Owner") || r.includes("Contributor"))
            ? "Full subscription compromise possible"
            : "Lateral movement to other resources possible",
          likelihood: identity.resourceType.includes("VirtualMachine") ? "high" : "medium",
          mitreId: "T1078.004",
        });

        mitreAttackMappings.push({
          techniqueId: "T1078.004",
          techniqueName: "Cloud Accounts",
          tactic: "privilege-escalation",
          description: `Managed identity on ${identity.resourceType} has dangerous roles`,
        });
      }
    }

    const riskScore = this.calculateMIRiskScore(exploitableIdentities);
    const recommendations = this.generateMIRecommendations(exploitableIdentities);

    return {
      id,
      identitiesAnalyzed: enrichedIdentities,
      exploitableIdentities,
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        identitiesAnalyzed: enrichedIdentities.length,
        exploitableIdentitiesFound: exploitableIdentities.length,
      },
      timestamp: new Date(),
    };
  }

  async analyzeStorageExposure(
    accounts: Partial<StorageAccountInfo>[],
    containers: Partial<ContainerInfo>[] = []
  ): Promise<AzureStorageExposureResult> {
    const id = `azure-storage-${randomUUID().slice(0, 8)}`;
    const publicContainers: ContainerInfo[] = [];
    const misconfigurations: StorageMisconfiguration[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    const enrichedAccounts: StorageAccountInfo[] = accounts.map(a => ({
      name: a.name || "unknown",
      resourceGroup: a.resourceGroup || "",
      location: a.location || "",
      kind: a.kind || "StorageV2",
      sku: a.sku || "Standard_LRS",
      httpsOnly: a.httpsOnly ?? true,
      minimumTlsVersion: a.minimumTlsVersion || "TLS1_2",
      allowBlobPublicAccess: a.allowBlobPublicAccess ?? false,
      networkRuleSet: a.networkRuleSet,
      encryption: a.encryption,
    }));

    const enrichedContainers: ContainerInfo[] = containers.map(c => ({
      name: c.name || "unknown",
      storageAccount: c.storageAccount || "",
      publicAccess: c.publicAccess || "None",
      lastModified: c.lastModified,
      blobCount: c.blobCount,
    }));

    for (const account of enrichedAccounts) {
      if (account.allowBlobPublicAccess) {
        misconfigurations.push({
          accountName: account.name,
          type: "Public Blob Access Allowed",
          severity: "critical",
          description: "Storage account allows public blob access",
          remediation: "Disable allowBlobPublicAccess setting",
          mitreId: "T1530",
        });
      }

      if (!account.httpsOnly) {
        misconfigurations.push({
          accountName: account.name,
          type: "HTTP Allowed",
          severity: "high",
          description: "Storage account allows HTTP (unencrypted) connections",
          remediation: "Enable supportsHttpsTrafficOnly setting",
          mitreId: "T1557",
        });
      }

      if (account.minimumTlsVersion !== "TLS1_2") {
        misconfigurations.push({
          accountName: account.name,
          type: "Weak TLS Version",
          severity: "medium",
          description: `Storage account allows TLS version ${account.minimumTlsVersion}`,
          remediation: "Set minimumTlsVersion to TLS1_2",
          mitreId: "T1557",
        });
      }

      if (account.networkRuleSet?.defaultAction === "Allow") {
        misconfigurations.push({
          accountName: account.name,
          type: "No Network Restrictions",
          severity: "high",
          description: "Storage account allows access from all networks",
          remediation: "Configure network rules to restrict access",
          mitreId: "T1530",
        });
      }

      if (!account.encryption?.requireInfrastructureEncryption) {
        misconfigurations.push({
          accountName: account.name,
          type: "No Infrastructure Encryption",
          severity: "medium",
          description: "Double encryption not enabled for storage account",
          remediation: "Enable infrastructure encryption",
        });
      }
    }

    for (const container of enrichedContainers) {
      if (container.publicAccess !== "None") {
        publicContainers.push(container);
        misconfigurations.push({
          accountName: container.storageAccount,
          type: "Public Container",
          severity: "critical",
          description: `Container ${container.name} has ${container.publicAccess} public access`,
          remediation: "Set container public access to None",
          mitreId: "T1530",
        });
      }
    }

    if (publicContainers.length > 0 || misconfigurations.some(m => m.mitreId === "T1530")) {
      mitreAttackMappings.push({
        techniqueId: "T1530",
        techniqueName: "Data from Cloud Storage",
        tactic: "collection",
        description: "Public storage access allows unauthorized data access",
      });
    }

    const riskScore = this.calculateStorageRiskScore(publicContainers, misconfigurations);
    const recommendations = this.generateStorageRecommendations(misconfigurations);

    return {
      id,
      accountsAnalyzed: enrichedAccounts,
      publicContainers,
      misconfigurations,
      sensitiveDataExposures: [],
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        accountsAnalyzed: enrichedAccounts.length,
        containersAnalyzed: enrichedContainers.length,
        publicContainersFound: publicContainers.length,
        misconfigurationsFound: misconfigurations.length,
      },
      timestamp: new Date(),
    };
  }

  async analyzeRBACEscalation(
    principalId: string,
    principalName: string,
    roleAssignments: Partial<AzureRoleAssignment>[]
  ): Promise<AzureRBACEscalationResult> {
    const id = `azure-rbac-${randomUUID().slice(0, 8)}`;
    const escalationPaths: RBACEscalationPath[] = [];
    const dangerousPerms: AzureDangerousPermission[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    const enrichedRoles: AzureRoleAssignment[] = roleAssignments.map(ra => ({
      roleDefinitionId: ra.roleDefinitionId || "",
      roleName: ra.roleName || "unknown",
      scope: ra.scope || "",
      principalType: ra.principalType || "User",
    }));

    for (const path of AZURE_ESCALATION_PATHS) {
      const hasRole = enrichedRoles.some(ra => 
        path.requiredPermissions.some(rp => 
          this.roleMatchesPermission(ra.roleName, rp)
        )
      );

      if (hasRole) {
        escalationPaths.push(path);
        mitreAttackMappings.push({
          techniqueId: path.mitreId,
          techniqueName: path.name,
          tactic: "privilege-escalation",
          description: path.description,
        });
      }
    }

    for (const role of enrichedRoles) {
      const dangerousRole = DANGEROUS_AZURE_ROLES.find(dr => role.roleName.includes(dr.role));
      if (dangerousRole) {
        dangerousPerms.push({
          action: role.roleName,
          scope: role.scope,
          risk: dangerousRole.risk,
          exploitability: this.getRoleExploitability(role.roleName),
          mitreId: dangerousRole.mitreId,
        });
      }
    }

    const riskScore = this.calculateRBACRiskScore(escalationPaths, dangerousPerms);
    const recommendations = this.generateRBACRecommendations(escalationPaths, dangerousPerms);

    return {
      id,
      principalId,
      principalName,
      currentRoles: enrichedRoles,
      escalationPaths,
      dangerousPermissions: dangerousPerms,
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        rolesAnalyzed: enrichedRoles.length,
        escalationPathsFound: escalationPaths.length,
        dangerousPermissionsFound: dangerousPerms.length,
      },
      timestamp: new Date(),
    };
  }

  private roleMatchesPermission(roleName: string, permission: string): boolean {
    const rolePermissionMap: Record<string, string[]> = {
      "Owner": ["*"],
      "Contributor": ["*/write", "*/delete"],
      "User Access Administrator": ["Microsoft.Authorization/roleAssignments/write"],
      "Virtual Machine Contributor": ["Microsoft.Compute/virtualMachines/*"],
      "Storage Account Contributor": ["Microsoft.Storage/storageAccounts/*"],
      "Automation Contributor": ["Microsoft.Automation/automationAccounts/*"],
    };

    const perms = rolePermissionMap[roleName] || [];
    return perms.some(p => p === permission || p === "*");
  }

  private getRoleExploitability(roleName: string): "easy" | "moderate" | "difficult" {
    if (roleName.includes("Owner") || roleName.includes("User Access Administrator")) return "easy";
    if (roleName.includes("Contributor")) return "moderate";
    return "difficult";
  }

  private calculateMIRiskScore(exploits: ManagedIdentityExploit[]): number {
    let score = 0;
    for (const exploit of exploits) {
      score += exploit.likelihood === "high" ? 25 : exploit.likelihood === "medium" ? 15 : 10;
      if (exploit.dangerousRoles.some(r => r.includes("Owner"))) score += 20;
    }
    return Math.min(100, score);
  }

  private calculateStorageRiskScore(publicContainers: ContainerInfo[], misconfigs: StorageMisconfiguration[]): number {
    let score = publicContainers.length * 25;
    for (const m of misconfigs) {
      score += m.severity === "critical" ? 15 : m.severity === "high" ? 10 : 5;
    }
    return Math.min(100, score);
  }

  private calculateRBACRiskScore(paths: RBACEscalationPath[], perms: AzureDangerousPermission[]): number {
    let score = 0;
    for (const path of paths) {
      score += path.impact === "critical" ? 25 : path.impact === "high" ? 15 : 10;
    }
    for (const perm of perms) {
      score += perm.exploitability === "easy" ? 15 : perm.exploitability === "moderate" ? 10 : 5;
    }
    return Math.min(100, score);
  }

  private generateMIRecommendations(exploits: ManagedIdentityExploit[]): string[] {
    const recs: string[] = [];
    if (exploits.length > 0) {
      recs.push("Review and minimize role assignments for managed identities");
      recs.push("Use separate managed identities for different applications");
      recs.push("Implement conditional access policies for identity access");
    }
    if (exploits.some(e => e.resourceType.includes("VirtualMachine"))) {
      recs.push("Restrict VM access to authorized personnel only");
      recs.push("Enable Azure AD authentication for VM login");
    }
    recs.push("Monitor managed identity token requests in Azure AD logs");
    recs.push("Implement Azure Policy to restrict managed identity role assignments");
    return recs;
  }

  private generateStorageRecommendations(misconfigs: StorageMisconfiguration[]): string[] {
    const recs: string[] = [];
    if (misconfigs.some(m => m.type.includes("Public"))) {
      recs.push("Disable public blob access at subscription level using Azure Policy");
      recs.push("Review and remove public container access");
    }
    if (misconfigs.some(m => m.type.includes("HTTP"))) {
      recs.push("Enforce HTTPS-only access for all storage accounts");
    }
    if (misconfigs.some(m => m.type.includes("Network"))) {
      recs.push("Configure storage firewalls and virtual network rules");
      recs.push("Use private endpoints for storage account access");
    }
    recs.push("Enable storage account activity logging");
    recs.push("Use customer-managed keys for sensitive data encryption");
    return recs;
  }

  private generateRBACRecommendations(paths: RBACEscalationPath[], perms: AzureDangerousPermission[]): string[] {
    const recs: string[] = [];
    if (paths.length > 0) {
      recs.push("Implement Azure AD Privileged Identity Management (PIM)");
      recs.push("Enable just-in-time access for privileged roles");
    }
    if (perms.some(p => p.action.includes("Owner"))) {
      recs.push("Minimize Owner role assignments to essential personnel");
      recs.push("Use custom roles with minimal required permissions");
    }
    if (perms.some(p => p.action.includes("roleAssignments"))) {
      recs.push("Restrict User Access Administrator role to dedicated admin accounts");
    }
    recs.push("Enable Azure AD access reviews for role assignments");
    recs.push("Monitor role assignment changes in Azure Activity Log");
    return recs;
  }
}

export const azurePentestService = new AzurePentestService();
