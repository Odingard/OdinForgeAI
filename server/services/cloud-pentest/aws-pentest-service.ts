import { randomUUID } from "crypto";

export interface AWSCredentials {
  accessKeyId: string;
  secretAccessKey: string;
  sessionToken?: string;
  region?: string;
}

export interface IAMPrivilegeEscalationResult {
  id: string;
  userId: string;
  userName: string;
  accountId?: string;
  currentPrivileges: string[];
  escalationPaths: EscalationPath[];
  dangerousPermissions: DangerousPermission[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
  timestamp: Date;
}

export interface EscalationPath {
  name: string;
  description: string;
  steps: string[];
  requiredPermissions: string[];
  targetPermissions: string[];
  likelihood: "high" | "medium" | "low";
  impact: "critical" | "high" | "medium" | "low";
  mitreId: string;
}

export interface DangerousPermission {
  permission: string;
  resource: string;
  risk: string;
  exploitability: "easy" | "moderate" | "difficult";
  mitreId?: string;
}

export interface MitreMapping {
  techniqueId: string;
  techniqueName: string;
  tactic: string;
  description: string;
}

export interface S3BucketEnumerationResult {
  id: string;
  bucketsFound: S3BucketInfo[];
  publicBuckets: S3BucketInfo[];
  sensitiveDataExposures: DataExposure[];
  misconfigurations: S3Misconfiguration[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
  timestamp: Date;
}

export interface S3BucketInfo {
  name: string;
  region?: string;
  creationDate?: Date;
  isPublic: boolean;
  publicAccessBlock?: {
    blockPublicAcls: boolean;
    ignorePublicAcls: boolean;
    blockPublicPolicy: boolean;
    restrictPublicBuckets: boolean;
  };
  encryption?: {
    enabled: boolean;
    type?: string;
  };
  versioning?: boolean;
  logging?: boolean;
  objectCount?: number;
  totalSizeBytes?: number;
}

export interface DataExposure {
  bucketName: string;
  objectKey: string;
  dataType: string;
  sensitivityLevel: "critical" | "high" | "medium" | "low";
  description: string;
}

export interface S3Misconfiguration {
  bucketName: string;
  type: string;
  severity: "critical" | "high" | "medium" | "low";
  description: string;
  remediation: string;
  mitreId?: string;
}

export interface LambdaAbuseResult {
  id: string;
  functionsAnalyzed: LambdaFunctionInfo[];
  vulnerabilities: LambdaVulnerability[];
  privilegeEscalationRisks: LambdaEscalationRisk[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
  timestamp: Date;
}

export interface LambdaFunctionInfo {
  functionName: string;
  functionArn: string;
  runtime: string;
  role: string;
  handler: string;
  codeSize: number;
  timeout: number;
  memorySize: number;
  lastModified: string;
  environmentVariables?: Record<string, string>;
  vpcConfig?: {
    vpcId: string;
    subnetIds: string[];
    securityGroupIds: string[];
  };
}

export interface LambdaVulnerability {
  functionName: string;
  type: string;
  severity: "critical" | "high" | "medium" | "low";
  description: string;
  exploitability: string;
  remediation: string;
  mitreId?: string;
}

export interface LambdaEscalationRisk {
  functionName: string;
  roleArn: string;
  dangerousPermissions: string[];
  escalationPath: string;
  impact: string;
  mitreId: string;
}

const IAM_ESCALATION_PATHS: EscalationPath[] = [
  {
    name: "CreateAccessKey",
    description: "Create access keys for other IAM users",
    steps: [
      "Enumerate IAM users with iam:ListUsers",
      "Create new access key with iam:CreateAccessKey",
      "Use new credentials to access target user's permissions",
    ],
    requiredPermissions: ["iam:CreateAccessKey"],
    targetPermissions: ["*"],
    likelihood: "high",
    impact: "critical",
    mitreId: "T1098.001",
  },
  {
    name: "CreateLoginProfile",
    description: "Create console login for IAM users without one",
    steps: [
      "List users without console access",
      "Create login profile with iam:CreateLoginProfile",
      "Log in as target user via AWS Console",
    ],
    requiredPermissions: ["iam:CreateLoginProfile"],
    targetPermissions: ["*"],
    likelihood: "high",
    impact: "critical",
    mitreId: "T1098.001",
  },
  {
    name: "UpdateLoginProfile",
    description: "Reset password for existing IAM users",
    steps: [
      "Identify target user with console access",
      "Update login profile with iam:UpdateLoginProfile",
      "Log in as target user with new password",
    ],
    requiredPermissions: ["iam:UpdateLoginProfile"],
    targetPermissions: ["*"],
    likelihood: "high",
    impact: "critical",
    mitreId: "T1098.001",
  },
  {
    name: "AttachUserPolicy",
    description: "Attach administrator policy to current user",
    steps: [
      "Identify current IAM user/role",
      "Attach AdministratorAccess policy",
      "Gain full AWS account access",
    ],
    requiredPermissions: ["iam:AttachUserPolicy"],
    targetPermissions: ["*"],
    likelihood: "high",
    impact: "critical",
    mitreId: "T1098.003",
  },
  {
    name: "AttachRolePolicy",
    description: "Attach administrator policy to assumable role",
    steps: [
      "List roles that can be assumed",
      "Attach AdministratorAccess to target role",
      "Assume role to gain elevated privileges",
    ],
    requiredPermissions: ["iam:AttachRolePolicy", "sts:AssumeRole"],
    targetPermissions: ["*"],
    likelihood: "high",
    impact: "critical",
    mitreId: "T1098.003",
  },
  {
    name: "PutUserPolicy",
    description: "Create inline policy for escalation",
    steps: [
      "Create inline policy with administrative permissions",
      "Attach to current user",
      "Gain elevated access",
    ],
    requiredPermissions: ["iam:PutUserPolicy"],
    targetPermissions: ["*"],
    likelihood: "high",
    impact: "critical",
    mitreId: "T1098.003",
  },
  {
    name: "PassRoleToLambda",
    description: "Pass high-privilege role to new Lambda function",
    steps: [
      "Create Lambda function with iam:PassRole",
      "Attach high-privilege execution role",
      "Execute Lambda to perform privileged actions",
    ],
    requiredPermissions: ["iam:PassRole", "lambda:CreateFunction", "lambda:InvokeFunction"],
    targetPermissions: ["*"],
    likelihood: "medium",
    impact: "critical",
    mitreId: "T1548.005",
  },
  {
    name: "PassRoleToEC2",
    description: "Launch EC2 with high-privilege instance profile",
    steps: [
      "Create/modify instance profile",
      "Launch EC2 instance with profile",
      "Access instance metadata for credentials",
    ],
    requiredPermissions: ["iam:PassRole", "ec2:RunInstances"],
    targetPermissions: ["*"],
    likelihood: "medium",
    impact: "critical",
    mitreId: "T1548.005",
  },
  {
    name: "UpdateAssumeRolePolicy",
    description: "Modify role trust policy to allow assumption",
    steps: [
      "Identify high-privilege role",
      "Update trust policy to allow current principal",
      "Assume role for elevated access",
    ],
    requiredPermissions: ["iam:UpdateAssumeRolePolicy", "sts:AssumeRole"],
    targetPermissions: ["*"],
    likelihood: "medium",
    impact: "critical",
    mitreId: "T1098.003",
  },
  {
    name: "CreatePolicyVersion",
    description: "Create new version of existing policy with elevated permissions",
    steps: [
      "Identify policy attached to current identity",
      "Create new policy version with * permissions",
      "Set new version as default",
    ],
    requiredPermissions: ["iam:CreatePolicyVersion"],
    targetPermissions: ["*"],
    likelihood: "medium",
    impact: "critical",
    mitreId: "T1098.003",
  },
];

const DANGEROUS_PERMISSIONS = [
  { permission: "iam:*", risk: "Full IAM control enables any privilege escalation", mitreId: "T1098" },
  { permission: "iam:CreateAccessKey", risk: "Can create access keys for any user", mitreId: "T1098.001" },
  { permission: "iam:CreateLoginProfile", risk: "Can create console passwords for users", mitreId: "T1098.001" },
  { permission: "iam:UpdateLoginProfile", risk: "Can reset passwords for any user", mitreId: "T1098.001" },
  { permission: "iam:AttachUserPolicy", risk: "Can attach any policy to any user", mitreId: "T1098.003" },
  { permission: "iam:AttachRolePolicy", risk: "Can attach any policy to any role", mitreId: "T1098.003" },
  { permission: "iam:PutUserPolicy", risk: "Can create inline policies for users", mitreId: "T1098.003" },
  { permission: "iam:PutRolePolicy", risk: "Can create inline policies for roles", mitreId: "T1098.003" },
  { permission: "iam:PassRole", risk: "Can pass roles to services for privilege escalation", mitreId: "T1548.005" },
  { permission: "sts:AssumeRole", risk: "Can assume other roles if trust policy allows", mitreId: "T1550.001" },
  { permission: "lambda:CreateFunction", risk: "Can create functions with elevated roles", mitreId: "T1548.005" },
  { permission: "lambda:UpdateFunctionCode", risk: "Can inject malicious code into functions", mitreId: "T1525" },
  { permission: "ec2:RunInstances", risk: "Can launch instances with elevated profiles", mitreId: "T1548.005" },
  { permission: "ssm:SendCommand", risk: "Can execute commands on EC2 instances", mitreId: "T1569.002" },
  { permission: "secretsmanager:GetSecretValue", risk: "Can access secrets and credentials", mitreId: "T1555" },
  { permission: "kms:Decrypt", risk: "Can decrypt sensitive data", mitreId: "T1555" },
  { permission: "s3:*", risk: "Full S3 access including sensitive data", mitreId: "T1530" },
  { permission: "ec2:*", risk: "Full EC2 control including instance takeover", mitreId: "T1578" },
];

const S3_SENSITIVE_PATTERNS = [
  { pattern: /\.pem$|\.key$/i, type: "Private Key", sensitivity: "critical" as const },
  { pattern: /password|secret|credential|api.?key/i, type: "Credentials", sensitivity: "critical" as const },
  { pattern: /\.env$|config\.json|settings\.json/i, type: "Configuration", sensitivity: "high" as const },
  { pattern: /backup|dump|export/i, type: "Backup Data", sensitivity: "high" as const },
  { pattern: /\.sql$|\.db$|\.sqlite$/i, type: "Database", sensitivity: "high" as const },
  { pattern: /customer|user|account/i, type: "Customer Data", sensitivity: "high" as const },
  { pattern: /financial|payment|invoice/i, type: "Financial Data", sensitivity: "high" as const },
  { pattern: /medical|health|hipaa/i, type: "Medical Data", sensitivity: "critical" as const },
  { pattern: /ssn|social.?security/i, type: "SSN/PII", sensitivity: "critical" as const },
];

const LAMBDA_VULNERABILITY_CHECKS = [
  {
    type: "Overprivileged Role",
    check: (fn: LambdaFunctionInfo) => fn.role.includes("AdministratorAccess") || fn.role.includes("PowerUser"),
    severity: "critical" as const,
    description: "Function has overly permissive execution role",
    mitreId: "T1548.005",
  },
  {
    type: "Hardcoded Secrets",
    check: (fn: LambdaFunctionInfo) => {
      const envVars = fn.environmentVariables || {};
      return Object.keys(envVars).some(k => 
        /password|secret|key|token|credential/i.test(k)
      );
    },
    severity: "high" as const,
    description: "Environment variables may contain hardcoded secrets",
    mitreId: "T1552.001",
  },
  {
    type: "No VPC Isolation",
    check: (fn: LambdaFunctionInfo) => !fn.vpcConfig,
    severity: "medium" as const,
    description: "Function not deployed in VPC, has internet access",
    mitreId: "T1190",
  },
  {
    type: "Outdated Runtime",
    check: (fn: LambdaFunctionInfo) => {
      const outdated = ["python2.7", "nodejs8.10", "nodejs10.x", "dotnetcore2.1"];
      return outdated.includes(fn.runtime);
    },
    severity: "high" as const,
    description: "Function uses deprecated runtime with known vulnerabilities",
    mitreId: "T1190",
  },
  {
    type: "Long Timeout",
    check: (fn: LambdaFunctionInfo) => fn.timeout > 300,
    severity: "low" as const,
    description: "Long timeout may allow extended exploitation",
    mitreId: "T1496",
  },
];

class AWSPentestService {
  async analyzeIAMPrivilegeEscalation(
    permissions: string[],
    userId: string = "unknown",
    userName: string = "unknown",
    accountId?: string
  ): Promise<IAMPrivilegeEscalationResult> {
    const id = `aws-iam-${randomUUID().slice(0, 8)}`;
    const escalationPaths: EscalationPath[] = [];
    const dangerousPerms: DangerousPermission[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    for (const path of IAM_ESCALATION_PATHS) {
      const hasRequiredPerms = path.requiredPermissions.every(req =>
        permissions.some(p => this.matchesPermission(p, req))
      );

      if (hasRequiredPerms) {
        escalationPaths.push(path);
        mitreAttackMappings.push({
          techniqueId: path.mitreId,
          techniqueName: path.name,
          tactic: "privilege-escalation",
          description: path.description,
        });
      }
    }

    for (const dangerous of DANGEROUS_PERMISSIONS) {
      const matchingPerms = permissions.filter(p => 
        this.matchesPermission(p, dangerous.permission)
      );

      for (const perm of matchingPerms) {
        dangerousPerms.push({
          permission: perm,
          resource: "*",
          risk: dangerous.risk,
          exploitability: this.getExploitability(perm),
          mitreId: dangerous.mitreId,
        });
      }
    }

    const riskScore = this.calculateIAMRiskScore(escalationPaths, dangerousPerms);
    const recommendations = this.generateIAMRecommendations(escalationPaths, dangerousPerms);

    return {
      id,
      userId,
      userName,
      accountId,
      currentPrivileges: permissions,
      escalationPaths,
      dangerousPermissions: dangerousPerms,
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        permissionsAnalyzed: permissions.length,
        escalationPathsFound: escalationPaths.length,
        dangerousPermissionsFound: dangerousPerms.length,
      },
      timestamp: new Date(),
    };
  }

  async analyzeS3Buckets(
    buckets: Partial<S3BucketInfo>[]
  ): Promise<S3BucketEnumerationResult> {
    const id = `aws-s3-${randomUUID().slice(0, 8)}`;
    const publicBuckets: S3BucketInfo[] = [];
    const misconfigurations: S3Misconfiguration[] = [];
    const sensitiveDataExposures: DataExposure[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    const enrichedBuckets: S3BucketInfo[] = buckets.map(b => ({
      name: b.name || "unknown",
      region: b.region,
      creationDate: b.creationDate,
      isPublic: b.isPublic || false,
      publicAccessBlock: b.publicAccessBlock,
      encryption: b.encryption,
      versioning: b.versioning,
      logging: b.logging,
      objectCount: b.objectCount,
      totalSizeBytes: b.totalSizeBytes,
    }));

    for (const bucket of enrichedBuckets) {
      if (bucket.isPublic) {
        publicBuckets.push(bucket);
        misconfigurations.push({
          bucketName: bucket.name,
          type: "Public Access",
          severity: "critical",
          description: "Bucket is publicly accessible",
          remediation: "Enable S3 Block Public Access settings",
          mitreId: "T1530",
        });
      }

      if (!bucket.encryption?.enabled) {
        misconfigurations.push({
          bucketName: bucket.name,
          type: "No Encryption",
          severity: "high",
          description: "Bucket does not have encryption enabled",
          remediation: "Enable SSE-S3 or SSE-KMS encryption",
          mitreId: "T1530",
        });
      }

      if (!bucket.versioning) {
        misconfigurations.push({
          bucketName: bucket.name,
          type: "No Versioning",
          severity: "medium",
          description: "Bucket versioning not enabled, no protection against accidental deletion",
          remediation: "Enable bucket versioning",
        });
      }

      if (!bucket.logging) {
        misconfigurations.push({
          bucketName: bucket.name,
          type: "No Access Logging",
          severity: "medium",
          description: "Access logging not enabled, cannot audit bucket access",
          remediation: "Enable server access logging",
        });
      }

      if (!bucket.publicAccessBlock?.blockPublicAcls) {
        misconfigurations.push({
          bucketName: bucket.name,
          type: "Public ACLs Allowed",
          severity: "high",
          description: "Bucket allows public ACLs to be applied",
          remediation: "Enable Block Public ACLs setting",
          mitreId: "T1530",
        });
      }
    }

    if (publicBuckets.length > 0) {
      mitreAttackMappings.push({
        techniqueId: "T1530",
        techniqueName: "Data from Cloud Storage",
        tactic: "collection",
        description: "Public buckets allow unauthorized data access",
      });
    }

    const riskScore = this.calculateS3RiskScore(publicBuckets, misconfigurations);
    const recommendations = this.generateS3Recommendations(misconfigurations);

    return {
      id,
      bucketsFound: enrichedBuckets,
      publicBuckets,
      sensitiveDataExposures,
      misconfigurations,
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        bucketsAnalyzed: enrichedBuckets.length,
        publicBucketsFound: publicBuckets.length,
        misconfigurationsFound: misconfigurations.length,
      },
      timestamp: new Date(),
    };
  }

  async analyzeLambdaFunctions(
    functions: Partial<LambdaFunctionInfo>[]
  ): Promise<LambdaAbuseResult> {
    const id = `aws-lambda-${randomUUID().slice(0, 8)}`;
    const vulnerabilities: LambdaVulnerability[] = [];
    const escalationRisks: LambdaEscalationRisk[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    const enrichedFunctions: LambdaFunctionInfo[] = functions.map(f => ({
      functionName: f.functionName || "unknown",
      functionArn: f.functionArn || "",
      runtime: f.runtime || "unknown",
      role: f.role || "",
      handler: f.handler || "",
      codeSize: f.codeSize || 0,
      timeout: f.timeout || 3,
      memorySize: f.memorySize || 128,
      lastModified: f.lastModified || new Date().toISOString(),
      environmentVariables: f.environmentVariables,
      vpcConfig: f.vpcConfig,
    }));

    for (const fn of enrichedFunctions) {
      for (const check of LAMBDA_VULNERABILITY_CHECKS) {
        if (check.check(fn)) {
          vulnerabilities.push({
            functionName: fn.functionName,
            type: check.type,
            severity: check.severity,
            description: check.description,
            exploitability: this.getVulnExploitability(check.severity),
            remediation: this.getLambdaRemediation(check.type),
            mitreId: check.mitreId,
          });

          if (check.mitreId) {
            mitreAttackMappings.push({
              techniqueId: check.mitreId,
              techniqueName: check.type,
              tactic: "execution",
              description: check.description,
            });
          }
        }
      }

      if (fn.role.includes("Admin") || fn.role.includes("PowerUser")) {
        escalationRisks.push({
          functionName: fn.functionName,
          roleArn: fn.role,
          dangerousPermissions: ["*"],
          escalationPath: "Invoke function to execute privileged actions",
          impact: "Full account compromise possible",
          mitreId: "T1548.005",
        });
      }
    }

    const riskScore = this.calculateLambdaRiskScore(vulnerabilities, escalationRisks);
    const recommendations = this.generateLambdaRecommendations(vulnerabilities, escalationRisks);

    return {
      id,
      functionsAnalyzed: enrichedFunctions,
      vulnerabilities,
      privilegeEscalationRisks: escalationRisks,
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        functionsAnalyzed: enrichedFunctions.length,
        vulnerabilitiesFound: vulnerabilities.length,
        escalationRisksFound: escalationRisks.length,
      },
      timestamp: new Date(),
    };
  }

  private matchesPermission(actual: string, required: string): boolean {
    if (actual === "*" || actual === required) return true;
    if (actual.endsWith(":*")) {
      const [service] = actual.split(":");
      return required.startsWith(service + ":");
    }
    const actualPattern = actual.replace(/\*/g, ".*");
    return new RegExp(`^${actualPattern}$`).test(required);
  }

  private getExploitability(permission: string): "easy" | "moderate" | "difficult" {
    const easyPerms = ["iam:CreateAccessKey", "iam:CreateLoginProfile", "iam:UpdateLoginProfile"];
    const moderatePerms = ["iam:AttachUserPolicy", "iam:AttachRolePolicy", "iam:PutUserPolicy"];
    
    if (easyPerms.some(p => permission.includes(p.split(":")[1]))) return "easy";
    if (moderatePerms.some(p => permission.includes(p.split(":")[1]))) return "moderate";
    return "difficult";
  }

  private getVulnExploitability(severity: string): string {
    switch (severity) {
      case "critical": return "Trivial - direct exploitation possible";
      case "high": return "Easy - requires minimal effort";
      case "medium": return "Moderate - requires some skill";
      default: return "Difficult - requires significant effort";
    }
  }

  private calculateIAMRiskScore(paths: EscalationPath[], perms: DangerousPermission[]): number {
    let score = 0;
    
    for (const path of paths) {
      score += path.impact === "critical" ? 25 : path.impact === "high" ? 15 : 10;
    }
    
    for (const perm of perms) {
      score += perm.exploitability === "easy" ? 10 : perm.exploitability === "moderate" ? 5 : 2;
    }
    
    return Math.min(100, score);
  }

  private calculateS3RiskScore(publicBuckets: S3BucketInfo[], misconfigs: S3Misconfiguration[]): number {
    let score = publicBuckets.length * 25;
    
    for (const m of misconfigs) {
      score += m.severity === "critical" ? 15 : m.severity === "high" ? 10 : 5;
    }
    
    return Math.min(100, score);
  }

  private calculateLambdaRiskScore(vulns: LambdaVulnerability[], risks: LambdaEscalationRisk[]): number {
    let score = 0;
    
    for (const v of vulns) {
      score += v.severity === "critical" ? 20 : v.severity === "high" ? 15 : 5;
    }
    
    score += risks.length * 25;
    
    return Math.min(100, score);
  }

  private generateIAMRecommendations(paths: EscalationPath[], perms: DangerousPermission[]): string[] {
    const recs: string[] = [];
    
    if (paths.length > 0) {
      recs.push("Implement least privilege principle - remove unnecessary IAM permissions");
      recs.push("Enable AWS CloudTrail for IAM activity monitoring");
      recs.push("Use IAM Access Analyzer to identify overprivileged access");
    }
    
    if (perms.some(p => p.permission.includes("iam:"))) {
      recs.push("Restrict IAM administrative permissions to dedicated admin roles");
      recs.push("Implement permission boundaries for IAM users and roles");
    }
    
    if (perms.some(p => p.permission.includes("PassRole"))) {
      recs.push("Restrict iam:PassRole to specific role ARNs using resource conditions");
    }
    
    if (paths.some(p => p.name.includes("Lambda") || p.name.includes("EC2"))) {
      recs.push("Implement service control policies (SCPs) to limit service usage");
    }
    
    recs.push("Enable MFA for all IAM users with console access");
    recs.push("Regularly rotate access keys and review unused credentials");
    
    return recs;
  }

  private generateS3Recommendations(misconfigs: S3Misconfiguration[]): string[] {
    const recs: string[] = [];
    
    if (misconfigs.some(m => m.type === "Public Access")) {
      recs.push("Enable S3 Block Public Access at account and bucket level");
      recs.push("Review and remove public bucket policies and ACLs");
    }
    
    if (misconfigs.some(m => m.type === "No Encryption")) {
      recs.push("Enable default encryption (SSE-S3 or SSE-KMS) for all buckets");
      recs.push("Consider using customer-managed KMS keys for sensitive data");
    }
    
    if (misconfigs.some(m => m.type === "No Versioning")) {
      recs.push("Enable versioning for critical buckets to protect against accidental deletion");
    }
    
    if (misconfigs.some(m => m.type === "No Access Logging")) {
      recs.push("Enable S3 access logging for security monitoring and compliance");
    }
    
    recs.push("Implement bucket policies that explicitly deny public access");
    recs.push("Use VPC endpoints for private S3 access from within VPC");
    
    return recs;
  }

  private generateLambdaRecommendations(vulns: LambdaVulnerability[], risks: LambdaEscalationRisk[]): string[] {
    const recs: string[] = [];
    
    if (vulns.some(v => v.type === "Overprivileged Role")) {
      recs.push("Apply least privilege to Lambda execution roles");
      recs.push("Use separate roles for each function with minimal permissions");
    }
    
    if (vulns.some(v => v.type === "Hardcoded Secrets")) {
      recs.push("Use AWS Secrets Manager or Parameter Store for sensitive values");
      recs.push("Enable encryption for Lambda environment variables");
    }
    
    if (vulns.some(v => v.type === "No VPC Isolation")) {
      recs.push("Deploy Lambda functions in VPC for network isolation");
      recs.push("Use security groups to control function network access");
    }
    
    if (vulns.some(v => v.type === "Outdated Runtime")) {
      recs.push("Upgrade Lambda functions to supported runtimes");
      recs.push("Implement automated runtime upgrade process");
    }
    
    if (risks.length > 0) {
      recs.push("Review and restrict iam:PassRole permissions for Lambda");
      recs.push("Implement function URL authentication if using Lambda URLs");
    }
    
    return recs;
  }

  private getLambdaRemediation(type: string): string {
    const remediations: Record<string, string> = {
      "Overprivileged Role": "Create a dedicated execution role with only required permissions",
      "Hardcoded Secrets": "Migrate secrets to AWS Secrets Manager and use GetSecretValue API",
      "No VPC Isolation": "Configure VPC settings with appropriate subnets and security groups",
      "Outdated Runtime": "Update runtime to latest supported version",
      "Long Timeout": "Reduce timeout to minimum required for function execution",
    };
    return remediations[type] || "Review and remediate the identified issue";
  }
}

export const awsPentestService = new AWSPentestService();
