import { randomUUID } from "crypto";

export interface GCPServiceAccountResult {
  id: string;
  accountsAnalyzed: ServiceAccountInfo[];
  impersonationRisks: ServiceAccountImpersonation[];
  keyExposures: ServiceAccountKeyExposure[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
  timestamp: Date;
}

export interface ServiceAccountInfo {
  email: string;
  projectId: string;
  uniqueId: string;
  displayName?: string;
  disabled: boolean;
  iamBindings: IAMBinding[];
  keys: ServiceAccountKey[];
}

export interface ServiceAccountKey {
  keyId: string;
  keyType: "USER_MANAGED" | "SYSTEM_MANAGED";
  keyOrigin: string;
  validAfterTime: Date;
  validBeforeTime?: Date;
  keyAlgorithm: string;
}

export interface IAMBinding {
  role: string;
  members: string[];
  condition?: {
    title: string;
    expression: string;
  };
}

export interface ServiceAccountImpersonation {
  sourceAccount: string;
  targetAccount: string;
  impersonationPath: string;
  dangerousRoles: string[];
  impact: string;
  likelihood: "high" | "medium" | "low";
  mitreId: string;
}

export interface ServiceAccountKeyExposure {
  serviceAccount: string;
  keyId: string;
  exposureType: string;
  ageInDays: number;
  severity: "critical" | "high" | "medium" | "low";
  mitreId: string;
}

export interface GCPMetadataAbuseResult {
  id: string;
  instancesAnalyzed: ComputeInstanceInfo[];
  metadataVulnerabilities: MetadataVulnerability[];
  networkExposures: NetworkExposure[];
  recommendations: string[];
  riskScore: number;
  mitreAttackMappings: MitreMapping[];
  evidence: Record<string, unknown>;
  timestamp: Date;
}

export interface ComputeInstanceInfo {
  name: string;
  zone: string;
  machineType: string;
  status: string;
  serviceAccount?: string;
  serviceAccountScopes?: string[];
  networkInterfaces: NetworkInterface[];
  metadata?: Record<string, string>;
  shieldedInstanceConfig?: {
    enableSecureBoot: boolean;
    enableVtpm: boolean;
    enableIntegrityMonitoring: boolean;
  };
}

export interface NetworkInterface {
  network: string;
  subnetwork?: string;
  networkIP: string;
  accessConfigs?: {
    type: string;
    natIP?: string;
  }[];
}

export interface MetadataVulnerability {
  instanceName: string;
  type: string;
  severity: "critical" | "high" | "medium" | "low";
  description: string;
  exploitability: string;
  remediation: string;
  mitreId: string;
}

export interface NetworkExposure {
  instanceName: string;
  exposureType: string;
  publicIP?: string;
  risk: string;
  mitreId: string;
}

export interface MitreMapping {
  techniqueId: string;
  techniqueName: string;
  tactic: string;
  description: string;
}

const DANGEROUS_GCP_ROLES = [
  { role: "roles/owner", risk: "Full project control", mitreId: "T1098" },
  { role: "roles/editor", risk: "Can modify most resources", mitreId: "T1098" },
  { role: "roles/iam.serviceAccountAdmin", risk: "Can manage service accounts", mitreId: "T1098.003" },
  { role: "roles/iam.serviceAccountTokenCreator", risk: "Can impersonate service accounts", mitreId: "T1550.001" },
  { role: "roles/iam.serviceAccountKeyAdmin", risk: "Can create service account keys", mitreId: "T1098.001" },
  { role: "roles/compute.admin", risk: "Full compute control", mitreId: "T1578" },
  { role: "roles/storage.admin", risk: "Full storage control", mitreId: "T1530" },
  { role: "roles/secretmanager.admin", risk: "Can access all secrets", mitreId: "T1555" },
  { role: "roles/cloudfunctions.admin", risk: "Can deploy malicious functions", mitreId: "T1525" },
];

const IMPERSONATION_PATHS = [
  {
    name: "Token Creator to Service Account",
    description: "Use serviceAccountTokenCreator role to impersonate other service accounts",
    requiredRole: "roles/iam.serviceAccountTokenCreator",
    targetCapability: "Full impersonation",
    likelihood: "high" as const,
    mitreId: "T1550.001",
  },
  {
    name: "Key Admin to Service Account",
    description: "Create new key for service account to gain its permissions",
    requiredRole: "roles/iam.serviceAccountKeyAdmin",
    targetCapability: "Persistent access via key",
    likelihood: "high" as const,
    mitreId: "T1098.001",
  },
  {
    name: "Compute to Service Account",
    description: "Access VM metadata to obtain service account token",
    requiredRole: "roles/compute.instanceAdmin",
    targetCapability: "Access via metadata server",
    likelihood: "medium" as const,
    mitreId: "T1552.005",
  },
  {
    name: "Cloud Function to Service Account",
    description: "Deploy function with target service account",
    requiredRole: "roles/cloudfunctions.admin",
    targetCapability: "Code execution as service account",
    likelihood: "medium" as const,
    mitreId: "T1548.005",
  },
];

const METADATA_VULNERABILITY_CHECKS = [
  {
    type: "Default Service Account",
    check: (instance: ComputeInstanceInfo) => 
      instance.serviceAccount?.includes("-compute@developer.gserviceaccount.com"),
    severity: "high" as const,
    description: "Instance uses default compute service account with broad permissions",
    mitreId: "T1078.004",
  },
  {
    type: "Full API Scopes",
    check: (instance: ComputeInstanceInfo) =>
      instance.serviceAccountScopes?.includes("https://www.googleapis.com/auth/cloud-platform"),
    severity: "critical" as const,
    description: "Instance has full cloud-platform scope enabling broad API access",
    mitreId: "T1078.004",
  },
  {
    type: "Startup Script Secrets",
    check: (instance: ComputeInstanceInfo) => {
      const script = instance.metadata?.["startup-script"] || "";
      return /password|secret|key|token|credential/i.test(script);
    },
    severity: "critical" as const,
    description: "Startup script may contain hardcoded secrets",
    mitreId: "T1552.001",
  },
  {
    type: "SSH Keys in Metadata",
    check: (instance: ComputeInstanceInfo) =>
      !!instance.metadata?.["ssh-keys"],
    severity: "medium" as const,
    description: "Instance has SSH keys configured in metadata",
    mitreId: "T1098.004",
  },
  {
    type: "No Shielded VM",
    check: (instance: ComputeInstanceInfo) =>
      !instance.shieldedInstanceConfig?.enableSecureBoot,
    severity: "medium" as const,
    description: "Instance does not have Shielded VM security features enabled",
    mitreId: "T1542",
  },
];

class GCPPentestService {
  async analyzeServiceAccounts(
    accounts: Partial<ServiceAccountInfo>[]
  ): Promise<GCPServiceAccountResult> {
    const id = `gcp-sa-${randomUUID().slice(0, 8)}`;
    const impersonationRisks: ServiceAccountImpersonation[] = [];
    const keyExposures: ServiceAccountKeyExposure[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    const enrichedAccounts: ServiceAccountInfo[] = accounts.map(a => ({
      email: a.email || "unknown@unknown.iam.gserviceaccount.com",
      projectId: a.projectId || "",
      uniqueId: a.uniqueId || "",
      displayName: a.displayName,
      disabled: a.disabled ?? false,
      iamBindings: a.iamBindings || [],
      keys: a.keys || [],
    }));

    for (const account of enrichedAccounts) {
      for (const binding of account.iamBindings) {
        const dangerousRole = DANGEROUS_GCP_ROLES.find(dr => binding.role === dr.role);
        if (dangerousRole) {
          const impersonationPath = IMPERSONATION_PATHS.find(ip =>
            binding.role === ip.requiredRole || binding.role === "roles/owner" || binding.role === "roles/editor"
          );

          if (impersonationPath) {
            impersonationRisks.push({
              sourceAccount: account.email,
              targetAccount: "any service account in project",
              impersonationPath: impersonationPath.description,
              dangerousRoles: [binding.role],
              impact: impersonationPath.targetCapability,
              likelihood: impersonationPath.likelihood,
              mitreId: impersonationPath.mitreId,
            });

            mitreAttackMappings.push({
              techniqueId: impersonationPath.mitreId,
              techniqueName: impersonationPath.name,
              tactic: "privilege-escalation",
              description: impersonationPath.description,
            });
          }
        }
      }

      for (const key of account.keys) {
        if (key.keyType === "USER_MANAGED") {
          const ageInDays = Math.floor(
            (Date.now() - new Date(key.validAfterTime).getTime()) / (1000 * 60 * 60 * 24)
          );

          if (ageInDays > 90) {
            keyExposures.push({
              serviceAccount: account.email,
              keyId: key.keyId,
              exposureType: "Old Key",
              ageInDays,
              severity: ageInDays > 365 ? "critical" : "high",
              mitreId: "T1552.001",
            });
          }

          if (!key.validBeforeTime) {
            keyExposures.push({
              serviceAccount: account.email,
              keyId: key.keyId,
              exposureType: "No Expiration",
              ageInDays,
              severity: "high",
              mitreId: "T1552.001",
            });
          }
        }
      }
    }

    if (keyExposures.length > 0) {
      mitreAttackMappings.push({
        techniqueId: "T1552.001",
        techniqueName: "Credentials in Files",
        tactic: "credential-access",
        description: "Service account keys may be stored insecurely",
      });
    }

    const riskScore = this.calculateSARiskScore(impersonationRisks, keyExposures);
    const recommendations = this.generateSARecommendations(impersonationRisks, keyExposures);

    return {
      id,
      accountsAnalyzed: enrichedAccounts,
      impersonationRisks,
      keyExposures,
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        accountsAnalyzed: enrichedAccounts.length,
        impersonationRisksFound: impersonationRisks.length,
        keyExposuresFound: keyExposures.length,
      },
      timestamp: new Date(),
    };
  }

  async analyzeComputeMetadata(
    instances: Partial<ComputeInstanceInfo>[]
  ): Promise<GCPMetadataAbuseResult> {
    const id = `gcp-metadata-${randomUUID().slice(0, 8)}`;
    const metadataVulnerabilities: MetadataVulnerability[] = [];
    const networkExposures: NetworkExposure[] = [];
    const mitreAttackMappings: MitreMapping[] = [];

    const enrichedInstances: ComputeInstanceInfo[] = instances.map(i => ({
      name: i.name || "unknown",
      zone: i.zone || "",
      machineType: i.machineType || "",
      status: i.status || "RUNNING",
      serviceAccount: i.serviceAccount,
      serviceAccountScopes: i.serviceAccountScopes,
      networkInterfaces: i.networkInterfaces || [],
      metadata: i.metadata,
      shieldedInstanceConfig: i.shieldedInstanceConfig,
    }));

    for (const instance of enrichedInstances) {
      for (const check of METADATA_VULNERABILITY_CHECKS) {
        if (check.check(instance)) {
          metadataVulnerabilities.push({
            instanceName: instance.name,
            type: check.type,
            severity: check.severity,
            description: check.description,
            exploitability: this.getExploitability(check.severity),
            remediation: this.getMetadataRemediation(check.type),
            mitreId: check.mitreId,
          });

          mitreAttackMappings.push({
            techniqueId: check.mitreId,
            techniqueName: check.type,
            tactic: "credential-access",
            description: check.description,
          });
        }
      }

      for (const nic of instance.networkInterfaces) {
        const accessConfigs = nic.accessConfigs || [];
        for (const config of accessConfigs) {
          if (config.natIP) {
            networkExposures.push({
              instanceName: instance.name,
              exposureType: "Public IP",
              publicIP: config.natIP,
              risk: "Instance accessible from internet",
              mitreId: "T1190",
            });
          }
        }
      }
    }

    if (networkExposures.length > 0) {
      mitreAttackMappings.push({
        techniqueId: "T1190",
        techniqueName: "Exploit Public-Facing Application",
        tactic: "initial-access",
        description: "Instances with public IPs are exposed to internet attacks",
      });
    }

    const riskScore = this.calculateMetadataRiskScore(metadataVulnerabilities, networkExposures);
    const recommendations = this.generateMetadataRecommendations(metadataVulnerabilities, networkExposures);

    return {
      id,
      instancesAnalyzed: enrichedInstances,
      metadataVulnerabilities,
      networkExposures,
      recommendations,
      riskScore,
      mitreAttackMappings,
      evidence: {
        instancesAnalyzed: enrichedInstances.length,
        metadataVulnerabilitiesFound: metadataVulnerabilities.length,
        networkExposuresFound: networkExposures.length,
      },
      timestamp: new Date(),
    };
  }

  private getExploitability(severity: string): string {
    switch (severity) {
      case "critical": return "Trivial - metadata server always accessible from instance";
      case "high": return "Easy - requires instance access";
      case "medium": return "Moderate - requires specific conditions";
      default: return "Difficult - requires chained exploitation";
    }
  }

  private getMetadataRemediation(type: string): string {
    const remediations: Record<string, string> = {
      "Default Service Account": "Create dedicated service account with minimal permissions",
      "Full API Scopes": "Restrict scopes to only required APIs",
      "Startup Script Secrets": "Use Secret Manager instead of metadata for secrets",
      "SSH Keys in Metadata": "Use OS Login instead of metadata SSH keys",
      "No Shielded VM": "Enable Shielded VM features (Secure Boot, vTPM, Integrity Monitoring)",
    };
    return remediations[type] || "Review and remediate the identified issue";
  }

  private calculateSARiskScore(
    impersonations: ServiceAccountImpersonation[],
    keyExposures: ServiceAccountKeyExposure[]
  ): number {
    let score = 0;
    for (const i of impersonations) {
      score += i.likelihood === "high" ? 25 : i.likelihood === "medium" ? 15 : 10;
    }
    for (const k of keyExposures) {
      score += k.severity === "critical" ? 20 : k.severity === "high" ? 15 : 10;
    }
    return Math.min(100, score);
  }

  private calculateMetadataRiskScore(
    vulns: MetadataVulnerability[],
    exposures: NetworkExposure[]
  ): number {
    let score = 0;
    for (const v of vulns) {
      score += v.severity === "critical" ? 20 : v.severity === "high" ? 15 : 10;
    }
    score += exposures.length * 15;
    return Math.min(100, score);
  }

  private generateSARecommendations(
    impersonations: ServiceAccountImpersonation[],
    keyExposures: ServiceAccountKeyExposure[]
  ): string[] {
    const recs: string[] = [];
    
    if (impersonations.length > 0) {
      recs.push("Review and minimize service account IAM bindings");
      recs.push("Use Workload Identity Federation instead of service account keys");
      recs.push("Implement service account impersonation logging");
    }
    
    if (impersonations.some(i => i.dangerousRoles.some(r => r.includes("TokenCreator")))) {
      recs.push("Restrict serviceAccountTokenCreator role to essential principals only");
    }
    
    if (keyExposures.length > 0) {
      recs.push("Rotate service account keys older than 90 days");
      recs.push("Set key expiration times for all user-managed keys");
      recs.push("Migrate to workload identity where possible to eliminate key usage");
    }
    
    recs.push("Enable Cloud Audit Logs for IAM activity");
    recs.push("Use Organization Policy to restrict service account key creation");
    
    return recs;
  }

  private generateMetadataRecommendations(
    vulns: MetadataVulnerability[],
    exposures: NetworkExposure[]
  ): string[] {
    const recs: string[] = [];
    
    if (vulns.some(v => v.type === "Default Service Account")) {
      recs.push("Create dedicated service accounts for each workload");
      recs.push("Avoid using default compute service account");
    }
    
    if (vulns.some(v => v.type === "Full API Scopes")) {
      recs.push("Apply principle of least privilege to service account scopes");
      recs.push("Use fine-grained API scopes instead of cloud-platform");
    }
    
    if (vulns.some(v => v.type === "Startup Script Secrets")) {
      recs.push("Migrate secrets from metadata to Secret Manager");
      recs.push("Use IAM-based secret access instead of embedding in scripts");
    }
    
    if (vulns.some(v => v.type === "SSH Keys in Metadata")) {
      recs.push("Enable OS Login for centralized SSH key management");
      recs.push("Remove project-wide SSH keys from metadata");
    }
    
    if (exposures.length > 0) {
      recs.push("Remove unnecessary public IP addresses from instances");
      recs.push("Use Cloud NAT for outbound internet access without public IPs");
      recs.push("Implement VPC firewall rules to restrict access");
    }
    
    recs.push("Enable VPC Flow Logs for network visibility");
    recs.push("Use Shielded VMs for enhanced instance security");
    
    return recs;
  }
}

export const gcpPentestService = new GCPPentestService();
