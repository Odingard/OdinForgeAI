import https from "https";
import http from "http";
import { URL } from "url";

export interface ExploitRequest {
  method: string;
  url: string;
  headers?: Record<string, string>;
  body?: string;
  timeout?: number;
  followRedirects?: boolean;
  maxRedirects?: number;
  verifySsl?: boolean;
}

export interface ExploitResponse {
  statusCode: number;
  statusMessage: string;
  headers: Record<string, string>;
  body: string;
  timing: {
    dnsLookup?: number;
    tcpConnect?: number;
    tlsHandshake?: number;
    firstByte: number;
    total: number;
  };
  redirectChain: string[];
  error?: string;
}

export interface VulnerabilityIndicator {
  type: string;
  severity: "critical" | "high" | "medium" | "low" | "info";
  description: string;
  evidence: string;
  mitreId?: string;
}

export interface DispatchResult {
  success: boolean;
  request: {
    method: string;
    url: string;
    headers: Record<string, string>;
    body?: string;
  };
  response: ExploitResponse;
  indicators: VulnerabilityIndicator[];
  isVulnerable: boolean;
  vulnerabilityType?: string;
  confidenceScore: number;
}

const VULN_PATTERNS = {
  sqli: {
    errorPatterns: [
      /SQL syntax.*MySQL/i,
      /Warning.*mysql_/i,
      /PostgreSQL.*ERROR/i,
      /ORA-\d{5}/i,
      /Microsoft SQL Server.*Error/i,
      /Unclosed quotation mark/i,
      /SQLSTATE\[/i,
      /syntax error at or near/i,
      /pg_query\(\)/i,
      /PDOException/i,
    ],
    timeBasedThreshold: 4500,
    booleanDiffThreshold: 0.3,
  },
  xss: {
    reflectionPatterns: [
      /<script[^>]*>.*<\/script>/i,
      /javascript:/i,
      /on\w+\s*=/i,
      /<svg[^>]*onload/i,
      /<img[^>]*onerror/i,
    ],
  },
  rce: {
    patterns: [
      /uid=\d+\(.*\) gid=\d+/,
      /Linux.*\d+\.\d+\.\d+/,
      /Windows NT/,
      /root:.*:0:0:/,
      /Microsoft Windows \[Version/,
    ],
  },
  ssrf: {
    internalPatterns: [
      /localhost/i,
      /127\.0\.0\.1/,
      /10\.\d+\.\d+\.\d+/,
      /172\.(1[6-9]|2[0-9]|3[01])\.\d+\.\d+/,
      /192\.168\.\d+\.\d+/,
      /metadata\.google\.internal/i,
      /169\.254\.169\.254/,
    ],
  },
  pathTraversal: {
    patterns: [
      /root:.*:0:0:/,
      /\[boot loader\]/i,
      /\[extensions\]/i,
      /DB_HOST|DB_PASSWORD|API_KEY/i,
    ],
  },
  xxe: {
    patterns: [
      /root:.*:0:0:/,
      /<!ENTITY/,
      /SYSTEM\s+"file:/i,
    ],
  },
};

class HttpExploitDispatcher {
  private userAgent = "OdinForge-AEV/1.0";
  private maxBodySize = 10 * 1024 * 1024;

  async dispatch(
    request: ExploitRequest,
    payloadCategory: string,
    payloadContent: string
  ): Promise<DispatchResult> {
    const startTime = Date.now();
    const requestHeaders: Record<string, string> = {
      "User-Agent": this.userAgent,
      "Accept": "*/*",
      "Connection": "close",
      ...request.headers,
    };

    const requestData = {
      method: request.method.toUpperCase(),
      url: request.url,
      headers: requestHeaders,
      body: request.body,
    };

    try {
      const response = await this.executeRequest({
        ...request,
        headers: requestHeaders,
        timeout: request.timeout || 30000,
        followRedirects: request.followRedirects ?? true,
        maxRedirects: request.maxRedirects || 5,
        verifySsl: request.verifySsl ?? false,
      });

      const indicators = this.analyzeResponse(
        response,
        payloadCategory,
        payloadContent,
        startTime
      );

      const isVulnerable = indicators.some(
        i => i.severity === "critical" || i.severity === "high"
      );

      return {
        success: true,
        request: requestData,
        response,
        indicators,
        isVulnerable,
        vulnerabilityType: isVulnerable ? payloadCategory : undefined,
        confidenceScore: this.calculateConfidence(indicators),
      };
    } catch (error: any) {
      const errorResponse: ExploitResponse = {
        statusCode: 0,
        statusMessage: "Request Failed",
        headers: {},
        body: "",
        timing: { firstByte: 0, total: Date.now() - startTime },
        redirectChain: [],
        error: error.message,
      };

      if (error.code === "ETIMEDOUT" && payloadCategory === "sqli") {
        const indicators = [{
          type: "time_based_sqli",
          severity: "high" as const,
          description: "Timeout may indicate time-based SQL injection",
          evidence: `Request timed out after ${request.timeout || 30000}ms`,
          mitreId: "T1190",
        }];

        return {
          success: true,
          request: requestData,
          response: errorResponse,
          indicators,
          isVulnerable: true,
          vulnerabilityType: "sqli",
          confidenceScore: 70,
        };
      }

      return {
        success: false,
        request: requestData,
        response: errorResponse,
        indicators: [],
        isVulnerable: false,
        confidenceScore: 0,
      };
    }
  }

  private async executeRequest(request: ExploitRequest): Promise<ExploitResponse> {
    return new Promise((resolve, reject) => {
      const parsedUrl = new URL(request.url);
      const isHttps = parsedUrl.protocol === "https:";
      const httpModule = isHttps ? https : http;

      const timingData = {
        start: Date.now(),
        firstByte: 0,
      };

      const requestOptions = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port || (isHttps ? 443 : 80),
        path: parsedUrl.pathname + parsedUrl.search,
        method: request.method,
        headers: request.headers,
        timeout: request.timeout,
        ...(isHttps && { rejectUnauthorized: request.verifySsl }),
      };

      const redirectChain: string[] = [];
      let redirectCount = 0;

      const makeRequest = (options: http.RequestOptions, url: string) => {
        const req = httpModule.request(options, (res) => {
          timingData.firstByte = Date.now() - timingData.start;

          if (
            res.statusCode &&
            [301, 302, 303, 307, 308].includes(res.statusCode) &&
            request.followRedirects &&
            res.headers.location
          ) {
            if (redirectCount >= (request.maxRedirects || 5)) {
              reject(new Error("Too many redirects"));
              return;
            }

            redirectChain.push(url);
            redirectCount++;

            try {
              const redirectUrl = new URL(res.headers.location, url);
              const redirectIsHttps = redirectUrl.protocol === "https:";
              const redirectModule = redirectIsHttps ? https : http;

              const redirectOptions = {
                hostname: redirectUrl.hostname,
                port: redirectUrl.port || (redirectIsHttps ? 443 : 80),
                path: redirectUrl.pathname + redirectUrl.search,
                method: "GET",
                headers: request.headers,
                timeout: request.timeout,
                ...(redirectIsHttps && { rejectUnauthorized: request.verifySsl }),
              };

              makeRequest.call(this, redirectOptions, redirectUrl.toString());
            } catch (e) {
              reject(new Error(`Invalid redirect URL: ${res.headers.location}`));
            }
            return;
          }

          const chunks: Buffer[] = [];
          let totalSize = 0;

          res.on("data", (chunk: Buffer) => {
            totalSize += chunk.length;
            if (totalSize <= this.maxBodySize) {
              chunks.push(chunk);
            }
          });

          res.on("end", () => {
            const body = Buffer.concat(chunks).toString("utf-8");
            const headers: Record<string, string> = {};
            
            for (const [key, value] of Object.entries(res.headers)) {
              if (typeof value === "string") {
                headers[key] = value;
              } else if (Array.isArray(value)) {
                headers[key] = value.join(", ");
              }
            }

            resolve({
              statusCode: res.statusCode || 0,
              statusMessage: res.statusMessage || "",
              headers,
              body,
              timing: {
                firstByte: timingData.firstByte,
                total: Date.now() - timingData.start,
              },
              redirectChain,
            });
          });

          res.on("error", reject);
        });

        req.on("timeout", () => {
          req.destroy();
          reject(new Error("Request timeout"));
        });

        req.on("error", reject);

        if (request.body) {
          req.write(request.body);
        }

        req.end();
      };

      makeRequest(requestOptions, request.url);
    });
  }

  private analyzeResponse(
    response: ExploitResponse,
    category: string,
    payload: string,
    startTime: number
  ): VulnerabilityIndicator[] {
    const indicators: VulnerabilityIndicator[] = [];
    const responseBody = response.body || "";
    const responseLower = responseBody.toLowerCase();

    switch (category) {
      case "sqli":
        indicators.push(...this.analyzeSqli(response, payload, startTime));
        break;
      case "xss":
        indicators.push(...this.analyzeXss(response, payload));
        break;
      case "rce":
        indicators.push(...this.analyzeRce(response));
        break;
      case "ssrf":
        indicators.push(...this.analyzeSsrf(response));
        break;
      case "path_traversal":
        indicators.push(...this.analyzePathTraversal(response));
        break;
      case "xxe":
        indicators.push(...this.analyzeXxe(response));
        break;
      default:
        if (responseBody.includes(payload)) {
          indicators.push({
            type: "payload_reflection",
            severity: "medium",
            description: "Payload reflected in response without encoding",
            evidence: `Payload found in response body`,
            mitreId: "T1190",
          });
        }
    }

    if (response.statusCode >= 500) {
      indicators.push({
        type: "server_error",
        severity: "info",
        description: "Server error may indicate processing issue",
        evidence: `HTTP ${response.statusCode}: ${response.statusMessage}`,
      });
    }

    return indicators;
  }

  private analyzeSqli(
    response: ExploitResponse,
    payload: string,
    startTime: number
  ): VulnerabilityIndicator[] {
    const indicators: VulnerabilityIndicator[] = [];
    const body = response.body || "";

    for (const pattern of VULN_PATTERNS.sqli.errorPatterns) {
      const match = body.match(pattern);
      if (match) {
        indicators.push({
          type: "sqli_error_based",
          severity: "critical",
          description: "SQL error message detected in response",
          evidence: match[0].substring(0, 200),
          mitreId: "T1190",
        });
        break;
      }
    }

    if (payload.includes("WAITFOR") || payload.includes("SLEEP") || payload.includes("pg_sleep")) {
      const responseTime = response.timing.total;
      if (responseTime >= VULN_PATTERNS.sqli.timeBasedThreshold) {
        indicators.push({
          type: "sqli_time_based",
          severity: "high",
          description: "Time-based blind SQL injection detected",
          evidence: `Response took ${responseTime}ms, indicating time-based injection success`,
          mitreId: "T1190",
        });
      }
    }

    return indicators;
  }

  private analyzeXss(
    response: ExploitResponse,
    payload: string
  ): VulnerabilityIndicator[] {
    const indicators: VulnerabilityIndicator[] = [];
    const body = response.body || "";
    const contentType = response.headers["content-type"] || "";

    if (body.includes(payload)) {
      const isHtmlContext = contentType.includes("text/html");
      
      if (isHtmlContext) {
        indicators.push({
          type: "xss_reflected",
          severity: "high",
          description: "XSS payload reflected in HTML response without encoding",
          evidence: `Payload "${payload.substring(0, 50)}" found in response`,
          mitreId: "T1059.007",
        });
      } else {
        indicators.push({
          type: "payload_reflected",
          severity: "medium",
          description: "Payload reflected in non-HTML response",
          evidence: `Payload found in ${contentType} response`,
        });
      }
    }

    for (const pattern of VULN_PATTERNS.xss.reflectionPatterns) {
      if (pattern.test(body)) {
        indicators.push({
          type: "xss_pattern_match",
          severity: "high",
          description: "Potential XSS pattern detected in response",
          evidence: `Pattern ${pattern.source} matched`,
          mitreId: "T1059.007",
        });
        break;
      }
    }

    return indicators;
  }

  private analyzeRce(response: ExploitResponse): VulnerabilityIndicator[] {
    const indicators: VulnerabilityIndicator[] = [];
    const body = response.body || "";

    for (const pattern of VULN_PATTERNS.rce.patterns) {
      const match = body.match(pattern);
      if (match) {
        indicators.push({
          type: "rce_command_output",
          severity: "critical",
          description: "Command execution output detected in response",
          evidence: match[0].substring(0, 200),
          mitreId: "T1059",
        });
        break;
      }
    }

    return indicators;
  }

  private analyzeSsrf(response: ExploitResponse): VulnerabilityIndicator[] {
    const indicators: VulnerabilityIndicator[] = [];
    const body = response.body || "";

    for (const pattern of VULN_PATTERNS.ssrf.internalPatterns) {
      if (pattern.test(body)) {
        indicators.push({
          type: "ssrf_internal_access",
          severity: "high",
          description: "Response contains internal resource data",
          evidence: `Internal pattern ${pattern.source} matched in response`,
          mitreId: "T1090",
        });
        break;
      }
    }

    if (response.redirectChain.length > 0) {
      const hasInternalRedirect = response.redirectChain.some(url => {
        try {
          const parsed = new URL(url);
          return VULN_PATTERNS.ssrf.internalPatterns.some(p => 
            p.test(parsed.hostname)
          );
        } catch {
          return false;
        }
      });

      if (hasInternalRedirect) {
        indicators.push({
          type: "ssrf_redirect_internal",
          severity: "high",
          description: "Redirect chain includes internal resources",
          evidence: `Redirect chain: ${response.redirectChain.join(" -> ")}`,
          mitreId: "T1090",
        });
      }
    }

    return indicators;
  }

  private analyzePathTraversal(response: ExploitResponse): VulnerabilityIndicator[] {
    const indicators: VulnerabilityIndicator[] = [];
    const body = response.body || "";

    for (const pattern of VULN_PATTERNS.pathTraversal.patterns) {
      if (pattern.test(body)) {
        indicators.push({
          type: "path_traversal",
          severity: "critical",
          description: "Sensitive file content detected in response",
          evidence: `Pattern matched: ${pattern.source}`,
          mitreId: "T1005",
        });
        break;
      }
    }

    return indicators;
  }

  private analyzeXxe(response: ExploitResponse): VulnerabilityIndicator[] {
    const indicators: VulnerabilityIndicator[] = [];
    const body = response.body || "";

    for (const pattern of VULN_PATTERNS.xxe.patterns) {
      if (pattern.test(body)) {
        indicators.push({
          type: "xxe_entity_expansion",
          severity: "critical",
          description: "XXE attack successful - external entity processed",
          evidence: `Pattern matched: ${pattern.source}`,
          mitreId: "T1611",
        });
        break;
      }
    }

    return indicators;
  }

  private calculateConfidence(indicators: VulnerabilityIndicator[]): number {
    if (indicators.length === 0) return 0;

    let confidence = 0;
    for (const indicator of indicators) {
      switch (indicator.severity) {
        case "critical":
          confidence += 40;
          break;
        case "high":
          confidence += 25;
          break;
        case "medium":
          confidence += 15;
          break;
        case "low":
          confidence += 5;
          break;
        case "info":
          confidence += 2;
          break;
      }
    }

    return Math.min(100, confidence);
  }
}

export const httpExploitDispatcher = new HttpExploitDispatcher();
