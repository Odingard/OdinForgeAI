/**
 * OdinForge AI — Exploit Agent Benchmark Harness
 *
 * Runs the agentic exploit agent against known-vulnerable targets
 * and scores its ability to find and validate real vulnerabilities.
 *
 * Usage:
 *   npx tsx server/benchmark/exploit-benchmark.ts [target_url] [mode] [options]
 *
 * Options:
 *   --target <name>                 Benchmark target (default: juice-shop). Available: juice-shop, dvwa, webgoat
 *   --output <path>                 Write JSON report to specific path (default: /tmp/odinforge-benchmark-<ts>.json)
 *   --threshold-pass-rate <n>       Fail if fewer than n scenarios pass (for CI gating)
 *   --threshold-detection-rate <n>  Fail if detection rate is below n% (for CI gating)
 *
 * Examples:
 *   npx tsx server/benchmark/exploit-benchmark.ts http://localhost:3001 simulation
 *   npx tsx server/benchmark/exploit-benchmark.ts http://localhost:3001 simulation --target juice-shop
 *   npx tsx server/benchmark/exploit-benchmark.ts http://localhost:3002 simulation --target dvwa
 *   npx tsx server/benchmark/exploit-benchmark.ts http://localhost:3001 simulation --threshold-pass-rate 4 --threshold-detection-rate 70
 */

import "dotenv/config";
import { runExploitAgent } from "../services/agents/exploit";
import type { AgentMemory, ExploitFindings } from "../services/agents/types";
import { getTarget, listTargets } from "./targets";
import type { BenchmarkScenario, BenchmarkTarget } from "./targets";

// ─── CLI Args ───────────────────────────────────────────────────────

function parseArgs() {
  const args = process.argv.slice(2);
  let target = "http://localhost:3001";
  let mode: "safe" | "simulation" | "live" = "simulation";
  let targetName = "juice-shop";
  let output = "";
  let thresholdPassRate = -1;
  let thresholdDetectionRate = -1;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === "--output" && args[i + 1]) {
      output = args[++i];
    } else if (args[i] === "--threshold-pass-rate" && args[i + 1]) {
      thresholdPassRate = parseInt(args[++i], 10);
    } else if (args[i] === "--threshold-detection-rate" && args[i + 1]) {
      thresholdDetectionRate = parseInt(args[++i], 10);
    } else if (args[i] === "--target" && args[i + 1]) {
      targetName = args[++i];
    } else if (!args[i].startsWith("--")) {
      if (!target || target === "http://localhost:3001") {
        if (args[i].startsWith("http")) target = args[i];
        else if (["safe", "simulation", "live"].includes(args[i])) mode = args[i] as typeof mode;
      } else {
        if (["safe", "simulation", "live"].includes(args[i])) mode = args[i] as typeof mode;
      }
    }
  }

  return { target, mode, targetName, output, thresholdPassRate, thresholdDetectionRate };
}

const CLI = parseArgs();

// ─── Configuration ──────────────────────────────────────────────────

let targetConfig: BenchmarkTarget;
try {
  targetConfig = getTarget(CLI.targetName);
} catch (err: any) {
  console.error(err.message);
  console.error(`Available targets: ${listTargets().join(", ")}`);
  process.exit(1);
}

const TARGET_URL = CLI.target;
const EXECUTION_MODE = CLI.mode;

// ─── Scoring ────────────────────────────────────────────────────────

interface ScenarioResult {
  scenarioId: string;
  scenarioName: string;
  success: boolean;
  exploitable: boolean;
  chainsFound: number;
  validatedChains: number;
  toolCallsMade: number;
  vulnTypesFound: string[];
  expectedVulnTypes: string[];
  matchedExpected: string[];
  missedExpected: string[];
  processingTimeMs: number;
  findings: ExploitFindings;
  error?: string;
}

function scoreScenario(
  scenario: BenchmarkScenario,
  result: ExploitFindings,
  processingTime: number
): ScenarioResult {
  const chainsText = result.exploitChains
    .map((c) => `${c.name} ${c.description} ${c.technique}`)
    .join(" ")
    .toLowerCase();

  const misconfigText = result.misconfigurations.join(" ").toLowerCase();

  // Include tool call results for comprehensive vuln detection
  const toolCallText = (result.toolCallLog || [])
    .map((tc: { toolName: string; resultSummary: string }) => `${tc.toolName} ${tc.resultSummary}`)
    .join(" ")
    .toLowerCase();

  const allText = chainsText + " " + misconfigText + " " + toolCallText;

  const matchedExpected: string[] = [];
  const missedExpected: string[] = [];

  for (const expected of scenario.expectedVulnTypes) {
    const vulnDef = targetConfig.expectedVulns.find(
      (v) => v.keywords.includes(expected) || v.name.toLowerCase().includes(expected)
    );
    const keywords = vulnDef?.keywords || [expected];
    const found = keywords.some((kw) => allText.includes(kw));
    if (found) {
      matchedExpected.push(expected);
    } else {
      missedExpected.push(expected);
    }
  }

  const vulnTypesFound: string[] = [];
  for (const vd of targetConfig.expectedVulns) {
    if (vd.keywords.some((kw) => allText.includes(kw))) {
      vulnTypesFound.push(vd.name);
    }
  }

  const validatedChains = result.exploitChains.filter((c) => c.validated).length;

  return {
    scenarioId: scenario.id,
    scenarioName: scenario.name,
    success: matchedExpected.length > 0,
    exploitable: result.exploitable,
    chainsFound: result.exploitChains.length,
    validatedChains,
    toolCallsMade: result.toolCallLog?.length || 0,
    vulnTypesFound,
    expectedVulnTypes: scenario.expectedVulnTypes,
    matchedExpected,
    missedExpected,
    processingTimeMs: processingTime,
    findings: result,
  };
}

// ─── Runner ─────────────────────────────────────────────────────────

async function runScenario(scenario: BenchmarkScenario): Promise<ScenarioResult> {
  const description = typeof scenario.description === "function"
    ? scenario.description(TARGET_URL)
    : scenario.description;

  const memory: AgentMemory = {
    context: {
      assetId: `benchmark-${scenario.id}`,
      exposureType: scenario.exposureType,
      priority: "critical",
      description,
      evaluationId: `bench-eval-${scenario.id}-${Date.now()}`,
      executionMode: EXECUTION_MODE,
      organizationId: "benchmark-org",
    },
  };

  const startTime = Date.now();

  try {
    const result = await runExploitAgent(memory, (stage, progress, message) => {
      process.stdout.write(`  [${scenario.id}] ${progress}% ${message}\r`);
    });

    const elapsed = Date.now() - startTime;
    console.log(`  [${scenario.id}] Completed in ${(elapsed / 1000).toFixed(1)}s`);

    return scoreScenario(scenario, result.findings, elapsed);
  } catch (error: any) {
    const elapsed = Date.now() - startTime;
    console.log(`  [${scenario.id}] FAILED: ${error.message}`);

    return {
      scenarioId: scenario.id,
      scenarioName: scenario.name,
      success: false,
      exploitable: false,
      chainsFound: 0,
      validatedChains: 0,
      toolCallsMade: 0,
      vulnTypesFound: [],
      expectedVulnTypes: scenario.expectedVulnTypes,
      matchedExpected: [],
      missedExpected: scenario.expectedVulnTypes,
      processingTimeMs: elapsed,
      findings: { exploitable: false, exploitChains: [], cveReferences: [], misconfigurations: [] },
      error: error.message,
    };
  }
}

// ─── Main ───────────────────────────────────────────────────────────

async function main() {
  console.log("═══════════════════════════════════════════════════════════");
  console.log("  OdinForge AI — Exploit Agent Benchmark");
  console.log("═══════════════════════════════════════════════════════════");
  console.log(`  Target:    ${targetConfig.displayName} (${targetConfig.version})`);
  console.log(`  URL:       ${TARGET_URL}`);
  console.log(`  Mode:      ${EXECUTION_MODE}`);
  console.log(`  Scenarios: ${targetConfig.scenarios.length}`);
  console.log(`  Time:      ${new Date().toISOString()}`);
  console.log("───────────────────────────────────────────────────────────\n");

  // Verify target is reachable
  try {
    const resp = await fetch(TARGET_URL);
    console.log(`  Target reachable: ${resp.status} ${resp.statusText}\n`);
  } catch (err: any) {
    console.error(`  ERROR: Cannot reach ${TARGET_URL}: ${err.message}`);
    process.exit(1);
  }

  // Run target-specific setup if defined
  if (targetConfig.setup) {
    try {
      await targetConfig.setup(TARGET_URL);
    } catch (err: any) {
      console.error(`  ERROR: Target setup failed: ${err.message}`);
      process.exit(1);
    }
  }

  const results: ScenarioResult[] = [];

  for (const scenario of targetConfig.scenarios) {
    console.log(`▶ ${scenario.name} (${scenario.id})`);
    const result = await runScenario(scenario);
    results.push(result);
    console.log();
  }

  // ── Summary ─────────────────────────────────────────────────────

  console.log("═══════════════════════════════════════════════════════════");
  console.log("  RESULTS SUMMARY");
  console.log("═══════════════════════════════════════════════════════════\n");

  let totalExpected = 0;
  let totalMatched = 0;
  let totalChains = 0;
  let totalValidated = 0;
  let totalToolCalls = 0;
  let totalTime = 0;

  for (const r of results) {
    const status = r.success ? "✅ PASS" : "❌ FAIL";
    console.log(`  ${status}  ${r.scenarioName}`);
    console.log(`         Chains: ${r.chainsFound} found, ${r.validatedChains} validated`);
    console.log(`         Tools:  ${r.toolCallsMade} calls`);
    console.log(`         Found:  ${r.vulnTypesFound.join(", ") || "none"}`);
    if (r.matchedExpected.length > 0) {
      console.log(`         Hit:    ${r.matchedExpected.join(", ")}`);
    }
    if (r.missedExpected.length > 0) {
      console.log(`         Missed: ${r.missedExpected.join(", ")}`);
    }
    if (r.error) {
      console.log(`         Error:  ${r.error}`);
    }
    console.log(`         Time:   ${(r.processingTimeMs / 1000).toFixed(1)}s`);
    console.log();

    totalExpected += r.expectedVulnTypes.length;
    totalMatched += r.matchedExpected.length;
    totalChains += r.chainsFound;
    totalValidated += r.validatedChains;
    totalToolCalls += r.toolCallsMade;
    totalTime += r.processingTimeMs;
  }

  const passRate = results.filter((r) => r.success).length;
  const detectionRate = totalExpected > 0 ? ((totalMatched / totalExpected) * 100).toFixed(1) : "0";

  console.log("───────────────────────────────────────────────────────────");
  console.log(`  Scenarios:        ${passRate}/${results.length} passed (${((passRate / results.length) * 100).toFixed(0)}%)`);
  console.log(`  Detection Rate:   ${totalMatched}/${totalExpected} expected vulns found (${detectionRate}%)`);
  console.log(`  Exploit Chains:   ${totalChains} found, ${totalValidated} tool-validated`);
  console.log(`  Tool Calls:       ${totalToolCalls} total`);
  console.log(`  Total Time:       ${(totalTime / 1000).toFixed(1)}s`);
  console.log(`  Avg per Scenario: ${(totalTime / results.length / 1000).toFixed(1)}s`);
  console.log("═══════════════════════════════════════════════════════════\n");

  // ── JSON Report ───────────────────────────────────────────────────

  const outputPath = CLI.output || `/tmp/odinforge-benchmark-${Date.now()}.json`;
  const report = {
    meta: {
      target: TARGET_URL,
      targetName: targetConfig.name,
      targetDisplayName: targetConfig.displayName,
      targetVersion: targetConfig.version,
      executionMode: EXECUTION_MODE,
      timestamp: new Date().toISOString(),
      scenarioCount: targetConfig.scenarios.length,
      passRate: `${passRate}/${results.length}`,
      detectionRate: `${detectionRate}%`,
      totalToolCalls,
      totalTimeMs: totalTime,
    },
    results: results.map((r) => ({
      ...r,
      findings: {
        exploitable: r.findings.exploitable,
        chainsCount: r.findings.exploitChains.length,
        chains: r.findings.exploitChains.map((c) => ({
          name: c.name,
          technique: c.technique,
          likelihood: c.success_likelihood,
          validated: c.validated || false,
          verdict: c.validationVerdict,
          confidence: c.validationConfidence,
        })),
        cveReferences: r.findings.cveReferences,
        misconfigurations: r.findings.misconfigurations,
        toolCallLog: r.findings.toolCallLog,
      },
    })),
  };

  const fs = await import("fs");
  const path = await import("path");

  const outputDir = path.dirname(outputPath);
  if (outputDir !== "." && outputDir !== "/tmp") {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(outputPath, JSON.stringify(report, null, 2));

  console.log(`  Full report: ${outputPath}\n`);

  // ── Threshold checks (CI gating) ─────────────────────────────────

  let exitCode = 0;

  if (CLI.thresholdPassRate >= 0) {
    if (passRate < CLI.thresholdPassRate) {
      console.log(`  THRESHOLD FAILED: pass rate ${passRate}/${results.length} < required ${CLI.thresholdPassRate}/${results.length}`);
      exitCode = 1;
    } else {
      console.log(`  THRESHOLD OK: pass rate ${passRate}/${results.length} >= ${CLI.thresholdPassRate}/${results.length}`);
    }
  }

  if (CLI.thresholdDetectionRate >= 0) {
    const actualDetRate = totalExpected > 0 ? Math.round((totalMatched / totalExpected) * 100) : 0;
    if (actualDetRate < CLI.thresholdDetectionRate) {
      console.log(`  THRESHOLD FAILED: detection rate ${actualDetRate}% < required ${CLI.thresholdDetectionRate}%`);
      exitCode = 1;
    } else {
      console.log(`  THRESHOLD OK: detection rate ${actualDetRate}% >= ${CLI.thresholdDetectionRate}%`);
    }
  }

  if (CLI.thresholdPassRate < 0 && CLI.thresholdDetectionRate < 0) {
    exitCode = passRate === results.length ? 0 : 1;
  }

  process.exit(exitCode);
}

main().catch((err) => {
  console.error("Benchmark failed:", err);
  process.exit(2);
});
